// Code generated by telegram-bot-api-types. DO NOT EDIT.
// Version 8.2
import Foundation

public struct TelegramAPI {
    let request: (String, Codable) throws -> Data

    public init(request: @escaping (String, Codable) throws -> Data) {
        self.request = request
    }

    public class ValueWrapper<T: Codable>: Codable {
        let value: T
        init(value: T) {
            self.value = value
        }
    }

    public struct Empty: Codable {}
}

extension TelegramAPI {
    public enum ChatType: String, Codable {
        case `private` = "private"
        case `group` = "group"
        case `supergroup` = "supergroup"
        case `channel` = "channel"
    }
}

extension TelegramAPI {
    public enum ChatAction: String, Codable {
        case `typing` = "typing"
        case `upload_photo` = "upload_photo"
        case `record_video` = "record_video"
        case `upload_video` = "upload_video"
        case `record_voice` = "record_voice"
        case `upload_voice` = "upload_voice"
        case `upload_document` = "upload_document"
        case `find_location` = "find_location"
        case `record_video_note` = "record_video_note"
        case `upload_video_note` = "upload_video_note"
    }
}

extension TelegramAPI {
    public enum MessageEntityType: String, Codable {
        case `mention` = "mention"
        case `hashtag` = "hashtag"
        case `cashtag` = "cashtag"
        case `bot_command` = "bot_command"
        case `url` = "url"
        case `email` = "email"
        case `phone_number` = "phone_number"
        case `bold` = "bold"
        case `italic` = "italic"
        case `underline` = "underline"
        case `strikethrough` = "strikethrough"
        case `code` = "code"
        case `pre` = "pre"
        case `text_link` = "text_link"
        case `text_mention` = "text_mention"
        case `spoiler` = "spoiler"
        case `custom_emoji` = "custom_emoji"
    }
}

extension TelegramAPI {
    public enum ParseMode: String, Codable {
        case `Markdown` = "Markdown"
        case `MarkdownV2` = "MarkdownV2"
        case `HTML` = "HTML"
    }
}

extension TelegramAPI {
    /**
     * https://core.telegram.org/bots/api#update  
     * This object represents an incoming update.
     * At most one of the optional parameters can be present in any given update.
    */
    public struct Update: Codable {
        /** Integer | The update's unique identifier. Update identifiers start from a certain positive number and increase sequentially. This identifier becomes especially handy if you're using webhooks, since it allows you to ignore repeated updates or to restore the correct update sequence, should they get out of order. If there are no new updates for at least a week, then identifier of the next update will be chosen randomly instead of sequentially. */
        public let update_id: Int
        /** Message | Optional. New incoming message of any kind - text, photo, sticker, etc. */
        public let message: Message?
        /** Message | Optional. New version of a message that is known to the bot and was edited. This update may at times be triggered by changes to message fields that are either unavailable or not actively used by your bot. */
        public let edited_message: Message?
        /** Message | Optional. New incoming channel post of any kind - text, photo, sticker, etc. */
        public let channel_post: Message?
        /** Message | Optional. New version of a channel post that is known to the bot and was edited. This update may at times be triggered by changes to message fields that are either unavailable or not actively used by your bot. */
        public let edited_channel_post: Message?
        /** BusinessConnection | Optional. The bot was connected to or disconnected from a business account, or a user edited an existing connection with the bot */
        public let business_connection: BusinessConnection?
        /** Message | Optional. New message from a connected business account */
        public let business_message: Message?
        /** Message | Optional. New version of a message from a connected business account */
        public let edited_business_message: Message?
        /** BusinessMessagesDeleted | Optional. Messages were deleted from a connected business account */
        public let deleted_business_messages: BusinessMessagesDeleted?
        /** MessageReactionUpdated | Optional. A reaction to a message was changed by a user. The bot must be an administrator in the chat and must explicitly specify "message_reaction" in the list of allowed_updates to receive these updates. The update isn't received for reactions set by bots. */
        public let message_reaction: MessageReactionUpdated?
        /** MessageReactionCountUpdated | Optional. Reactions to a message with anonymous reactions were changed. The bot must be an administrator in the chat and must explicitly specify "message_reaction_count" in the list of allowed_updates to receive these updates. The updates are grouped and can be sent with delay up to a few minutes. */
        public let message_reaction_count: MessageReactionCountUpdated?
        /** InlineQuery | Optional. New incoming inline query */
        public let inline_query: InlineQuery?
        /** ChosenInlineResult | Optional. The result of an inline query that was chosen by a user and sent to their chat partner. Please see our documentation on the feedback collecting for details on how to enable these updates for your bot. */
        public let chosen_inline_result: ChosenInlineResult?
        /** CallbackQuery | Optional. New incoming callback query */
        public let callback_query: CallbackQuery?
        /** ShippingQuery | Optional. New incoming shipping query. Only for invoices with flexible price */
        public let shipping_query: ShippingQuery?
        /** PreCheckoutQuery | Optional. New incoming pre-checkout query. Contains full information about checkout */
        public let pre_checkout_query: PreCheckoutQuery?
        /** PaidMediaPurchased | Optional. A user purchased paid media with a non-empty payload sent by the bot in a non-channel chat */
        public let purchased_paid_media: PaidMediaPurchased?
        /** Poll | Optional. New poll state. Bots receive only updates about manually stopped polls and polls, which are sent by the bot */
        public let poll: Poll?
        /** PollAnswer | Optional. A user changed their answer in a non-anonymous poll. Bots receive new votes only in polls that were sent by the bot itself. */
        public let poll_answer: PollAnswer?
        /** ChatMemberUpdated | Optional. The bot's chat member status was updated in a chat. For private chats, this update is received only when the bot is blocked or unblocked by the user. */
        public let my_chat_member: ChatMemberUpdated?
        /** ChatMemberUpdated | Optional. A chat member's status was updated in a chat. The bot must be an administrator in the chat and must explicitly specify "chat_member" in the list of allowed_updates to receive these updates. */
        public let chat_member: ChatMemberUpdated?
        /** ChatJoinRequest | Optional. A request to join the chat has been sent. The bot must have the can_invite_users administrator right in the chat to receive these updates. */
        public let chat_join_request: ChatJoinRequest?
        /** ChatBoostUpdated | Optional. A chat boost was added or changed. The bot must be an administrator in the chat to receive these updates. */
        public let chat_boost: ChatBoostUpdated?
        /** ChatBoostRemoved | Optional. A boost was removed from a chat. The bot must be an administrator in the chat to receive these updates. */
        public let removed_chat_boost: ChatBoostRemoved?
        public init(update_id: Int ,message: Message? = nil ,edited_message: Message? = nil ,channel_post: Message? = nil ,edited_channel_post: Message? = nil ,business_connection: BusinessConnection? = nil ,business_message: Message? = nil ,edited_business_message: Message? = nil ,deleted_business_messages: BusinessMessagesDeleted? = nil ,message_reaction: MessageReactionUpdated? = nil ,message_reaction_count: MessageReactionCountUpdated? = nil ,inline_query: InlineQuery? = nil ,chosen_inline_result: ChosenInlineResult? = nil ,callback_query: CallbackQuery? = nil ,shipping_query: ShippingQuery? = nil ,pre_checkout_query: PreCheckoutQuery? = nil ,purchased_paid_media: PaidMediaPurchased? = nil ,poll: Poll? = nil ,poll_answer: PollAnswer? = nil ,my_chat_member: ChatMemberUpdated? = nil ,chat_member: ChatMemberUpdated? = nil ,chat_join_request: ChatJoinRequest? = nil ,chat_boost: ChatBoostUpdated? = nil ,removed_chat_boost: ChatBoostRemoved? = nil) {
            self.update_id = update_id
            self.message = message
            self.edited_message = edited_message
            self.channel_post = channel_post
            self.edited_channel_post = edited_channel_post
            self.business_connection = business_connection
            self.business_message = business_message
            self.edited_business_message = edited_business_message
            self.deleted_business_messages = deleted_business_messages
            self.message_reaction = message_reaction
            self.message_reaction_count = message_reaction_count
            self.inline_query = inline_query
            self.chosen_inline_result = chosen_inline_result
            self.callback_query = callback_query
            self.shipping_query = shipping_query
            self.pre_checkout_query = pre_checkout_query
            self.purchased_paid_media = purchased_paid_media
            self.poll = poll
            self.poll_answer = poll_answer
            self.my_chat_member = my_chat_member
            self.chat_member = chat_member
            self.chat_join_request = chat_join_request
            self.chat_boost = chat_boost
            self.removed_chat_boost = removed_chat_boost
        }
    }
}

extension TelegramAPI {
    /**
     * https://core.telegram.org/bots/api#webhookinfo  
     * Describes the current status of a webhook.
    */
    public struct WebhookInfo: Codable {
        /** String | Webhook URL, may be empty if webhook is not set up */
        public let url: String
        /** Boolean | True, if a custom certificate was provided for webhook certificate checks */
        public let has_custom_certificate: Bool
        /** Integer | Number of updates awaiting delivery */
        public let pending_update_count: Int
        /** String | Optional. Currently used webhook IP address */
        public let ip_address: String?
        /** Integer | Optional. Unix time for the most recent error that happened when trying to deliver an update via webhook */
        public let last_error_date: Int?
        /** String | Optional. Error message in human-readable format for the most recent error that happened when trying to deliver an update via webhook */
        public let last_error_message: String?
        /** Integer | Optional. Unix time of the most recent error that happened when trying to synchronize available updates with Telegram datacenters */
        public let last_synchronization_error_date: Int?
        /** Integer | Optional. The maximum allowed number of simultaneous HTTPS connections to the webhook for update delivery */
        public let max_connections: Int?
        /** Array of String | Optional. A list of update types the bot is subscribed to. Defaults to all update types except chat_member */
        public let allowed_updates: Array<String>?
        public init(url: String ,has_custom_certificate: Bool ,pending_update_count: Int ,ip_address: String? = nil ,last_error_date: Int? = nil ,last_error_message: String? = nil ,last_synchronization_error_date: Int? = nil ,max_connections: Int? = nil ,allowed_updates: Array<String>? = nil) {
            self.url = url
            self.has_custom_certificate = has_custom_certificate
            self.pending_update_count = pending_update_count
            self.ip_address = ip_address
            self.last_error_date = last_error_date
            self.last_error_message = last_error_message
            self.last_synchronization_error_date = last_synchronization_error_date
            self.max_connections = max_connections
            self.allowed_updates = allowed_updates
        }
    }
}

extension TelegramAPI {
    /**
     * https://core.telegram.org/bots/api#user  
     * This object represents a Telegram user or bot.
    */
    public struct User: Codable {
        /** Integer | Unique identifier for this user or bot. This number may have more than 32 significant bits and some programming languages may have difficulty/silent defects in interpreting it. But it has at most 52 significant bits, so a 64-bit integer or double-precision float type are safe for storing this identifier. */
        public let id: Int
        /** Boolean | True, if this user is a bot */
        public let is_bot: Bool
        /** String | User's or bot's first name */
        public let first_name: String
        /** String | Optional. User's or bot's last name */
        public let last_name: String?
        /** String | Optional. User's or bot's username */
        public let username: String?
        /** String | Optional. IETF language tag of the user's language */
        public let language_code: String?
        /** Boolean | Optional. True, if this user is a Telegram Premium user */
        public let is_premium: Bool?
        /** Boolean | Optional. True, if this user added the bot to the attachment menu */
        public let added_to_attachment_menu: Bool?
        /** Boolean | Optional. True, if the bot can be invited to groups. Returned only in getMe. */
        public let can_join_groups: Bool?
        /** Boolean | Optional. True, if privacy mode is disabled for the bot. Returned only in getMe. */
        public let can_read_all_group_messages: Bool?
        /** Boolean | Optional. True, if the bot supports inline queries. Returned only in getMe. */
        public let supports_inline_queries: Bool?
        /** Boolean | Optional. True, if the bot can be connected to a Telegram Business account to receive its messages. Returned only in getMe. */
        public let can_connect_to_business: Bool?
        /** Boolean | Optional. True, if the bot has a main Web App. Returned only in getMe. */
        public let has_main_web_app: Bool?
        public init(id: Int ,is_bot: Bool ,first_name: String ,last_name: String? = nil ,username: String? = nil ,language_code: String? = nil ,is_premium: Bool? = nil ,added_to_attachment_menu: Bool? = nil ,can_join_groups: Bool? = nil ,can_read_all_group_messages: Bool? = nil ,supports_inline_queries: Bool? = nil ,can_connect_to_business: Bool? = nil ,has_main_web_app: Bool? = nil) {
            self.id = id
            self.is_bot = is_bot
            self.first_name = first_name
            self.last_name = last_name
            self.username = username
            self.language_code = language_code
            self.is_premium = is_premium
            self.added_to_attachment_menu = added_to_attachment_menu
            self.can_join_groups = can_join_groups
            self.can_read_all_group_messages = can_read_all_group_messages
            self.supports_inline_queries = supports_inline_queries
            self.can_connect_to_business = can_connect_to_business
            self.has_main_web_app = has_main_web_app
        }
    }
}

extension TelegramAPI {
    /**
     * https://core.telegram.org/bots/api#chat  
     * This object represents a chat.
    */
    public struct Chat: Codable {
        /** Integer | Unique identifier for this chat. This number may have more than 32 significant bits and some programming languages may have difficulty/silent defects in interpreting it. But it has at most 52 significant bits, so a signed 64-bit integer or double-precision float type are safe for storing this identifier. */
        public let id: Int
        /** ChatType | Type of the chat, can be either "private", "group", "supergroup" or "channel" */
        public let type: ChatType
        /** String | Optional. Title, for supergroups, channels and group chats */
        public let title: String?
        /** String | Optional. Username, for private chats, supergroups and channels if available */
        public let username: String?
        /** String | Optional. First name of the other party in a private chat */
        public let first_name: String?
        /** String | Optional. Last name of the other party in a private chat */
        public let last_name: String?
        /** Boolean | Optional. True, if the supergroup chat is a forum (has topics enabled) */
        public let is_forum: Bool?
        public init(id: Int ,type: ChatType ,title: String? = nil ,username: String? = nil ,first_name: String? = nil ,last_name: String? = nil ,is_forum: Bool? = nil) {
            self.id = id
            self.type = type
            self.title = title
            self.username = username
            self.first_name = first_name
            self.last_name = last_name
            self.is_forum = is_forum
        }
    }
}

extension TelegramAPI {
    /**
     * https://core.telegram.org/bots/api#chatfullinfo  
     * This object contains full information about a chat.
    */
    public struct ChatFullInfo: Codable {
        /** Integer | Unique identifier for this chat. This number may have more than 32 significant bits and some programming languages may have difficulty/silent defects in interpreting it. But it has at most 52 significant bits, so a signed 64-bit integer or double-precision float type are safe for storing this identifier. */
        public let id: Int
        /** ChatType | Type of the chat, can be either "private", "group", "supergroup" or "channel" */
        public let type: ChatType
        /** String | Optional. Title, for supergroups, channels and group chats */
        public let title: String?
        /** String | Optional. Username, for private chats, supergroups and channels if available */
        public let username: String?
        /** String | Optional. First name of the other party in a private chat */
        public let first_name: String?
        /** String | Optional. Last name of the other party in a private chat */
        public let last_name: String?
        /** Boolean | Optional. True, if the supergroup chat is a forum (has topics enabled) */
        public let is_forum: Bool?
        /** Integer | Identifier of the accent color for the chat name and backgrounds of the chat photo, reply header, and link preview. See accent colors for more details. */
        public let accent_color_id: Int
        /** Integer | The maximum number of reactions that can be set on a message in the chat */
        public let max_reaction_count: Int
        /** ChatPhoto | Optional. Chat photo */
        public let photo: ChatPhoto?
        /** Array of String | Optional. If non-empty, the list of all active chat usernames; for private chats, supergroups and channels */
        public let active_usernames: Array<String>?
        /** Birthdate | Optional. For private chats, the date of birth of the user */
        public let birthdate: Birthdate?
        /** BusinessIntro | Optional. For private chats with business accounts, the intro of the business */
        public let business_intro: BusinessIntro?
        /** BusinessLocation | Optional. For private chats with business accounts, the location of the business */
        public let business_location: BusinessLocation?
        /** BusinessOpeningHours | Optional. For private chats with business accounts, the opening hours of the business */
        public let business_opening_hours: BusinessOpeningHours?
        /** Chat | Optional. For private chats, the personal channel of the user */
        public let personal_chat: Chat?
        /** Array of ReactionType | Optional. List of available reactions allowed in the chat. If omitted, then all emoji reactions are allowed. */
        public let available_reactions: Array<ReactionType>?
        /** String | Optional. Custom emoji identifier of the emoji chosen by the chat for the reply header and link preview background */
        public let background_custom_emoji_id: String?
        /** Integer | Optional. Identifier of the accent color for the chat's profile background. See profile accent colors for more details. */
        public let profile_accent_color_id: Int?
        /** String | Optional. Custom emoji identifier of the emoji chosen by the chat for its profile background */
        public let profile_background_custom_emoji_id: String?
        /** String | Optional. Custom emoji identifier of the emoji status of the chat or the other party in a private chat */
        public let emoji_status_custom_emoji_id: String?
        /** Integer | Optional. Expiration date of the emoji status of the chat or the other party in a private chat, in Unix time, if any */
        public let emoji_status_expiration_date: Int?
        /** String | Optional. Bio of the other party in a private chat */
        public let bio: String?
        /** Boolean | Optional. True, if privacy settings of the other party in the private chat allows to use tg://user?id=<user_id> links only in chats with the user */
        public let has_private_forwards: Bool?
        /** Boolean | Optional. True, if the privacy settings of the other party restrict sending voice and video note messages in the private chat */
        public let has_restricted_voice_and_video_messages: Bool?
        /** Boolean | Optional. True, if users need to join the supergroup before they can send messages */
        public let join_to_send_messages: Bool?
        /** Boolean | Optional. True, if all users directly joining the supergroup without using an invite link need to be approved by supergroup administrators */
        public let join_by_request: Bool?
        /** String | Optional. Description, for groups, supergroups and channel chats */
        public let description: String?
        /** String | Optional. Primary invite link, for groups, supergroups and channel chats */
        public let invite_link: String?
        /** Message | Optional. The most recent pinned message (by sending date) */
        public let pinned_message: Message?
        /** ChatPermissions | Optional. Default chat member permissions, for groups and supergroups */
        public let permissions: ChatPermissions?
        /** Boolean | Optional. True, if paid media messages can be sent or forwarded to the channel chat. The field is available only for channel chats. */
        public let can_send_paid_media: Bool?
        /** Integer | Optional. For supergroups, the minimum allowed delay between consecutive messages sent by each unprivileged user; in seconds */
        public let slow_mode_delay: Int?
        /** Integer | Optional. For supergroups, the minimum number of boosts that a non-administrator user needs to add in order to ignore slow mode and chat permissions */
        public let unrestrict_boost_count: Int?
        /** Integer | Optional. The time after which all messages sent to the chat will be automatically deleted; in seconds */
        public let message_auto_delete_time: Int?
        /** Boolean | Optional. True, if aggressive anti-spam checks are enabled in the supergroup. The field is only available to chat administrators. */
        public let has_aggressive_anti_spam_enabled: Bool?
        /** Boolean | Optional. True, if non-administrators can only get the list of bots and administrators in the chat */
        public let has_hidden_members: Bool?
        /** Boolean | Optional. True, if messages from the chat can't be forwarded to other chats */
        public let has_protected_content: Bool?
        /** Boolean | Optional. True, if new chat members will have access to old messages; available only to chat administrators */
        public let has_visible_history: Bool?
        /** String | Optional. For supergroups, name of the group sticker set */
        public let sticker_set_name: String?
        /** Boolean | Optional. True, if the bot can change the group sticker set */
        public let can_set_sticker_set: Bool?
        /** String | Optional. For supergroups, the name of the group's custom emoji sticker set. Custom emoji from this set can be used by all users and bots in the group. */
        public let custom_emoji_sticker_set_name: String?
        /** Integer | Optional. Unique identifier for the linked chat, i.e. the discussion group identifier for a channel and vice versa; for supergroups and channel chats. This identifier may be greater than 32 bits and some programming languages may have difficulty/silent defects in interpreting it. But it is smaller than 52 bits, so a signed 64 bit integer or double-precision float type are safe for storing this identifier. */
        public let linked_chat_id: Int?
        /** ChatLocation | Optional. For supergroups, the location to which the supergroup is connected */
        public let location: ChatLocation?
        public init(id: Int ,type: ChatType ,title: String? = nil ,username: String? = nil ,first_name: String? = nil ,last_name: String? = nil ,is_forum: Bool? = nil ,accent_color_id: Int ,max_reaction_count: Int ,photo: ChatPhoto? = nil ,active_usernames: Array<String>? = nil ,birthdate: Birthdate? = nil ,business_intro: BusinessIntro? = nil ,business_location: BusinessLocation? = nil ,business_opening_hours: BusinessOpeningHours? = nil ,personal_chat: Chat? = nil ,available_reactions: Array<ReactionType>? = nil ,background_custom_emoji_id: String? = nil ,profile_accent_color_id: Int? = nil ,profile_background_custom_emoji_id: String? = nil ,emoji_status_custom_emoji_id: String? = nil ,emoji_status_expiration_date: Int? = nil ,bio: String? = nil ,has_private_forwards: Bool? = nil ,has_restricted_voice_and_video_messages: Bool? = nil ,join_to_send_messages: Bool? = nil ,join_by_request: Bool? = nil ,description: String? = nil ,invite_link: String? = nil ,pinned_message: Message? = nil ,permissions: ChatPermissions? = nil ,can_send_paid_media: Bool? = nil ,slow_mode_delay: Int? = nil ,unrestrict_boost_count: Int? = nil ,message_auto_delete_time: Int? = nil ,has_aggressive_anti_spam_enabled: Bool? = nil ,has_hidden_members: Bool? = nil ,has_protected_content: Bool? = nil ,has_visible_history: Bool? = nil ,sticker_set_name: String? = nil ,can_set_sticker_set: Bool? = nil ,custom_emoji_sticker_set_name: String? = nil ,linked_chat_id: Int? = nil ,location: ChatLocation? = nil) {
            self.id = id
            self.type = type
            self.title = title
            self.username = username
            self.first_name = first_name
            self.last_name = last_name
            self.is_forum = is_forum
            self.accent_color_id = accent_color_id
            self.max_reaction_count = max_reaction_count
            self.photo = photo
            self.active_usernames = active_usernames
            self.birthdate = birthdate
            self.business_intro = business_intro
            self.business_location = business_location
            self.business_opening_hours = business_opening_hours
            self.personal_chat = personal_chat
            self.available_reactions = available_reactions
            self.background_custom_emoji_id = background_custom_emoji_id
            self.profile_accent_color_id = profile_accent_color_id
            self.profile_background_custom_emoji_id = profile_background_custom_emoji_id
            self.emoji_status_custom_emoji_id = emoji_status_custom_emoji_id
            self.emoji_status_expiration_date = emoji_status_expiration_date
            self.bio = bio
            self.has_private_forwards = has_private_forwards
            self.has_restricted_voice_and_video_messages = has_restricted_voice_and_video_messages
            self.join_to_send_messages = join_to_send_messages
            self.join_by_request = join_by_request
            self.description = description
            self.invite_link = invite_link
            self.pinned_message = pinned_message
            self.permissions = permissions
            self.can_send_paid_media = can_send_paid_media
            self.slow_mode_delay = slow_mode_delay
            self.unrestrict_boost_count = unrestrict_boost_count
            self.message_auto_delete_time = message_auto_delete_time
            self.has_aggressive_anti_spam_enabled = has_aggressive_anti_spam_enabled
            self.has_hidden_members = has_hidden_members
            self.has_protected_content = has_protected_content
            self.has_visible_history = has_visible_history
            self.sticker_set_name = sticker_set_name
            self.can_set_sticker_set = can_set_sticker_set
            self.custom_emoji_sticker_set_name = custom_emoji_sticker_set_name
            self.linked_chat_id = linked_chat_id
            self.location = location
        }
    }
}

extension TelegramAPI {
    /**
     * https://core.telegram.org/bots/api#message  
     * This object represents a message.
    */
    public struct Message: Codable {
        /** Integer | Unique message identifier inside this chat. In specific instances (e.g., message containing a video sent to a big chat), the server might automatically schedule a message instead of sending it immediately. In such cases, this field will be 0 and the relevant message will be unusable until it is actually sent */
        public let message_id: Int
        /** Integer | Optional. Unique identifier of a message thread to which the message belongs; for supergroups only */
        public let message_thread_id: Int?
        /** User | Optional. Sender of the message; may be empty for messages sent to channels. For backward compatibility, if the message was sent on behalf of a chat, the field contains a fake sender user in non-channel chats */
        public let from: User?
        /** Chat | Optional. Sender of the message when sent on behalf of a chat. For example, the supergroup itself for messages sent by its anonymous administrators or a linked channel for messages automatically forwarded to the channel's discussion group. For backward compatibility, if the message was sent on behalf of a chat, the field from contains a fake sender user in non-channel chats. */
        public let sender_chat: Chat?
        /** Integer | Optional. If the sender of the message boosted the chat, the number of boosts added by the user */
        public let sender_boost_count: Int?
        /** User | Optional. The bot that actually sent the message on behalf of the business account. Available only for outgoing messages sent on behalf of the connected business account. */
        public let sender_business_bot: User?
        /** Integer | Date the message was sent in Unix time. It is always a positive number, representing a valid date. */
        public let date: Int
        /** String | Optional. Unique identifier of the business connection from which the message was received. If non-empty, the message belongs to a chat of the corresponding business account that is independent from any potential bot chat which might share the same identifier. */
        public let business_connection_id: String?
        /** Chat | Chat the message belongs to */
        public let chat: Chat
        /** MessageOrigin | Optional. Information about the original message for forwarded messages */
        public let forward_origin: MessageOrigin?
        /** Boolean | Optional. True, if the message is sent to a forum topic */
        public let is_topic_message: Bool?
        /** Boolean | Optional. True, if the message is a channel post that was automatically forwarded to the connected discussion group */
        public let is_automatic_forward: Bool?
        /** ValueWrapper<Message> | Optional. For replies in the same chat and message thread, the original message. Note that the Message object in this field will not contain further reply_to_message fields even if it itself is a reply. */
        public let reply_to_message: ValueWrapper<Message>?
        /** ExternalReplyInfo | Optional. Information about the message that is being replied to, which may come from another chat or forum topic */
        public let external_reply: ExternalReplyInfo?
        /** TextQuote | Optional. For replies that quote part of the original message, the quoted part of the message */
        public let quote: TextQuote?
        /** Story | Optional. For replies to a story, the original story */
        public let reply_to_story: Story?
        /** User | Optional. Bot through which the message was sent */
        public let via_bot: User?
        /** Integer | Optional. Date the message was last edited in Unix time */
        public let edit_date: Int?
        /** Boolean | Optional. True, if the message can't be forwarded */
        public let has_protected_content: Bool?
        /** Boolean | Optional. True, if the message was sent by an implicit action, for example, as an away or a greeting business message, or as a scheduled message */
        public let is_from_offline: Bool?
        /** String | Optional. The unique identifier of a media message group this message belongs to */
        public let media_group_id: String?
        /** String | Optional. Signature of the post author for messages in channels, or the custom title of an anonymous group administrator */
        public let author_signature: String?
        /** String | Optional. For text messages, the actual UTF-8 text of the message */
        public let text: String?
        /** Array of MessageEntity | Optional. For text messages, special entities like usernames, URLs, bot commands, etc. that appear in the text */
        public let entities: Array<MessageEntity>?
        /** LinkPreviewOptions | Optional. Options used for link preview generation for the message, if it is a text message and link preview options were changed */
        public let link_preview_options: LinkPreviewOptions?
        /** String | Optional. Unique identifier of the message effect added to the message */
        public let effect_id: String?
        /** Animation | Optional. Message is an animation, information about the animation. For backward compatibility, when this field is set, the document field will also be set */
        public let animation: Animation?
        /** Audio | Optional. Message is an audio file, information about the file */
        public let audio: Audio?
        /** Document | Optional. Message is a general file, information about the file */
        public let document: Document?
        /** PaidMediaInfo | Optional. Message contains paid media; information about the paid media */
        public let paid_media: PaidMediaInfo?
        /** Array of PhotoSize | Optional. Message is a photo, available sizes of the photo */
        public let photo: Array<PhotoSize>?
        /** Sticker | Optional. Message is a sticker, information about the sticker */
        public let sticker: Sticker?
        /** Story | Optional. Message is a forwarded story */
        public let story: Story?
        /** Video | Optional. Message is a video, information about the video */
        public let video: Video?
        /** VideoNote | Optional. Message is a video note, information about the video message */
        public let video_note: VideoNote?
        /** Voice | Optional. Message is a voice message, information about the file */
        public let voice: Voice?
        /** String | Optional. Caption for the animation, audio, document, paid media, photo, video or voice */
        public let caption: String?
        /** Array of MessageEntity | Optional. For messages with a caption, special entities like usernames, URLs, bot commands, etc. that appear in the caption */
        public let caption_entities: Array<MessageEntity>?
        /** Boolean | Optional. True, if the caption must be shown above the message media */
        public let show_caption_above_media: Bool?
        /** Boolean | Optional. True, if the message media is covered by a spoiler animation */
        public let has_media_spoiler: Bool?
        /** Contact | Optional. Message is a shared contact, information about the contact */
        public let contact: Contact?
        /** Dice | Optional. Message is a dice with random value */
        public let dice: Dice?
        /** Game | Optional. Message is a game, information about the game. More about games: https://core.telegram.org/bots/api#games */
        public let game: Game?
        /** Poll | Optional. Message is a native poll, information about the poll */
        public let poll: Poll?
        /** Venue | Optional. Message is a venue, information about the venue. For backward compatibility, when this field is set, the location field will also be set */
        public let venue: Venue?
        /** Location | Optional. Message is a shared location, information about the location */
        public let location: Location?
        /** Array of User | Optional. New members that were added to the group or supergroup and information about them (the bot itself may be one of these members) */
        public let new_chat_members: Array<User>?
        /** User | Optional. A member was removed from the group, information about them (this member may be the bot itself) */
        public let left_chat_member: User?
        /** String | Optional. A chat title was changed to this value */
        public let new_chat_title: String?
        /** Array of PhotoSize | Optional. A chat photo was change to this value */
        public let new_chat_photo: Array<PhotoSize>?
        /** Boolean | Optional. Service message: the chat photo was deleted */
        public let delete_chat_photo: Bool?
        /** Boolean | Optional. Service message: the group has been created */
        public let group_chat_created: Bool?
        /** Boolean | Optional. Service message: the supergroup has been created. This field can't be received in a message coming through updates, because bot can't be a member of a supergroup when it is created. It can only be found in reply_to_message if someone replies to a very first message in a directly created supergroup. */
        public let supergroup_chat_created: Bool?
        /** Boolean | Optional. Service message: the channel has been created. This field can't be received in a message coming through updates, because bot can't be a member of a channel when it is created. It can only be found in reply_to_message if someone replies to a very first message in a channel. */
        public let channel_chat_created: Bool?
        /** MessageAutoDeleteTimerChanged | Optional. Service message: auto-delete timer settings changed in the chat */
        public let message_auto_delete_timer_changed: MessageAutoDeleteTimerChanged?
        /** Integer | Optional. The group has been migrated to a supergroup with the specified identifier. This number may have more than 32 significant bits and some programming languages may have difficulty/silent defects in interpreting it. But it has at most 52 significant bits, so a signed 64-bit integer or double-precision float type are safe for storing this identifier. */
        public let migrate_to_chat_id: Int?
        /** Integer | Optional. The supergroup has been migrated from a group with the specified identifier. This number may have more than 32 significant bits and some programming languages may have difficulty/silent defects in interpreting it. But it has at most 52 significant bits, so a signed 64-bit integer or double-precision float type are safe for storing this identifier. */
        public let migrate_from_chat_id: Int?
        /** MaybeInaccessibleMessage | Optional. Specified message was pinned. Note that the Message object in this field will not contain further reply_to_message fields even if it itself is a reply. */
        public let pinned_message: MaybeInaccessibleMessage?
        /** Invoice | Optional. Message is an invoice for a payment, information about the invoice. More about payments: https://core.telegram.org/bots/api#payments */
        public let invoice: Invoice?
        /** SuccessfulPayment | Optional. Message is a service message about a successful payment, information about the payment. More about payments: https://core.telegram.org/bots/api#payments */
        public let successful_payment: SuccessfulPayment?
        /** RefundedPayment | Optional. Message is a service message about a refunded payment, information about the payment. More about payments: https://core.telegram.org/bots/api#payments */
        public let refunded_payment: RefundedPayment?
        /** UsersShared | Optional. Service message: users were shared with the bot */
        public let users_shared: UsersShared?
        /** ChatShared | Optional. Service message: a chat was shared with the bot */
        public let chat_shared: ChatShared?
        /** String | Optional. The domain name of the website on which the user has logged in. More about Telegram Login: https://core.telegram.org/widgets/login */
        public let connected_website: String?
        /** WriteAccessAllowed | Optional. Service message: the user allowed the bot to write messages after adding it to the attachment or side menu, launching a Web App from a link, or accepting an explicit request from a Web App sent by the method requestWriteAccess */
        public let write_access_allowed: WriteAccessAllowed?
        /** PassportData | Optional. Telegram Passport data */
        public let passport_data: PassportData?
        /** ProximityAlertTriggered | Optional. Service message. A user in the chat triggered another user's proximity alert while sharing Live Location. */
        public let proximity_alert_triggered: ProximityAlertTriggered?
        /** ChatBoostAdded | Optional. Service message: user boosted the chat */
        public let boost_added: ChatBoostAdded?
        /** ChatBackground | Optional. Service message: chat background set */
        public let chat_background_set: ChatBackground?
        /** ForumTopicCreated | Optional. Service message: forum topic created */
        public let forum_topic_created: ForumTopicCreated?
        /** ForumTopicEdited | Optional. Service message: forum topic edited */
        public let forum_topic_edited: ForumTopicEdited?
        /** ForumTopicClosed | Optional. Service message: forum topic closed */
        public let forum_topic_closed: ForumTopicClosed?
        /** ForumTopicReopened | Optional. Service message: forum topic reopened */
        public let forum_topic_reopened: ForumTopicReopened?
        /** GeneralForumTopicHidden | Optional. Service message: the 'General' forum topic hidden */
        public let general_forum_topic_hidden: GeneralForumTopicHidden?
        /** GeneralForumTopicUnhidden | Optional. Service message: the 'General' forum topic unhidden */
        public let general_forum_topic_unhidden: GeneralForumTopicUnhidden?
        /** GiveawayCreated | Optional. Service message: a scheduled giveaway was created */
        public let giveaway_created: GiveawayCreated?
        /** Giveaway | Optional. The message is a scheduled giveaway message */
        public let giveaway: Giveaway?
        /** GiveawayWinners | Optional. A giveaway with public winners was completed */
        public let giveaway_winners: GiveawayWinners?
        /** GiveawayCompleted | Optional. Service message: a giveaway without public winners was completed */
        public let giveaway_completed: GiveawayCompleted?
        /** VideoChatScheduled | Optional. Service message: video chat scheduled */
        public let video_chat_scheduled: VideoChatScheduled?
        /** VideoChatStarted | Optional. Service message: video chat started */
        public let video_chat_started: VideoChatStarted?
        /** VideoChatEnded | Optional. Service message: video chat ended */
        public let video_chat_ended: VideoChatEnded?
        /** VideoChatParticipantsInvited | Optional. Service message: new participants invited to a video chat */
        public let video_chat_participants_invited: VideoChatParticipantsInvited?
        /** WebAppData | Optional. Service message: data sent by a Web App */
        public let web_app_data: WebAppData?
        /** InlineKeyboardMarkup | Optional. Inline keyboard attached to the message. login_url buttons are represented as ordinary url buttons. */
        public let reply_markup: InlineKeyboardMarkup?
        public init(message_id: Int ,message_thread_id: Int? = nil ,from: User? = nil ,sender_chat: Chat? = nil ,sender_boost_count: Int? = nil ,sender_business_bot: User? = nil ,date: Int ,business_connection_id: String? = nil ,chat: Chat ,forward_origin: MessageOrigin? = nil ,is_topic_message: Bool? = nil ,is_automatic_forward: Bool? = nil ,reply_to_message: ValueWrapper<Message>? = nil ,external_reply: ExternalReplyInfo? = nil ,quote: TextQuote? = nil ,reply_to_story: Story? = nil ,via_bot: User? = nil ,edit_date: Int? = nil ,has_protected_content: Bool? = nil ,is_from_offline: Bool? = nil ,media_group_id: String? = nil ,author_signature: String? = nil ,text: String? = nil ,entities: Array<MessageEntity>? = nil ,link_preview_options: LinkPreviewOptions? = nil ,effect_id: String? = nil ,animation: Animation? = nil ,audio: Audio? = nil ,document: Document? = nil ,paid_media: PaidMediaInfo? = nil ,photo: Array<PhotoSize>? = nil ,sticker: Sticker? = nil ,story: Story? = nil ,video: Video? = nil ,video_note: VideoNote? = nil ,voice: Voice? = nil ,caption: String? = nil ,caption_entities: Array<MessageEntity>? = nil ,show_caption_above_media: Bool? = nil ,has_media_spoiler: Bool? = nil ,contact: Contact? = nil ,dice: Dice? = nil ,game: Game? = nil ,poll: Poll? = nil ,venue: Venue? = nil ,location: Location? = nil ,new_chat_members: Array<User>? = nil ,left_chat_member: User? = nil ,new_chat_title: String? = nil ,new_chat_photo: Array<PhotoSize>? = nil ,delete_chat_photo: Bool? = nil ,group_chat_created: Bool? = nil ,supergroup_chat_created: Bool? = nil ,channel_chat_created: Bool? = nil ,message_auto_delete_timer_changed: MessageAutoDeleteTimerChanged? = nil ,migrate_to_chat_id: Int? = nil ,migrate_from_chat_id: Int? = nil ,pinned_message: MaybeInaccessibleMessage? = nil ,invoice: Invoice? = nil ,successful_payment: SuccessfulPayment? = nil ,refunded_payment: RefundedPayment? = nil ,users_shared: UsersShared? = nil ,chat_shared: ChatShared? = nil ,connected_website: String? = nil ,write_access_allowed: WriteAccessAllowed? = nil ,passport_data: PassportData? = nil ,proximity_alert_triggered: ProximityAlertTriggered? = nil ,boost_added: ChatBoostAdded? = nil ,chat_background_set: ChatBackground? = nil ,forum_topic_created: ForumTopicCreated? = nil ,forum_topic_edited: ForumTopicEdited? = nil ,forum_topic_closed: ForumTopicClosed? = nil ,forum_topic_reopened: ForumTopicReopened? = nil ,general_forum_topic_hidden: GeneralForumTopicHidden? = nil ,general_forum_topic_unhidden: GeneralForumTopicUnhidden? = nil ,giveaway_created: GiveawayCreated? = nil ,giveaway: Giveaway? = nil ,giveaway_winners: GiveawayWinners? = nil ,giveaway_completed: GiveawayCompleted? = nil ,video_chat_scheduled: VideoChatScheduled? = nil ,video_chat_started: VideoChatStarted? = nil ,video_chat_ended: VideoChatEnded? = nil ,video_chat_participants_invited: VideoChatParticipantsInvited? = nil ,web_app_data: WebAppData? = nil ,reply_markup: InlineKeyboardMarkup? = nil) {
            self.message_id = message_id
            self.message_thread_id = message_thread_id
            self.from = from
            self.sender_chat = sender_chat
            self.sender_boost_count = sender_boost_count
            self.sender_business_bot = sender_business_bot
            self.date = date
            self.business_connection_id = business_connection_id
            self.chat = chat
            self.forward_origin = forward_origin
            self.is_topic_message = is_topic_message
            self.is_automatic_forward = is_automatic_forward
            self.reply_to_message = reply_to_message
            self.external_reply = external_reply
            self.quote = quote
            self.reply_to_story = reply_to_story
            self.via_bot = via_bot
            self.edit_date = edit_date
            self.has_protected_content = has_protected_content
            self.is_from_offline = is_from_offline
            self.media_group_id = media_group_id
            self.author_signature = author_signature
            self.text = text
            self.entities = entities
            self.link_preview_options = link_preview_options
            self.effect_id = effect_id
            self.animation = animation
            self.audio = audio
            self.document = document
            self.paid_media = paid_media
            self.photo = photo
            self.sticker = sticker
            self.story = story
            self.video = video
            self.video_note = video_note
            self.voice = voice
            self.caption = caption
            self.caption_entities = caption_entities
            self.show_caption_above_media = show_caption_above_media
            self.has_media_spoiler = has_media_spoiler
            self.contact = contact
            self.dice = dice
            self.game = game
            self.poll = poll
            self.venue = venue
            self.location = location
            self.new_chat_members = new_chat_members
            self.left_chat_member = left_chat_member
            self.new_chat_title = new_chat_title
            self.new_chat_photo = new_chat_photo
            self.delete_chat_photo = delete_chat_photo
            self.group_chat_created = group_chat_created
            self.supergroup_chat_created = supergroup_chat_created
            self.channel_chat_created = channel_chat_created
            self.message_auto_delete_timer_changed = message_auto_delete_timer_changed
            self.migrate_to_chat_id = migrate_to_chat_id
            self.migrate_from_chat_id = migrate_from_chat_id
            self.pinned_message = pinned_message
            self.invoice = invoice
            self.successful_payment = successful_payment
            self.refunded_payment = refunded_payment
            self.users_shared = users_shared
            self.chat_shared = chat_shared
            self.connected_website = connected_website
            self.write_access_allowed = write_access_allowed
            self.passport_data = passport_data
            self.proximity_alert_triggered = proximity_alert_triggered
            self.boost_added = boost_added
            self.chat_background_set = chat_background_set
            self.forum_topic_created = forum_topic_created
            self.forum_topic_edited = forum_topic_edited
            self.forum_topic_closed = forum_topic_closed
            self.forum_topic_reopened = forum_topic_reopened
            self.general_forum_topic_hidden = general_forum_topic_hidden
            self.general_forum_topic_unhidden = general_forum_topic_unhidden
            self.giveaway_created = giveaway_created
            self.giveaway = giveaway
            self.giveaway_winners = giveaway_winners
            self.giveaway_completed = giveaway_completed
            self.video_chat_scheduled = video_chat_scheduled
            self.video_chat_started = video_chat_started
            self.video_chat_ended = video_chat_ended
            self.video_chat_participants_invited = video_chat_participants_invited
            self.web_app_data = web_app_data
            self.reply_markup = reply_markup
        }
    }
}

extension TelegramAPI {
    /**
     * https://core.telegram.org/bots/api#messageid  
     * This object represents a unique message identifier.
    */
    public struct MessageId: Codable {
        /** Integer | Unique message identifier. In specific instances (e.g., message containing a video sent to a big chat), the server might automatically schedule a message instead of sending it immediately. In such cases, this field will be 0 and the relevant message will be unusable until it is actually sent */
        public let message_id: Int
        public init(message_id: Int) {
            self.message_id = message_id
        }
    }
}

extension TelegramAPI {
    /**
     * https://core.telegram.org/bots/api#inaccessiblemessage  
     * This object describes a message that was deleted or is otherwise inaccessible to the bot.
    */
    public struct InaccessibleMessage: Codable {
        /** Chat | Chat the message belonged to */
        public let chat: Chat
        /** Integer | Unique message identifier inside the chat */
        public let message_id: Int
        /** Integer | Always 0. The field can be used to differentiate regular and inaccessible messages. */
        public let date: Int
        public init(chat: Chat ,message_id: Int ,date: Int) {
            self.chat = chat
            self.message_id = message_id
            self.date = date
        }
    }
}

extension TelegramAPI {
    /**
     * https://core.telegram.org/bots/api#maybeinaccessiblemessage  
     * This object describes a message that can be inaccessible to the bot. It can be one of
     * - Message
     * - InaccessibleMessage
    */
    public indirect enum MaybeInaccessibleMessage: Codable {
        case message(Message)
        case inaccessibleMessage(InaccessibleMessage)

        public init(from decoder: Decoder) throws {
            let container = try decoder.singleValueContainer()
            if let value = try? container.decode(Message.self) {
                self = .message(value)
            }
            else if let value = try? container.decode(InaccessibleMessage.self) {
                self = .inaccessibleMessage(value)
            }else {
                throw DecodingError.typeMismatch(MaybeInaccessibleMessage.self, DecodingError.Context(codingPath: decoder.codingPath, debugDescription: "Wrong type for MaybeInaccessibleMessage"))
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.singleValueContainer()
            switch self {
                case .message(let value):
                    try container.encode(value)
                case .inaccessibleMessage(let value):
                    try container.encode(value)
            }
        }
    }
}

extension TelegramAPI {
    /**
     * https://core.telegram.org/bots/api#messageentity  
     * This object represents one special entity in a text message. For example, hashtags, usernames, URLs, etc.
    */
    public struct MessageEntity: Codable {
        /** MessageEntityType | Type of the entity. Currently, can be "mention" (@username), "hashtag" (#hashtag or #hashtag@chatusername), "cashtag" ($USD or $USD@chatusername), "bot_command" (/start@jobs_bot), "url" (https://telegram.org), "email" (do-not-reply@telegram.org), "phone_number" (+1-212-555-0123), "bold" (bold text), "italic" (italic text), "underline" (underlined text), "strikethrough" (strikethrough text), "spoiler" (spoiler message), "blockquote" (block quotation), "expandable_blockquote" (collapsed-by-default block quotation), "code" (monowidth string), "pre" (monowidth block), "text_link" (for clickable text URLs), "text_mention" (for users without usernames), "custom_emoji" (for inline custom emoji stickers) */
        public let type: MessageEntityType
        /** Integer | Offset in UTF-16 code units to the start of the entity */
        public let offset: Int
        /** Integer | Length of the entity in UTF-16 code units */
        public let length: Int
        /** String | Optional. For "text_link" only, URL that will be opened after user taps on the text */
        public let url: String?
        /** User | Optional. For "text_mention" only, the mentioned user */
        public let user: User?
        /** String | Optional. For "pre" only, the programming language of the entity text */
        public let language: String?
        /** String | Optional. For "custom_emoji" only, unique identifier of the custom emoji. Use getCustomEmojiStickers to get full information about the sticker */
        public let custom_emoji_id: String?
        public init(type: MessageEntityType ,offset: Int ,length: Int ,url: String? = nil ,user: User? = nil ,language: String? = nil ,custom_emoji_id: String? = nil) {
            self.type = type
            self.offset = offset
            self.length = length
            self.url = url
            self.user = user
            self.language = language
            self.custom_emoji_id = custom_emoji_id
        }
    }
}

extension TelegramAPI {
    /**
     * https://core.telegram.org/bots/api#textquote  
     * This object contains information about the quoted part of a message that is replied to by the given message.
    */
    public struct TextQuote: Codable {
        /** String | Text of the quoted part of a message that is replied to by the given message */
        public let text: String
        /** Array of MessageEntity | Optional. Special entities that appear in the quote. Currently, only bold, italic, underline, strikethrough, spoiler, and custom_emoji entities are kept in quotes. */
        public let entities: Array<MessageEntity>?
        /** Integer | Approximate quote position in the original message in UTF-16 code units as specified by the sender */
        public let position: Int
        /** Boolean | Optional. True, if the quote was chosen manually by the message sender. Otherwise, the quote was added automatically by the server. */
        public let is_manual: Bool?
        public init(text: String ,entities: Array<MessageEntity>? = nil ,position: Int ,is_manual: Bool? = nil) {
            self.text = text
            self.entities = entities
            self.position = position
            self.is_manual = is_manual
        }
    }
}

extension TelegramAPI {
    /**
     * https://core.telegram.org/bots/api#externalreplyinfo  
     * This object contains information about a message that is being replied to, which may come from another chat or forum topic.
    */
    public struct ExternalReplyInfo: Codable {
        /** MessageOrigin | Origin of the message replied to by the given message */
        public let origin: MessageOrigin
        /** Chat | Optional. Chat the original message belongs to. Available only if the chat is a supergroup or a channel. */
        public let chat: Chat?
        /** Integer | Optional. Unique message identifier inside the original chat. Available only if the original chat is a supergroup or a channel. */
        public let message_id: Int?
        /** LinkPreviewOptions | Optional. Options used for link preview generation for the original message, if it is a text message */
        public let link_preview_options: LinkPreviewOptions?
        /** Animation | Optional. Message is an animation, information about the animation */
        public let animation: Animation?
        /** Audio | Optional. Message is an audio file, information about the file */
        public let audio: Audio?
        /** Document | Optional. Message is a general file, information about the file */
        public let document: Document?
        /** PaidMediaInfo | Optional. Message contains paid media; information about the paid media */
        public let paid_media: PaidMediaInfo?
        /** Array of PhotoSize | Optional. Message is a photo, available sizes of the photo */
        public let photo: Array<PhotoSize>?
        /** Sticker | Optional. Message is a sticker, information about the sticker */
        public let sticker: Sticker?
        /** Story | Optional. Message is a forwarded story */
        public let story: Story?
        /** Video | Optional. Message is a video, information about the video */
        public let video: Video?
        /** VideoNote | Optional. Message is a video note, information about the video message */
        public let video_note: VideoNote?
        /** Voice | Optional. Message is a voice message, information about the file */
        public let voice: Voice?
        /** Boolean | Optional. True, if the message media is covered by a spoiler animation */
        public let has_media_spoiler: Bool?
        /** Contact | Optional. Message is a shared contact, information about the contact */
        public let contact: Contact?
        /** Dice | Optional. Message is a dice with random value */
        public let dice: Dice?
        /** Game | Optional. Message is a game, information about the game. More about games: https://core.telegram.org/bots/api#games */
        public let game: Game?
        /** Giveaway | Optional. Message is a scheduled giveaway, information about the giveaway */
        public let giveaway: Giveaway?
        /** GiveawayWinners | Optional. A giveaway with public winners was completed */
        public let giveaway_winners: GiveawayWinners?
        /** Invoice | Optional. Message is an invoice for a payment, information about the invoice. More about payments: https://core.telegram.org/bots/api#payments */
        public let invoice: Invoice?
        /** Location | Optional. Message is a shared location, information about the location */
        public let location: Location?
        /** Poll | Optional. Message is a native poll, information about the poll */
        public let poll: Poll?
        /** Venue | Optional. Message is a venue, information about the venue */
        public let venue: Venue?
        public init(origin: MessageOrigin ,chat: Chat? = nil ,message_id: Int? = nil ,link_preview_options: LinkPreviewOptions? = nil ,animation: Animation? = nil ,audio: Audio? = nil ,document: Document? = nil ,paid_media: PaidMediaInfo? = nil ,photo: Array<PhotoSize>? = nil ,sticker: Sticker? = nil ,story: Story? = nil ,video: Video? = nil ,video_note: VideoNote? = nil ,voice: Voice? = nil ,has_media_spoiler: Bool? = nil ,contact: Contact? = nil ,dice: Dice? = nil ,game: Game? = nil ,giveaway: Giveaway? = nil ,giveaway_winners: GiveawayWinners? = nil ,invoice: Invoice? = nil ,location: Location? = nil ,poll: Poll? = nil ,venue: Venue? = nil) {
            self.origin = origin
            self.chat = chat
            self.message_id = message_id
            self.link_preview_options = link_preview_options
            self.animation = animation
            self.audio = audio
            self.document = document
            self.paid_media = paid_media
            self.photo = photo
            self.sticker = sticker
            self.story = story
            self.video = video
            self.video_note = video_note
            self.voice = voice
            self.has_media_spoiler = has_media_spoiler
            self.contact = contact
            self.dice = dice
            self.game = game
            self.giveaway = giveaway
            self.giveaway_winners = giveaway_winners
            self.invoice = invoice
            self.location = location
            self.poll = poll
            self.venue = venue
        }
    }
}

extension TelegramAPI {
    /**
     * https://core.telegram.org/bots/api#replyparameters  
     * Describes reply parameters for the message that is being sent.
    */
    public struct ReplyParameters: Codable {
        /** Integer | Identifier of the message that will be replied to in the current chat, or in the chat chat_id if it is specified */
        public let message_id: Int
        /** Integer or String | Optional. If the message to be replied to is from a different chat, unique identifier for the chat or username of the channel (in the format @channelusername). Not supported for messages sent on behalf of a business account. */
        public let chat_id: Either2<Int, String>?
        /** Boolean | Optional. Pass True if the message should be sent even if the specified message to be replied to is not found. Always False for replies in another chat or forum topic. Always True for messages sent on behalf of a business account. */
        public let allow_sending_without_reply: Bool?
        /** String | Optional. Quoted part of the message to be replied to; 0-1024 characters after entities parsing. The quote must be an exact substring of the message to be replied to, including bold, italic, underline, strikethrough, spoiler, and custom_emoji entities. The message will fail to send if the quote isn't found in the original message. */
        public let quote: String?
        /** String | Optional. Mode for parsing entities in the quote. See formatting options for more details. */
        public let quote_parse_mode: String?
        /** Array of MessageEntity | Optional. A JSON-serialized list of special entities that appear in the quote. It can be specified instead of quote_parse_mode. */
        public let quote_entities: Array<MessageEntity>?
        /** Integer | Optional. Position of the quote in the original message in UTF-16 code units */
        public let quote_position: Int?
        public init(message_id: Int ,chat_id: Either2<Int, String>? = nil ,allow_sending_without_reply: Bool? = nil ,quote: String? = nil ,quote_parse_mode: String? = nil ,quote_entities: Array<MessageEntity>? = nil ,quote_position: Int? = nil) {
            self.message_id = message_id
            self.chat_id = chat_id
            self.allow_sending_without_reply = allow_sending_without_reply
            self.quote = quote
            self.quote_parse_mode = quote_parse_mode
            self.quote_entities = quote_entities
            self.quote_position = quote_position
        }
    }
}

extension TelegramAPI {
    /**
     * https://core.telegram.org/bots/api#messageorigin  
     * This object describes the origin of a message. It can be one of
     * - MessageOriginUser
     * - MessageOriginHiddenUser
     * - MessageOriginChat
     * - MessageOriginChannel
    */
    public indirect enum MessageOrigin: Codable {
        case messageOriginUser(MessageOriginUser)
        case messageOriginHiddenUser(MessageOriginHiddenUser)
        case messageOriginChat(MessageOriginChat)
        case messageOriginChannel(MessageOriginChannel)

        public init(from decoder: Decoder) throws {
            let container = try decoder.singleValueContainer()
            if let value = try? container.decode(MessageOriginUser.self) {
                self = .messageOriginUser(value)
            }
            else if let value = try? container.decode(MessageOriginHiddenUser.self) {
                self = .messageOriginHiddenUser(value)
            }
            else if let value = try? container.decode(MessageOriginChat.self) {
                self = .messageOriginChat(value)
            }
            else if let value = try? container.decode(MessageOriginChannel.self) {
                self = .messageOriginChannel(value)
            }else {
                throw DecodingError.typeMismatch(MessageOrigin.self, DecodingError.Context(codingPath: decoder.codingPath, debugDescription: "Wrong type for MessageOrigin"))
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.singleValueContainer()
            switch self {
                case .messageOriginUser(let value):
                    try container.encode(value)
                case .messageOriginHiddenUser(let value):
                    try container.encode(value)
                case .messageOriginChat(let value):
                    try container.encode(value)
                case .messageOriginChannel(let value):
                    try container.encode(value)
            }
        }
    }
}

extension TelegramAPI {
    /**
     * https://core.telegram.org/bots/api#messageoriginuser  
     * The message was originally sent by a known user.
    */
    public struct MessageOriginUser: Codable {
        /** String | Type of the message origin, always "user" */
        public let type: String
        /** Integer | Date the message was sent originally in Unix time */
        public let date: Int
        /** User | User that sent the message originally */
        public let sender_user: User
        public init(type: String ,date: Int ,sender_user: User) {
            self.type = type
            self.date = date
            self.sender_user = sender_user
        }
    }
}

extension TelegramAPI {
    /**
     * https://core.telegram.org/bots/api#messageoriginhiddenuser  
     * The message was originally sent by an unknown user.
    */
    public struct MessageOriginHiddenUser: Codable {
        /** String | Type of the message origin, always "hidden_user" */
        public let type: String
        /** Integer | Date the message was sent originally in Unix time */
        public let date: Int
        /** String | Name of the user that sent the message originally */
        public let sender_user_name: String
        public init(type: String ,date: Int ,sender_user_name: String) {
            self.type = type
            self.date = date
            self.sender_user_name = sender_user_name
        }
    }
}

extension TelegramAPI {
    /**
     * https://core.telegram.org/bots/api#messageoriginchat  
     * The message was originally sent on behalf of a chat to a group chat.
    */
    public struct MessageOriginChat: Codable {
        /** String | Type of the message origin, always "chat" */
        public let type: String
        /** Integer | Date the message was sent originally in Unix time */
        public let date: Int
        /** Chat | Chat that sent the message originally */
        public let sender_chat: Chat
        /** String | Optional. For messages originally sent by an anonymous chat administrator, original message author signature */
        public let author_signature: String?
        public init(type: String ,date: Int ,sender_chat: Chat ,author_signature: String? = nil) {
            self.type = type
            self.date = date
            self.sender_chat = sender_chat
            self.author_signature = author_signature
        }
    }
}

extension TelegramAPI {
    /**
     * https://core.telegram.org/bots/api#messageoriginchannel  
     * The message was originally sent to a channel chat.
    */
    public struct MessageOriginChannel: Codable {
        /** String | Type of the message origin, always "channel" */
        public let type: String
        /** Integer | Date the message was sent originally in Unix time */
        public let date: Int
        /** Chat | Channel chat to which the message was originally sent */
        public let chat: Chat
        /** Integer | Unique message identifier inside the chat */
        public let message_id: Int
        /** String | Optional. Signature of the original post author */
        public let author_signature: String?
        public init(type: String ,date: Int ,chat: Chat ,message_id: Int ,author_signature: String? = nil) {
            self.type = type
            self.date = date
            self.chat = chat
            self.message_id = message_id
            self.author_signature = author_signature
        }
    }
}

extension TelegramAPI {
    /**
     * https://core.telegram.org/bots/api#photosize  
     * This object represents one size of a photo or a file / sticker thumbnail.
    */
    public struct PhotoSize: Codable {
        /** String | Identifier for this file, which can be used to download or reuse the file */
        public let file_id: String
        /** String | Unique identifier for this file, which is supposed to be the same over time and for different bots. Can't be used to download or reuse the file. */
        public let file_unique_id: String
        /** Integer | Photo width */
        public let width: Int
        /** Integer | Photo height */
        public let height: Int
        /** Integer | Optional. File size in bytes */
        public let file_size: Int?
        public init(file_id: String ,file_unique_id: String ,width: Int ,height: Int ,file_size: Int? = nil) {
            self.file_id = file_id
            self.file_unique_id = file_unique_id
            self.width = width
            self.height = height
            self.file_size = file_size
        }
    }
}

extension TelegramAPI {
    /**
     * https://core.telegram.org/bots/api#animation  
     * This object represents an animation file (GIF or H.264/MPEG-4 AVC video without sound).
    */
    public struct Animation: Codable {
        /** String | Identifier for this file, which can be used to download or reuse the file */
        public let file_id: String
        /** String | Unique identifier for this file, which is supposed to be the same over time and for different bots. Can't be used to download or reuse the file. */
        public let file_unique_id: String
        /** Integer | Video width as defined by the sender */
        public let width: Int
        /** Integer | Video height as defined by the sender */
        public let height: Int
        /** Integer | Duration of the video in seconds as defined by the sender */
        public let duration: Int
        /** PhotoSize | Optional. Animation thumbnail as defined by the sender */
        public let thumbnail: PhotoSize?
        /** String | Optional. Original animation filename as defined by the sender */
        public let file_name: String?
        /** String | Optional. MIME type of the file as defined by the sender */
        public let mime_type: String?
        /** Integer | Optional. File size in bytes. It can be bigger than 2^31 and some programming languages may have difficulty/silent defects in interpreting it. But it has at most 52 significant bits, so a signed 64-bit integer or double-precision float type are safe for storing this value. */
        public let file_size: Int?
        public init(file_id: String ,file_unique_id: String ,width: Int ,height: Int ,duration: Int ,thumbnail: PhotoSize? = nil ,file_name: String? = nil ,mime_type: String? = nil ,file_size: Int? = nil) {
            self.file_id = file_id
            self.file_unique_id = file_unique_id
            self.width = width
            self.height = height
            self.duration = duration
            self.thumbnail = thumbnail
            self.file_name = file_name
            self.mime_type = mime_type
            self.file_size = file_size
        }
    }
}

extension TelegramAPI {
    /**
     * https://core.telegram.org/bots/api#audio  
     * This object represents an audio file to be treated as music by the Telegram clients.
    */
    public struct Audio: Codable {
        /** String | Identifier for this file, which can be used to download or reuse the file */
        public let file_id: String
        /** String | Unique identifier for this file, which is supposed to be the same over time and for different bots. Can't be used to download or reuse the file. */
        public let file_unique_id: String
        /** Integer | Duration of the audio in seconds as defined by the sender */
        public let duration: Int
        /** String | Optional. Performer of the audio as defined by the sender or by audio tags */
        public let performer: String?
        /** String | Optional. Title of the audio as defined by the sender or by audio tags */
        public let title: String?
        /** String | Optional. Original filename as defined by the sender */
        public let file_name: String?
        /** String | Optional. MIME type of the file as defined by the sender */
        public let mime_type: String?
        /** Integer | Optional. File size in bytes. It can be bigger than 2^31 and some programming languages may have difficulty/silent defects in interpreting it. But it has at most 52 significant bits, so a signed 64-bit integer or double-precision float type are safe for storing this value. */
        public let file_size: Int?
        /** PhotoSize | Optional. Thumbnail of the album cover to which the music file belongs */
        public let thumbnail: PhotoSize?
        public init(file_id: String ,file_unique_id: String ,duration: Int ,performer: String? = nil ,title: String? = nil ,file_name: String? = nil ,mime_type: String? = nil ,file_size: Int? = nil ,thumbnail: PhotoSize? = nil) {
            self.file_id = file_id
            self.file_unique_id = file_unique_id
            self.duration = duration
            self.performer = performer
            self.title = title
            self.file_name = file_name
            self.mime_type = mime_type
            self.file_size = file_size
            self.thumbnail = thumbnail
        }
    }
}

extension TelegramAPI {
    /**
     * https://core.telegram.org/bots/api#document  
     * This object represents a general file (as opposed to photos, voice messages and audio files).
    */
    public struct Document: Codable {
        /** String | Identifier for this file, which can be used to download or reuse the file */
        public let file_id: String
        /** String | Unique identifier for this file, which is supposed to be the same over time and for different bots. Can't be used to download or reuse the file. */
        public let file_unique_id: String
        /** PhotoSize | Optional. Document thumbnail as defined by the sender */
        public let thumbnail: PhotoSize?
        /** String | Optional. Original filename as defined by the sender */
        public let file_name: String?
        /** String | Optional. MIME type of the file as defined by the sender */
        public let mime_type: String?
        /** Integer | Optional. File size in bytes. It can be bigger than 2^31 and some programming languages may have difficulty/silent defects in interpreting it. But it has at most 52 significant bits, so a signed 64-bit integer or double-precision float type are safe for storing this value. */
        public let file_size: Int?
        public init(file_id: String ,file_unique_id: String ,thumbnail: PhotoSize? = nil ,file_name: String? = nil ,mime_type: String? = nil ,file_size: Int? = nil) {
            self.file_id = file_id
            self.file_unique_id = file_unique_id
            self.thumbnail = thumbnail
            self.file_name = file_name
            self.mime_type = mime_type
            self.file_size = file_size
        }
    }
}

extension TelegramAPI {
    /**
     * https://core.telegram.org/bots/api#story  
     * This object represents a story.
    */
    public struct Story: Codable {
        /** Chat | Chat that posted the story */
        public let chat: Chat
        /** Integer | Unique identifier for the story in the chat */
        public let id: Int
        public init(chat: Chat ,id: Int) {
            self.chat = chat
            self.id = id
        }
    }
}

extension TelegramAPI {
    /**
     * https://core.telegram.org/bots/api#video  
     * This object represents a video file.
    */
    public struct Video: Codable {
        /** String | Identifier for this file, which can be used to download or reuse the file */
        public let file_id: String
        /** String | Unique identifier for this file, which is supposed to be the same over time and for different bots. Can't be used to download or reuse the file. */
        public let file_unique_id: String
        /** Integer | Video width as defined by the sender */
        public let width: Int
        /** Integer | Video height as defined by the sender */
        public let height: Int
        /** Integer | Duration of the video in seconds as defined by the sender */
        public let duration: Int
        /** PhotoSize | Optional. Video thumbnail */
        public let thumbnail: PhotoSize?
        /** String | Optional. Original filename as defined by the sender */
        public let file_name: String?
        /** String | Optional. MIME type of the file as defined by the sender */
        public let mime_type: String?
        /** Integer | Optional. File size in bytes. It can be bigger than 2^31 and some programming languages may have difficulty/silent defects in interpreting it. But it has at most 52 significant bits, so a signed 64-bit integer or double-precision float type are safe for storing this value. */
        public let file_size: Int?
        public init(file_id: String ,file_unique_id: String ,width: Int ,height: Int ,duration: Int ,thumbnail: PhotoSize? = nil ,file_name: String? = nil ,mime_type: String? = nil ,file_size: Int? = nil) {
            self.file_id = file_id
            self.file_unique_id = file_unique_id
            self.width = width
            self.height = height
            self.duration = duration
            self.thumbnail = thumbnail
            self.file_name = file_name
            self.mime_type = mime_type
            self.file_size = file_size
        }
    }
}

extension TelegramAPI {
    /**
     * https://core.telegram.org/bots/api#videonote  
     * This object represents a video message (available in Telegram apps as of v.4.0).
    */
    public struct VideoNote: Codable {
        /** String | Identifier for this file, which can be used to download or reuse the file */
        public let file_id: String
        /** String | Unique identifier for this file, which is supposed to be the same over time and for different bots. Can't be used to download or reuse the file. */
        public let file_unique_id: String
        /** Integer | Video width and height (diameter of the video message) as defined by the sender */
        public let length: Int
        /** Integer | Duration of the video in seconds as defined by the sender */
        public let duration: Int
        /** PhotoSize | Optional. Video thumbnail */
        public let thumbnail: PhotoSize?
        /** Integer | Optional. File size in bytes */
        public let file_size: Int?
        public init(file_id: String ,file_unique_id: String ,length: Int ,duration: Int ,thumbnail: PhotoSize? = nil ,file_size: Int? = nil) {
            self.file_id = file_id
            self.file_unique_id = file_unique_id
            self.length = length
            self.duration = duration
            self.thumbnail = thumbnail
            self.file_size = file_size
        }
    }
}

extension TelegramAPI {
    /**
     * https://core.telegram.org/bots/api#voice  
     * This object represents a voice note.
    */
    public struct Voice: Codable {
        /** String | Identifier for this file, which can be used to download or reuse the file */
        public let file_id: String
        /** String | Unique identifier for this file, which is supposed to be the same over time and for different bots. Can't be used to download or reuse the file. */
        public let file_unique_id: String
        /** Integer | Duration of the audio in seconds as defined by the sender */
        public let duration: Int
        /** String | Optional. MIME type of the file as defined by the sender */
        public let mime_type: String?
        /** Integer | Optional. File size in bytes. It can be bigger than 2^31 and some programming languages may have difficulty/silent defects in interpreting it. But it has at most 52 significant bits, so a signed 64-bit integer or double-precision float type are safe for storing this value. */
        public let file_size: Int?
        public init(file_id: String ,file_unique_id: String ,duration: Int ,mime_type: String? = nil ,file_size: Int? = nil) {
            self.file_id = file_id
            self.file_unique_id = file_unique_id
            self.duration = duration
            self.mime_type = mime_type
            self.file_size = file_size
        }
    }
}

extension TelegramAPI {
    /**
     * https://core.telegram.org/bots/api#paidmediainfo  
     * Describes the paid media added to a message.
    */
    public struct PaidMediaInfo: Codable {
        /** Integer | The number of Telegram Stars that must be paid to buy access to the media */
        public let star_count: Int
        /** Array of PaidMedia | Information about the paid media */
        public let paid_media: Array<PaidMedia>
        public init(star_count: Int ,paid_media: Array<PaidMedia>) {
            self.star_count = star_count
            self.paid_media = paid_media
        }
    }
}

extension TelegramAPI {
    /**
     * https://core.telegram.org/bots/api#paidmedia  
     * This object describes paid media. Currently, it can be one of
     * - PaidMediaPreview
     * - PaidMediaPhoto
     * - PaidMediaVideo
    */
    public indirect enum PaidMedia: Codable {
        case paidMediaPreview(PaidMediaPreview)
        case paidMediaPhoto(PaidMediaPhoto)
        case paidMediaVideo(PaidMediaVideo)

        public init(from decoder: Decoder) throws {
            let container = try decoder.singleValueContainer()
            if let value = try? container.decode(PaidMediaPreview.self) {
                self = .paidMediaPreview(value)
            }
            else if let value = try? container.decode(PaidMediaPhoto.self) {
                self = .paidMediaPhoto(value)
            }
            else if let value = try? container.decode(PaidMediaVideo.self) {
                self = .paidMediaVideo(value)
            }else {
                throw DecodingError.typeMismatch(PaidMedia.self, DecodingError.Context(codingPath: decoder.codingPath, debugDescription: "Wrong type for PaidMedia"))
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.singleValueContainer()
            switch self {
                case .paidMediaPreview(let value):
                    try container.encode(value)
                case .paidMediaPhoto(let value):
                    try container.encode(value)
                case .paidMediaVideo(let value):
                    try container.encode(value)
            }
        }
    }
}

extension TelegramAPI {
    /**
     * https://core.telegram.org/bots/api#paidmediapreview  
     * The paid media isn't available before the payment.
    */
    public struct PaidMediaPreview: Codable {
        /** String | Type of the paid media, always "preview" */
        public let type: String
        /** Integer | Optional. Media width as defined by the sender */
        public let width: Int?
        /** Integer | Optional. Media height as defined by the sender */
        public let height: Int?
        /** Integer | Optional. Duration of the media in seconds as defined by the sender */
        public let duration: Int?
        public init(type: String ,width: Int? = nil ,height: Int? = nil ,duration: Int? = nil) {
            self.type = type
            self.width = width
            self.height = height
            self.duration = duration
        }
    }
}

extension TelegramAPI {
    /**
     * https://core.telegram.org/bots/api#paidmediaphoto  
     * The paid media is a photo.
    */
    public struct PaidMediaPhoto: Codable {
        /** String | Type of the paid media, always "photo" */
        public let type: String
        /** Array of PhotoSize | The photo */
        public let photo: Array<PhotoSize>
        public init(type: String ,photo: Array<PhotoSize>) {
            self.type = type
            self.photo = photo
        }
    }
}

extension TelegramAPI {
    /**
     * https://core.telegram.org/bots/api#paidmediavideo  
     * The paid media is a video.
    */
    public struct PaidMediaVideo: Codable {
        /** String | Type of the paid media, always "video" */
        public let type: String
        /** Video | The video */
        public let video: Video
        public init(type: String ,video: Video) {
            self.type = type
            self.video = video
        }
    }
}

extension TelegramAPI {
    /**
     * https://core.telegram.org/bots/api#contact  
     * This object represents a phone contact.
    */
    public struct Contact: Codable {
        /** String | Contact's phone number */
        public let phone_number: String
        /** String | Contact's first name */
        public let first_name: String
        /** String | Optional. Contact's last name */
        public let last_name: String?
        /** Integer | Optional. Contact's user identifier in Telegram. This number may have more than 32 significant bits and some programming languages may have difficulty/silent defects in interpreting it. But it has at most 52 significant bits, so a 64-bit integer or double-precision float type are safe for storing this identifier. */
        public let user_id: Int?
        /** String | Optional. Additional data about the contact in the form of a vCard */
        public let vcard: String?
        public init(phone_number: String ,first_name: String ,last_name: String? = nil ,user_id: Int? = nil ,vcard: String? = nil) {
            self.phone_number = phone_number
            self.first_name = first_name
            self.last_name = last_name
            self.user_id = user_id
            self.vcard = vcard
        }
    }
}

extension TelegramAPI {
    /**
     * https://core.telegram.org/bots/api#dice  
     * This object represents an animated emoji that displays a random value.
    */
    public struct Dice: Codable {
        /** String | Emoji on which the dice throw animation is based */
        public let emoji: String
        /** Integer | Value of the dice, 1-6 for "", "" and "" base emoji, 1-5 for "" and "" base emoji, 1-64 for "" base emoji */
        public let value: Int
        public init(emoji: String ,value: Int) {
            self.emoji = emoji
            self.value = value
        }
    }
}

extension TelegramAPI {
    /**
     * https://core.telegram.org/bots/api#polloption  
     * This object contains information about one answer option in a poll.
    */
    public struct PollOption: Codable {
        /** String | Option text, 1-100 characters */
        public let text: String
        /** Array of MessageEntity | Optional. Special entities that appear in the option text. Currently, only custom emoji entities are allowed in poll option texts */
        public let text_entities: Array<MessageEntity>?
        /** Integer | Number of users that voted for this option */
        public let voter_count: Int
        public init(text: String ,text_entities: Array<MessageEntity>? = nil ,voter_count: Int) {
            self.text = text
            self.text_entities = text_entities
            self.voter_count = voter_count
        }
    }
}

extension TelegramAPI {
    /**
     * https://core.telegram.org/bots/api#inputpolloption  
     * This object contains information about one answer option in a poll to be sent.
    */
    public struct InputPollOption: Codable {
        /** String | Option text, 1-100 characters */
        public let text: String
        /** String | Optional. Mode for parsing entities in the text. See formatting options for more details. Currently, only custom emoji entities are allowed */
        public let text_parse_mode: String?
        /** Array of MessageEntity | Optional. A JSON-serialized list of special entities that appear in the poll option text. It can be specified instead of text_parse_mode */
        public let text_entities: Array<MessageEntity>?
        public init(text: String ,text_parse_mode: String? = nil ,text_entities: Array<MessageEntity>? = nil) {
            self.text = text
            self.text_parse_mode = text_parse_mode
            self.text_entities = text_entities
        }
    }
}

extension TelegramAPI {
    /**
     * https://core.telegram.org/bots/api#pollanswer  
     * This object represents an answer of a user in a non-anonymous poll.
    */
    public struct PollAnswer: Codable {
        /** String | Unique poll identifier */
        public let poll_id: String
        /** Chat | Optional. The chat that changed the answer to the poll, if the voter is anonymous */
        public let voter_chat: Chat?
        /** User | Optional. The user that changed the answer to the poll, if the voter isn't anonymous */
        public let user: User?
        /** Array of Integer | 0-based identifiers of chosen answer options. May be empty if the vote was retracted. */
        public let option_ids: Array<Int>
        public init(poll_id: String ,voter_chat: Chat? = nil ,user: User? = nil ,option_ids: Array<Int>) {
            self.poll_id = poll_id
            self.voter_chat = voter_chat
            self.user = user
            self.option_ids = option_ids
        }
    }
}

extension TelegramAPI {
    /**
     * https://core.telegram.org/bots/api#poll  
     * This object contains information about a poll.
    */
    public struct Poll: Codable {
        /** String | Unique poll identifier */
        public let id: String
        /** String | Poll question, 1-300 characters */
        public let question: String
        /** Array of MessageEntity | Optional. Special entities that appear in the question. Currently, only custom emoji entities are allowed in poll questions */
        public let question_entities: Array<MessageEntity>?
        /** Array of PollOption | List of poll options */
        public let options: Array<PollOption>
        /** Integer | Total number of users that voted in the poll */
        public let total_voter_count: Int
        /** Boolean | True, if the poll is closed */
        public let is_closed: Bool
        /** Boolean | True, if the poll is anonymous */
        public let is_anonymous: Bool
        /** String | Poll type, currently can be "regular" or "quiz" */
        public let type: String
        /** Boolean | True, if the poll allows multiple answers */
        public let allows_multiple_answers: Bool
        /** Integer | Optional. 0-based identifier of the correct answer option. Available only for polls in the quiz mode, which are closed, or was sent (not forwarded) by the bot or to the private chat with the bot. */
        public let correct_option_id: Int?
        /** String | Optional. Text that is shown when a user chooses an incorrect answer or taps on the lamp icon in a quiz-style poll, 0-200 characters */
        public let explanation: String?
        /** Array of MessageEntity | Optional. Special entities like usernames, URLs, bot commands, etc. that appear in the explanation */
        public let explanation_entities: Array<MessageEntity>?
        /** Integer | Optional. Amount of time in seconds the poll will be active after creation */
        public let open_period: Int?
        /** Integer | Optional. Point in time (Unix timestamp) when the poll will be automatically closed */
        public let close_date: Int?
        public init(id: String ,question: String ,question_entities: Array<MessageEntity>? = nil ,options: Array<PollOption> ,total_voter_count: Int ,is_closed: Bool ,is_anonymous: Bool ,type: String ,allows_multiple_answers: Bool ,correct_option_id: Int? = nil ,explanation: String? = nil ,explanation_entities: Array<MessageEntity>? = nil ,open_period: Int? = nil ,close_date: Int? = nil) {
            self.id = id
            self.question = question
            self.question_entities = question_entities
            self.options = options
            self.total_voter_count = total_voter_count
            self.is_closed = is_closed
            self.is_anonymous = is_anonymous
            self.type = type
            self.allows_multiple_answers = allows_multiple_answers
            self.correct_option_id = correct_option_id
            self.explanation = explanation
            self.explanation_entities = explanation_entities
            self.open_period = open_period
            self.close_date = close_date
        }
    }
}

extension TelegramAPI {
    /**
     * https://core.telegram.org/bots/api#location  
     * This object represents a point on the map.
    */
    public struct Location: Codable {
        /** Float | Latitude as defined by the sender */
        public let latitude: Float
        /** Float | Longitude as defined by the sender */
        public let longitude: Float
        /** Float | Optional. The radius of uncertainty for the location, measured in meters; 0-1500 */
        public let horizontal_accuracy: Float?
        /** Integer | Optional. Time relative to the message sending date, during which the location can be updated; in seconds. For active live locations only. */
        public let live_period: Int?
        /** Integer | Optional. The direction in which user is moving, in degrees; 1-360. For active live locations only. */
        public let heading: Int?
        /** Integer | Optional. The maximum distance for proximity alerts about approaching another chat member, in meters. For sent live locations only. */
        public let proximity_alert_radius: Int?
        public init(latitude: Float ,longitude: Float ,horizontal_accuracy: Float? = nil ,live_period: Int? = nil ,heading: Int? = nil ,proximity_alert_radius: Int? = nil) {
            self.latitude = latitude
            self.longitude = longitude
            self.horizontal_accuracy = horizontal_accuracy
            self.live_period = live_period
            self.heading = heading
            self.proximity_alert_radius = proximity_alert_radius
        }
    }
}

extension TelegramAPI {
    /**
     * https://core.telegram.org/bots/api#venue  
     * This object represents a venue.
    */
    public struct Venue: Codable {
        /** Location | Venue location. Can't be a live location */
        public let location: Location
        /** String | Name of the venue */
        public let title: String
        /** String | Address of the venue */
        public let address: String
        /** String | Optional. Foursquare identifier of the venue */
        public let foursquare_id: String?
        /** String | Optional. Foursquare type of the venue. (For example, "arts_entertainment/default", "arts_entertainment/aquarium" or "food/icecream".) */
        public let foursquare_type: String?
        /** String | Optional. Google Places identifier of the venue */
        public let google_place_id: String?
        /** String | Optional. Google Places type of the venue. (See supported types.) */
        public let google_place_type: String?
        public init(location: Location ,title: String ,address: String ,foursquare_id: String? = nil ,foursquare_type: String? = nil ,google_place_id: String? = nil ,google_place_type: String? = nil) {
            self.location = location
            self.title = title
            self.address = address
            self.foursquare_id = foursquare_id
            self.foursquare_type = foursquare_type
            self.google_place_id = google_place_id
            self.google_place_type = google_place_type
        }
    }
}

extension TelegramAPI {
    /**
     * https://core.telegram.org/bots/api#webappdata  
     * Describes data sent from a Web App to the bot.
    */
    public struct WebAppData: Codable {
        /** String | The data. Be aware that a bad client can send arbitrary data in this field. */
        public let data: String
        /** String | Text of the web_app keyboard button from which the Web App was opened. Be aware that a bad client can send arbitrary data in this field. */
        public let button_text: String
        public init(data: String ,button_text: String) {
            self.data = data
            self.button_text = button_text
        }
    }
}

extension TelegramAPI {
    /**
     * https://core.telegram.org/bots/api#proximityalerttriggered  
     * This object represents the content of a service message, sent whenever a user in the chat triggers a proximity alert set by another user.
    */
    public struct ProximityAlertTriggered: Codable {
        /** User | User that triggered the alert */
        public let traveler: User
        /** User | User that set the alert */
        public let watcher: User
        /** Integer | The distance between the users */
        public let distance: Int
        public init(traveler: User ,watcher: User ,distance: Int) {
            self.traveler = traveler
            self.watcher = watcher
            self.distance = distance
        }
    }
}

extension TelegramAPI {
    /**
     * https://core.telegram.org/bots/api#messageautodeletetimerchanged  
     * This object represents a service message about a change in auto-delete timer settings.
    */
    public struct MessageAutoDeleteTimerChanged: Codable {
        /** Integer | New auto-delete time for messages in the chat; in seconds */
        public let message_auto_delete_time: Int
        public init(message_auto_delete_time: Int) {
            self.message_auto_delete_time = message_auto_delete_time
        }
    }
}

extension TelegramAPI {
    /**
     * https://core.telegram.org/bots/api#chatboostadded  
     * This object represents a service message about a user boosting a chat.
    */
    public struct ChatBoostAdded: Codable {
        /** Integer | Number of boosts added by the user */
        public let boost_count: Int
        public init(boost_count: Int) {
            self.boost_count = boost_count
        }
    }
}

extension TelegramAPI {
    /**
     * https://core.telegram.org/bots/api#backgroundfill  
     * This object describes the way a background is filled based on the selected colors. Currently, it can be one of
     * - BackgroundFillSolid
     * - BackgroundFillGradient
     * - BackgroundFillFreeformGradient
    */
    public indirect enum BackgroundFill: Codable {
        case backgroundFillSolid(BackgroundFillSolid)
        case backgroundFillGradient(BackgroundFillGradient)
        case backgroundFillFreeformGradient(BackgroundFillFreeformGradient)

        public init(from decoder: Decoder) throws {
            let container = try decoder.singleValueContainer()
            if let value = try? container.decode(BackgroundFillSolid.self) {
                self = .backgroundFillSolid(value)
            }
            else if let value = try? container.decode(BackgroundFillGradient.self) {
                self = .backgroundFillGradient(value)
            }
            else if let value = try? container.decode(BackgroundFillFreeformGradient.self) {
                self = .backgroundFillFreeformGradient(value)
            }else {
                throw DecodingError.typeMismatch(BackgroundFill.self, DecodingError.Context(codingPath: decoder.codingPath, debugDescription: "Wrong type for BackgroundFill"))
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.singleValueContainer()
            switch self {
                case .backgroundFillSolid(let value):
                    try container.encode(value)
                case .backgroundFillGradient(let value):
                    try container.encode(value)
                case .backgroundFillFreeformGradient(let value):
                    try container.encode(value)
            }
        }
    }
}

extension TelegramAPI {
    /**
     * https://core.telegram.org/bots/api#backgroundfillsolid  
     * The background is filled using the selected color.
    */
    public struct BackgroundFillSolid: Codable {
        /** String | Type of the background fill, always "solid" */
        public let type: String
        /** Integer | The color of the background fill in the RGB24 format */
        public let color: Int
        public init(type: String ,color: Int) {
            self.type = type
            self.color = color
        }
    }
}

extension TelegramAPI {
    /**
     * https://core.telegram.org/bots/api#backgroundfillgradient  
     * The background is a gradient fill.
    */
    public struct BackgroundFillGradient: Codable {
        /** String | Type of the background fill, always "gradient" */
        public let type: String
        /** Integer | Top color of the gradient in the RGB24 format */
        public let top_color: Int
        /** Integer | Bottom color of the gradient in the RGB24 format */
        public let bottom_color: Int
        /** Integer | Clockwise rotation angle of the background fill in degrees; 0-359 */
        public let rotation_angle: Int
        public init(type: String ,top_color: Int ,bottom_color: Int ,rotation_angle: Int) {
            self.type = type
            self.top_color = top_color
            self.bottom_color = bottom_color
            self.rotation_angle = rotation_angle
        }
    }
}

extension TelegramAPI {
    /**
     * https://core.telegram.org/bots/api#backgroundfillfreeformgradient  
     * The background is a freeform gradient that rotates after every message in the chat.
    */
    public struct BackgroundFillFreeformGradient: Codable {
        /** String | Type of the background fill, always "freeform_gradient" */
        public let type: String
        /** Array of Integer | A list of the 3 or 4 base colors that are used to generate the freeform gradient in the RGB24 format */
        public let colors: Array<Int>
        public init(type: String ,colors: Array<Int>) {
            self.type = type
            self.colors = colors
        }
    }
}

extension TelegramAPI {
    /**
     * https://core.telegram.org/bots/api#backgroundtype  
     * This object describes the type of a background. Currently, it can be one of
     * - BackgroundTypeFill
     * - BackgroundTypeWallpaper
     * - BackgroundTypePattern
     * - BackgroundTypeChatTheme
    */
    public indirect enum BackgroundType: Codable {
        case backgroundTypeFill(BackgroundTypeFill)
        case backgroundTypeWallpaper(BackgroundTypeWallpaper)
        case backgroundTypePattern(BackgroundTypePattern)
        case backgroundTypeChatTheme(BackgroundTypeChatTheme)

        public init(from decoder: Decoder) throws {
            let container = try decoder.singleValueContainer()
            if let value = try? container.decode(BackgroundTypeFill.self) {
                self = .backgroundTypeFill(value)
            }
            else if let value = try? container.decode(BackgroundTypeWallpaper.self) {
                self = .backgroundTypeWallpaper(value)
            }
            else if let value = try? container.decode(BackgroundTypePattern.self) {
                self = .backgroundTypePattern(value)
            }
            else if let value = try? container.decode(BackgroundTypeChatTheme.self) {
                self = .backgroundTypeChatTheme(value)
            }else {
                throw DecodingError.typeMismatch(BackgroundType.self, DecodingError.Context(codingPath: decoder.codingPath, debugDescription: "Wrong type for BackgroundType"))
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.singleValueContainer()
            switch self {
                case .backgroundTypeFill(let value):
                    try container.encode(value)
                case .backgroundTypeWallpaper(let value):
                    try container.encode(value)
                case .backgroundTypePattern(let value):
                    try container.encode(value)
                case .backgroundTypeChatTheme(let value):
                    try container.encode(value)
            }
        }
    }
}

extension TelegramAPI {
    /**
     * https://core.telegram.org/bots/api#backgroundtypefill  
     * The background is automatically filled based on the selected colors.
    */
    public struct BackgroundTypeFill: Codable {
        /** String | Type of the background, always "fill" */
        public let type: String
        /** BackgroundFill | The background fill */
        public let fill: BackgroundFill
        /** Integer | Dimming of the background in dark themes, as a percentage; 0-100 */
        public let dark_theme_dimming: Int
        public init(type: String ,fill: BackgroundFill ,dark_theme_dimming: Int) {
            self.type = type
            self.fill = fill
            self.dark_theme_dimming = dark_theme_dimming
        }
    }
}

extension TelegramAPI {
    /**
     * https://core.telegram.org/bots/api#backgroundtypewallpaper  
     * The background is a wallpaper in the JPEG format.
    */
    public struct BackgroundTypeWallpaper: Codable {
        /** String | Type of the background, always "wallpaper" */
        public let type: String
        /** Document | Document with the wallpaper */
        public let document: Document
        /** Integer | Dimming of the background in dark themes, as a percentage; 0-100 */
        public let dark_theme_dimming: Int
        /** Boolean | Optional. True, if the wallpaper is downscaled to fit in a 450x450 square and then box-blurred with radius 12 */
        public let is_blurred: Bool?
        /** Boolean | Optional. True, if the background moves slightly when the device is tilted */
        public let is_moving: Bool?
        public init(type: String ,document: Document ,dark_theme_dimming: Int ,is_blurred: Bool? = nil ,is_moving: Bool? = nil) {
            self.type = type
            self.document = document
            self.dark_theme_dimming = dark_theme_dimming
            self.is_blurred = is_blurred
            self.is_moving = is_moving
        }
    }
}

extension TelegramAPI {
    /**
     * https://core.telegram.org/bots/api#backgroundtypepattern  
     * The background is a .PNG or .TGV (gzipped subset of SVG with MIME type "application/x-tgwallpattern") pattern to be combined with the background fill chosen by the user.
    */
    public struct BackgroundTypePattern: Codable {
        /** String | Type of the background, always "pattern" */
        public let type: String
        /** Document | Document with the pattern */
        public let document: Document
        /** BackgroundFill | The background fill that is combined with the pattern */
        public let fill: BackgroundFill
        /** Integer | Intensity of the pattern when it is shown above the filled background; 0-100 */
        public let intensity: Int
        /** Boolean | Optional. True, if the background fill must be applied only to the pattern itself. All other pixels are black in this case. For dark themes only */
        public let is_inverted: Bool?
        /** Boolean | Optional. True, if the background moves slightly when the device is tilted */
        public let is_moving: Bool?
        public init(type: String ,document: Document ,fill: BackgroundFill ,intensity: Int ,is_inverted: Bool? = nil ,is_moving: Bool? = nil) {
            self.type = type
            self.document = document
            self.fill = fill
            self.intensity = intensity
            self.is_inverted = is_inverted
            self.is_moving = is_moving
        }
    }
}

extension TelegramAPI {
    /**
     * https://core.telegram.org/bots/api#backgroundtypechattheme  
     * The background is taken directly from a built-in chat theme.
    */
    public struct BackgroundTypeChatTheme: Codable {
        /** String | Type of the background, always "chat_theme" */
        public let type: String
        /** String | Name of the chat theme, which is usually an emoji */
        public let theme_name: String
        public init(type: String ,theme_name: String) {
            self.type = type
            self.theme_name = theme_name
        }
    }
}

extension TelegramAPI {
    /**
     * https://core.telegram.org/bots/api#chatbackground  
     * This object represents a chat background.
    */
    public struct ChatBackground: Codable {
        /** BackgroundType | Type of the background */
        public let type: BackgroundType
        public init(type: BackgroundType) {
            self.type = type
        }
    }
}

extension TelegramAPI {
    /**
     * https://core.telegram.org/bots/api#forumtopiccreated  
     * This object represents a service message about a new forum topic created in the chat.
    */
    public struct ForumTopicCreated: Codable {
        /** String | Name of the topic */
        public let name: String
        /** Integer | Color of the topic icon in RGB format */
        public let icon_color: Int
        /** String | Optional. Unique identifier of the custom emoji shown as the topic icon */
        public let icon_custom_emoji_id: String?
        public init(name: String ,icon_color: Int ,icon_custom_emoji_id: String? = nil) {
            self.name = name
            self.icon_color = icon_color
            self.icon_custom_emoji_id = icon_custom_emoji_id
        }
    }
}

extension TelegramAPI {
    /**
     * https://core.telegram.org/bots/api#forumtopicclosed  
     * This object represents a service message about a forum topic closed in the chat. Currently holds no information.
    */
    public struct ForumTopicClosed: Codable {
        public init() {
        }
    }
}

extension TelegramAPI {
    /**
     * https://core.telegram.org/bots/api#forumtopicedited  
     * This object represents a service message about an edited forum topic.
    */
    public struct ForumTopicEdited: Codable {
        /** String | Optional. New name of the topic, if it was edited */
        public let name: String?
        /** String | Optional. New identifier of the custom emoji shown as the topic icon, if it was edited; an empty string if the icon was removed */
        public let icon_custom_emoji_id: String?
        public init(name: String? = nil ,icon_custom_emoji_id: String? = nil) {
            self.name = name
            self.icon_custom_emoji_id = icon_custom_emoji_id
        }
    }
}

extension TelegramAPI {
    /**
     * https://core.telegram.org/bots/api#forumtopicreopened  
     * This object represents a service message about a forum topic reopened in the chat. Currently holds no information.
    */
    public struct ForumTopicReopened: Codable {
        public init() {
        }
    }
}

extension TelegramAPI {
    /**
     * https://core.telegram.org/bots/api#generalforumtopichidden  
     * This object represents a service message about General forum topic hidden in the chat. Currently holds no information.
    */
    public struct GeneralForumTopicHidden: Codable {
        public init() {
        }
    }
}

extension TelegramAPI {
    /**
     * https://core.telegram.org/bots/api#generalforumtopicunhidden  
     * This object represents a service message about General forum topic unhidden in the chat. Currently holds no information.
    */
    public struct GeneralForumTopicUnhidden: Codable {
        public init() {
        }
    }
}

extension TelegramAPI {
    /**
     * https://core.telegram.org/bots/api#shareduser  
     * This object contains information about a user that was shared with the bot using a KeyboardButtonRequestUsers button.
    */
    public struct SharedUser: Codable {
        /** Integer | Identifier of the shared user. This number may have more than 32 significant bits and some programming languages may have difficulty/silent defects in interpreting it. But it has at most 52 significant bits, so 64-bit integers or double-precision float types are safe for storing these identifiers. The bot may not have access to the user and could be unable to use this identifier, unless the user is already known to the bot by some other means. */
        public let user_id: Int
        /** String | Optional. First name of the user, if the name was requested by the bot */
        public let first_name: String?
        /** String | Optional. Last name of the user, if the name was requested by the bot */
        public let last_name: String?
        /** String | Optional. Username of the user, if the username was requested by the bot */
        public let username: String?
        /** Array of PhotoSize | Optional. Available sizes of the chat photo, if the photo was requested by the bot */
        public let photo: Array<PhotoSize>?
        public init(user_id: Int ,first_name: String? = nil ,last_name: String? = nil ,username: String? = nil ,photo: Array<PhotoSize>? = nil) {
            self.user_id = user_id
            self.first_name = first_name
            self.last_name = last_name
            self.username = username
            self.photo = photo
        }
    }
}

extension TelegramAPI {
    /**
     * https://core.telegram.org/bots/api#usersshared  
     * This object contains information about the users whose identifiers were shared with the bot using a KeyboardButtonRequestUsers button.
    */
    public struct UsersShared: Codable {
        /** Integer | Identifier of the request */
        public let request_id: Int
        /** Array of SharedUser | Information about users shared with the bot. */
        public let users: Array<SharedUser>
        public init(request_id: Int ,users: Array<SharedUser>) {
            self.request_id = request_id
            self.users = users
        }
    }
}

extension TelegramAPI {
    /**
     * https://core.telegram.org/bots/api#chatshared  
     * This object contains information about a chat that was shared with the bot using a KeyboardButtonRequestChat button.
    */
    public struct ChatShared: Codable {
        /** Integer | Identifier of the request */
        public let request_id: Int
        /** Integer | Identifier of the shared chat. This number may have more than 32 significant bits and some programming languages may have difficulty/silent defects in interpreting it. But it has at most 52 significant bits, so a 64-bit integer or double-precision float type are safe for storing this identifier. The bot may not have access to the chat and could be unable to use this identifier, unless the chat is already known to the bot by some other means. */
        public let chat_id: Int
        /** String | Optional. Title of the chat, if the title was requested by the bot. */
        public let title: String?
        /** String | Optional. Username of the chat, if the username was requested by the bot and available. */
        public let username: String?
        /** Array of PhotoSize | Optional. Available sizes of the chat photo, if the photo was requested by the bot */
        public let photo: Array<PhotoSize>?
        public init(request_id: Int ,chat_id: Int ,title: String? = nil ,username: String? = nil ,photo: Array<PhotoSize>? = nil) {
            self.request_id = request_id
            self.chat_id = chat_id
            self.title = title
            self.username = username
            self.photo = photo
        }
    }
}

extension TelegramAPI {
    /**
     * https://core.telegram.org/bots/api#writeaccessallowed  
     * This object represents a service message about a user allowing a bot to write messages after adding it to the attachment menu, launching a Web App from a link, or accepting an explicit request from a Web App sent by the method requestWriteAccess.
    */
    public struct WriteAccessAllowed: Codable {
        /** Boolean | Optional. True, if the access was granted after the user accepted an explicit request from a Web App sent by the method requestWriteAccess */
        public let from_request: Bool?
        /** String | Optional. Name of the Web App, if the access was granted when the Web App was launched from a link */
        public let web_app_name: String?
        /** Boolean | Optional. True, if the access was granted when the bot was added to the attachment or side menu */
        public let from_attachment_menu: Bool?
        public init(from_request: Bool? = nil ,web_app_name: String? = nil ,from_attachment_menu: Bool? = nil) {
            self.from_request = from_request
            self.web_app_name = web_app_name
            self.from_attachment_menu = from_attachment_menu
        }
    }
}

extension TelegramAPI {
    /**
     * https://core.telegram.org/bots/api#videochatscheduled  
     * This object represents a service message about a video chat scheduled in the chat.
    */
    public struct VideoChatScheduled: Codable {
        /** Integer | Point in time (Unix timestamp) when the video chat is supposed to be started by a chat administrator */
        public let start_date: Int
        public init(start_date: Int) {
            self.start_date = start_date
        }
    }
}

extension TelegramAPI {
    /**
     * https://core.telegram.org/bots/api#videochatstarted  
     * This object represents a service message about a video chat started in the chat. Currently holds no information.
    */
    public struct VideoChatStarted: Codable {
        public init() {
        }
    }
}

extension TelegramAPI {
    /**
     * https://core.telegram.org/bots/api#videochatended  
     * This object represents a service message about a video chat ended in the chat.
    */
    public struct VideoChatEnded: Codable {
        /** Integer | Video chat duration in seconds */
        public let duration: Int
        public init(duration: Int) {
            self.duration = duration
        }
    }
}

extension TelegramAPI {
    /**
     * https://core.telegram.org/bots/api#videochatparticipantsinvited  
     * This object represents a service message about new members invited to a video chat.
    */
    public struct VideoChatParticipantsInvited: Codable {
        /** Array of User | New members that were invited to the video chat */
        public let users: Array<User>
        public init(users: Array<User>) {
            self.users = users
        }
    }
}

extension TelegramAPI {
    /**
     * https://core.telegram.org/bots/api#giveawaycreated  
     * This object represents a service message about the creation of a scheduled giveaway.
    */
    public struct GiveawayCreated: Codable {
        /** Integer | Optional. The number of Telegram Stars to be split between giveaway winners; for Telegram Star giveaways only */
        public let prize_star_count: Int?
        public init(prize_star_count: Int? = nil) {
            self.prize_star_count = prize_star_count
        }
    }
}

extension TelegramAPI {
    /**
     * https://core.telegram.org/bots/api#giveaway  
     * This object represents a message about a scheduled giveaway.
    */
    public struct Giveaway: Codable {
        /** Array of Chat | The list of chats which the user must join to participate in the giveaway */
        public let chats: Array<Chat>
        /** Integer | Point in time (Unix timestamp) when winners of the giveaway will be selected */
        public let winners_selection_date: Int
        /** Integer | The number of users which are supposed to be selected as winners of the giveaway */
        public let winner_count: Int
        /** Boolean | Optional. True, if only users who join the chats after the giveaway started should be eligible to win */
        public let only_new_members: Bool?
        /** Boolean | Optional. True, if the list of giveaway winners will be visible to everyone */
        public let has_public_winners: Bool?
        /** String | Optional. Description of additional giveaway prize */
        public let prize_description: String?
        /** Array of String | Optional. A list of two-letter ISO 3166-1 alpha-2 country codes indicating the countries from which eligible users for the giveaway must come. If empty, then all users can participate in the giveaway. Users with a phone number that was bought on Fragment can always participate in giveaways. */
        public let country_codes: Array<String>?
        /** Integer | Optional. The number of Telegram Stars to be split between giveaway winners; for Telegram Star giveaways only */
        public let prize_star_count: Int?
        /** Integer | Optional. The number of months the Telegram Premium subscription won from the giveaway will be active for; for Telegram Premium giveaways only */
        public let premium_subscription_month_count: Int?
        public init(chats: Array<Chat> ,winners_selection_date: Int ,winner_count: Int ,only_new_members: Bool? = nil ,has_public_winners: Bool? = nil ,prize_description: String? = nil ,country_codes: Array<String>? = nil ,prize_star_count: Int? = nil ,premium_subscription_month_count: Int? = nil) {
            self.chats = chats
            self.winners_selection_date = winners_selection_date
            self.winner_count = winner_count
            self.only_new_members = only_new_members
            self.has_public_winners = has_public_winners
            self.prize_description = prize_description
            self.country_codes = country_codes
            self.prize_star_count = prize_star_count
            self.premium_subscription_month_count = premium_subscription_month_count
        }
    }
}

extension TelegramAPI {
    /**
     * https://core.telegram.org/bots/api#giveawaywinners  
     * This object represents a message about the completion of a giveaway with public winners.
    */
    public struct GiveawayWinners: Codable {
        /** Chat | The chat that created the giveaway */
        public let chat: Chat
        /** Integer | Identifier of the message with the giveaway in the chat */
        public let giveaway_message_id: Int
        /** Integer | Point in time (Unix timestamp) when winners of the giveaway were selected */
        public let winners_selection_date: Int
        /** Integer | Total number of winners in the giveaway */
        public let winner_count: Int
        /** Array of User | List of up to 100 winners of the giveaway */
        public let winners: Array<User>
        /** Integer | Optional. The number of other chats the user had to join in order to be eligible for the giveaway */
        public let additional_chat_count: Int?
        /** Integer | Optional. The number of Telegram Stars that were split between giveaway winners; for Telegram Star giveaways only */
        public let prize_star_count: Int?
        /** Integer | Optional. The number of months the Telegram Premium subscription won from the giveaway will be active for; for Telegram Premium giveaways only */
        public let premium_subscription_month_count: Int?
        /** Integer | Optional. Number of undistributed prizes */
        public let unclaimed_prize_count: Int?
        /** Boolean | Optional. True, if only users who had joined the chats after the giveaway started were eligible to win */
        public let only_new_members: Bool?
        /** Boolean | Optional. True, if the giveaway was canceled because the payment for it was refunded */
        public let was_refunded: Bool?
        /** String | Optional. Description of additional giveaway prize */
        public let prize_description: String?
        public init(chat: Chat ,giveaway_message_id: Int ,winners_selection_date: Int ,winner_count: Int ,winners: Array<User> ,additional_chat_count: Int? = nil ,prize_star_count: Int? = nil ,premium_subscription_month_count: Int? = nil ,unclaimed_prize_count: Int? = nil ,only_new_members: Bool? = nil ,was_refunded: Bool? = nil ,prize_description: String? = nil) {
            self.chat = chat
            self.giveaway_message_id = giveaway_message_id
            self.winners_selection_date = winners_selection_date
            self.winner_count = winner_count
            self.winners = winners
            self.additional_chat_count = additional_chat_count
            self.prize_star_count = prize_star_count
            self.premium_subscription_month_count = premium_subscription_month_count
            self.unclaimed_prize_count = unclaimed_prize_count
            self.only_new_members = only_new_members
            self.was_refunded = was_refunded
            self.prize_description = prize_description
        }
    }
}

extension TelegramAPI {
    /**
     * https://core.telegram.org/bots/api#giveawaycompleted  
     * This object represents a service message about the completion of a giveaway without public winners.
    */
    public struct GiveawayCompleted: Codable {
        /** Integer | Number of winners in the giveaway */
        public let winner_count: Int
        /** Integer | Optional. Number of undistributed prizes */
        public let unclaimed_prize_count: Int?
        /** ValueWrapper<Message> | Optional. Message with the giveaway that was completed, if it wasn't deleted */
        public let giveaway_message: ValueWrapper<Message>?
        /** Boolean | Optional. True, if the giveaway is a Telegram Star giveaway. Otherwise, currently, the giveaway is a Telegram Premium giveaway. */
        public let is_star_giveaway: Bool?
        public init(winner_count: Int ,unclaimed_prize_count: Int? = nil ,giveaway_message: ValueWrapper<Message>? = nil ,is_star_giveaway: Bool? = nil) {
            self.winner_count = winner_count
            self.unclaimed_prize_count = unclaimed_prize_count
            self.giveaway_message = giveaway_message
            self.is_star_giveaway = is_star_giveaway
        }
    }
}

extension TelegramAPI {
    /**
     * https://core.telegram.org/bots/api#linkpreviewoptions  
     * Describes the options used for link preview generation.
    */
    public struct LinkPreviewOptions: Codable {
        /** Boolean | Optional. True, if the link preview is disabled */
        public let is_disabled: Bool?
        /** String | Optional. URL to use for the link preview. If empty, then the first URL found in the message text will be used */
        public let url: String?
        /** Boolean | Optional. True, if the media in the link preview is supposed to be shrunk; ignored if the URL isn't explicitly specified or media size change isn't supported for the preview */
        public let prefer_small_media: Bool?
        /** Boolean | Optional. True, if the media in the link preview is supposed to be enlarged; ignored if the URL isn't explicitly specified or media size change isn't supported for the preview */
        public let prefer_large_media: Bool?
        /** Boolean | Optional. True, if the link preview must be shown above the message text; otherwise, the link preview will be shown below the message text */
        public let show_above_text: Bool?
        public init(is_disabled: Bool? = nil ,url: String? = nil ,prefer_small_media: Bool? = nil ,prefer_large_media: Bool? = nil ,show_above_text: Bool? = nil) {
            self.is_disabled = is_disabled
            self.url = url
            self.prefer_small_media = prefer_small_media
            self.prefer_large_media = prefer_large_media
            self.show_above_text = show_above_text
        }
    }
}

extension TelegramAPI {
    /**
     * https://core.telegram.org/bots/api#userprofilephotos  
     * This object represent a user's profile pictures.
    */
    public struct UserProfilePhotos: Codable {
        /** Integer | Total number of profile pictures the target user has */
        public let total_count: Int
        /** Array of Array of PhotoSize | Requested profile pictures (in up to 4 sizes each) */
        public let photos: Array<Array<PhotoSize>>
        public init(total_count: Int ,photos: Array<Array<PhotoSize>>) {
            self.total_count = total_count
            self.photos = photos
        }
    }
}

extension TelegramAPI {
    /**
     * https://core.telegram.org/bots/api#file  
     * This object represents a file ready to be downloaded. The file can be downloaded via the link https://api.telegram.org/file/bot<token>/<file_path>. It is guaranteed that the link will be valid for at least 1 hour. When the link expires, a new one can be requested by calling getFile.
    */
    public struct File: Codable {
        /** String | Identifier for this file, which can be used to download or reuse the file */
        public let file_id: String
        /** String | Unique identifier for this file, which is supposed to be the same over time and for different bots. Can't be used to download or reuse the file. */
        public let file_unique_id: String
        /** Integer | Optional. File size in bytes. It can be bigger than 2^31 and some programming languages may have difficulty/silent defects in interpreting it. But it has at most 52 significant bits, so a signed 64-bit integer or double-precision float type are safe for storing this value. */
        public let file_size: Int?
        /** String | Optional. File path. Use https://api.telegram.org/file/bot<token>/<file_path> to get the file. */
        public let file_path: String?
        public init(file_id: String ,file_unique_id: String ,file_size: Int? = nil ,file_path: String? = nil) {
            self.file_id = file_id
            self.file_unique_id = file_unique_id
            self.file_size = file_size
            self.file_path = file_path
        }
    }
}

extension TelegramAPI {
    /**
     * https://core.telegram.org/bots/api#webappinfo  
     * Describes a Web App.
    */
    public struct WebAppInfo: Codable {
        /** String | An HTTPS URL of a Web App to be opened with additional data as specified in Initializing Web Apps */
        public let url: String
        public init(url: String) {
            self.url = url
        }
    }
}

extension TelegramAPI {
    /**
     * https://core.telegram.org/bots/api#replykeyboardmarkup  
     * This object represents a custom keyboard with reply options (see Introduction to bots for details and examples). Not supported in channels and for messages sent on behalf of a Telegram Business account.
    */
    public struct ReplyKeyboardMarkup: Codable {
        /** Array of Array of KeyboardButton | Array of button rows, each represented by an Array of KeyboardButton objects */
        public let keyboard: Array<Array<KeyboardButton>>
        /** Boolean | Optional. Requests clients to always show the keyboard when the regular keyboard is hidden. Defaults to false, in which case the custom keyboard can be hidden and opened with a keyboard icon. */
        public let is_persistent: Bool?
        /** Boolean | Optional. Requests clients to resize the keyboard vertically for optimal fit (e.g., make the keyboard smaller if there are just two rows of buttons). Defaults to false, in which case the custom keyboard is always of the same height as the app's standard keyboard. */
        public let resize_keyboard: Bool?
        /** Boolean | Optional. Requests clients to hide the keyboard as soon as it's been used. The keyboard will still be available, but clients will automatically display the usual letter-keyboard in the chat - the user can press a special button in the input field to see the custom keyboard again. Defaults to false. */
        public let one_time_keyboard: Bool?
        /** String | Optional. The placeholder to be shown in the input field when the keyboard is active; 1-64 characters */
        public let input_field_placeholder: String?
        /** Boolean | Optional. Use this parameter if you want to show the keyboard to specific users only. Targets: 1) users that are @mentioned in the text of the Message object; 2) if the bot's message is a reply to a message in the same chat and forum topic, sender of the original message. Example: A user requests to change the bot's language, bot replies to the request with a keyboard to select the new language. Other users in the group don't see the keyboard. */
        public let selective: Bool?
        public init(keyboard: Array<Array<KeyboardButton>> ,is_persistent: Bool? = nil ,resize_keyboard: Bool? = nil ,one_time_keyboard: Bool? = nil ,input_field_placeholder: String? = nil ,selective: Bool? = nil) {
            self.keyboard = keyboard
            self.is_persistent = is_persistent
            self.resize_keyboard = resize_keyboard
            self.one_time_keyboard = one_time_keyboard
            self.input_field_placeholder = input_field_placeholder
            self.selective = selective
        }
    }
}

extension TelegramAPI {
    /**
     * https://core.telegram.org/bots/api#keyboardbutton  
     * This object represents one button of the reply keyboard. At most one of the optional fields must be used to specify type of the button. For simple text buttons, String can be used instead of this object to specify the button text.
     * Note: request_users and request_chat options will only work in Telegram versions released after 3 February, 2023. Older clients will display unsupported message.
    */
    public struct KeyboardButton: Codable {
        /** String | Text of the button. If none of the optional fields are used, it will be sent as a message when the button is pressed */
        public let text: String
        /** KeyboardButtonRequestUsers | Optional. If specified, pressing the button will open a list of suitable users. Identifiers of selected users will be sent to the bot in a "users_shared" service message. Available in private chats only. */
        public let request_users: KeyboardButtonRequestUsers?
        /** KeyboardButtonRequestChat | Optional. If specified, pressing the button will open a list of suitable chats. Tapping on a chat will send its identifier to the bot in a "chat_shared" service message. Available in private chats only. */
        public let request_chat: KeyboardButtonRequestChat?
        /** Boolean | Optional. If True, the user's phone number will be sent as a contact when the button is pressed. Available in private chats only. */
        public let request_contact: Bool?
        /** Boolean | Optional. If True, the user's current location will be sent when the button is pressed. Available in private chats only. */
        public let request_location: Bool?
        /** KeyboardButtonPollType | Optional. If specified, the user will be asked to create a poll and send it to the bot when the button is pressed. Available in private chats only. */
        public let request_poll: KeyboardButtonPollType?
        /** WebAppInfo | Optional. If specified, the described Web App will be launched when the button is pressed. The Web App will be able to send a "web_app_data" service message. Available in private chats only. */
        public let web_app: WebAppInfo?
        public init(text: String ,request_users: KeyboardButtonRequestUsers? = nil ,request_chat: KeyboardButtonRequestChat? = nil ,request_contact: Bool? = nil ,request_location: Bool? = nil ,request_poll: KeyboardButtonPollType? = nil ,web_app: WebAppInfo? = nil) {
            self.text = text
            self.request_users = request_users
            self.request_chat = request_chat
            self.request_contact = request_contact
            self.request_location = request_location
            self.request_poll = request_poll
            self.web_app = web_app
        }
    }
}

extension TelegramAPI {
    /**
     * https://core.telegram.org/bots/api#keyboardbuttonrequestusers  
     * This object defines the criteria used to request suitable users. Information about the selected users will be shared with the bot when the corresponding button is pressed. More about requesting users: https://core.telegram.org/bots/features#chat-and-user-selection
    */
    public struct KeyboardButtonRequestUsers: Codable {
        /** Integer | Signed 32-bit identifier of the request that will be received back in the UsersShared object. Must be unique within the message */
        public let request_id: Int
        /** Boolean | Optional. Pass True to request bots, pass False to request regular users. If not specified, no additional restrictions are applied. */
        public let user_is_bot: Bool?
        /** Boolean | Optional. Pass True to request premium users, pass False to request non-premium users. If not specified, no additional restrictions are applied. */
        public let user_is_premium: Bool?
        /** Integer | Optional. The maximum number of users to be selected; 1-10. Defaults to 1. */
        public let max_quantity: Int?
        /** Boolean | Optional. Pass True to request the users' first and last names */
        public let request_name: Bool?
        /** Boolean | Optional. Pass True to request the users' usernames */
        public let request_username: Bool?
        /** Boolean | Optional. Pass True to request the users' photos */
        public let request_photo: Bool?
        public init(request_id: Int ,user_is_bot: Bool? = nil ,user_is_premium: Bool? = nil ,max_quantity: Int? = nil ,request_name: Bool? = nil ,request_username: Bool? = nil ,request_photo: Bool? = nil) {
            self.request_id = request_id
            self.user_is_bot = user_is_bot
            self.user_is_premium = user_is_premium
            self.max_quantity = max_quantity
            self.request_name = request_name
            self.request_username = request_username
            self.request_photo = request_photo
        }
    }
}

extension TelegramAPI {
    /**
     * https://core.telegram.org/bots/api#keyboardbuttonrequestchat  
     * This object defines the criteria used to request a suitable chat. Information about the selected chat will be shared with the bot when the corresponding button is pressed. The bot will be granted requested rights in the chat if appropriate. More about requesting chats: https://core.telegram.org/bots/features#chat-and-user-selection.
    */
    public struct KeyboardButtonRequestChat: Codable {
        /** Integer | Signed 32-bit identifier of the request, which will be received back in the ChatShared object. Must be unique within the message */
        public let request_id: Int
        /** Boolean | Pass True to request a channel chat, pass False to request a group or a supergroup chat. */
        public let chat_is_channel: Bool
        /** Boolean | Optional. Pass True to request a forum supergroup, pass False to request a non-forum chat. If not specified, no additional restrictions are applied. */
        public let chat_is_forum: Bool?
        /** Boolean | Optional. Pass True to request a supergroup or a channel with a username, pass False to request a chat without a username. If not specified, no additional restrictions are applied. */
        public let chat_has_username: Bool?
        /** Boolean | Optional. Pass True to request a chat owned by the user. Otherwise, no additional restrictions are applied. */
        public let chat_is_created: Bool?
        /** ChatAdministratorRights | Optional. A JSON-serialized object listing the required administrator rights of the user in the chat. The rights must be a superset of bot_administrator_rights. If not specified, no additional restrictions are applied. */
        public let user_administrator_rights: ChatAdministratorRights?
        /** ChatAdministratorRights | Optional. A JSON-serialized object listing the required administrator rights of the bot in the chat. The rights must be a subset of user_administrator_rights. If not specified, no additional restrictions are applied. */
        public let bot_administrator_rights: ChatAdministratorRights?
        /** Boolean | Optional. Pass True to request a chat with the bot as a member. Otherwise, no additional restrictions are applied. */
        public let bot_is_member: Bool?
        /** Boolean | Optional. Pass True to request the chat's title */
        public let request_title: Bool?
        /** Boolean | Optional. Pass True to request the chat's username */
        public let request_username: Bool?
        /** Boolean | Optional. Pass True to request the chat's photo */
        public let request_photo: Bool?
        public init(request_id: Int ,chat_is_channel: Bool ,chat_is_forum: Bool? = nil ,chat_has_username: Bool? = nil ,chat_is_created: Bool? = nil ,user_administrator_rights: ChatAdministratorRights? = nil ,bot_administrator_rights: ChatAdministratorRights? = nil ,bot_is_member: Bool? = nil ,request_title: Bool? = nil ,request_username: Bool? = nil ,request_photo: Bool? = nil) {
            self.request_id = request_id
            self.chat_is_channel = chat_is_channel
            self.chat_is_forum = chat_is_forum
            self.chat_has_username = chat_has_username
            self.chat_is_created = chat_is_created
            self.user_administrator_rights = user_administrator_rights
            self.bot_administrator_rights = bot_administrator_rights
            self.bot_is_member = bot_is_member
            self.request_title = request_title
            self.request_username = request_username
            self.request_photo = request_photo
        }
    }
}

extension TelegramAPI {
    /**
     * https://core.telegram.org/bots/api#keyboardbuttonpolltype  
     * This object represents type of a poll, which is allowed to be created and sent when the corresponding button is pressed.
    */
    public struct KeyboardButtonPollType: Codable {
        /** String | Optional. If quiz is passed, the user will be allowed to create only polls in the quiz mode. If regular is passed, only regular polls will be allowed. Otherwise, the user will be allowed to create a poll of any type. */
        public let type: String?
        public init(type: String? = nil) {
            self.type = type
        }
    }
}

extension TelegramAPI {
    /**
     * https://core.telegram.org/bots/api#replykeyboardremove  
     * Upon receiving a message with this object, Telegram clients will remove the current custom keyboard and display the default letter-keyboard. By default, custom keyboards are displayed until a new keyboard is sent by a bot. An exception is made for one-time keyboards that are hidden immediately after the user presses a button (see ReplyKeyboardMarkup). Not supported in channels and for messages sent on behalf of a Telegram Business account.
    */
    public struct ReplyKeyboardRemove: Codable {
        /** Boolean | Requests clients to remove the custom keyboard (user will not be able to summon this keyboard; if you want to hide the keyboard from sight but keep it accessible, use one_time_keyboard in ReplyKeyboardMarkup) */
        public let remove_keyboard: Bool
        /** Boolean | Optional. Use this parameter if you want to remove the keyboard for specific users only. Targets: 1) users that are @mentioned in the text of the Message object; 2) if the bot's message is a reply to a message in the same chat and forum topic, sender of the original message. Example: A user votes in a poll, bot returns confirmation message in reply to the vote and removes the keyboard for that user, while still showing the keyboard with poll options to users who haven't voted yet. */
        public let selective: Bool?
        public init(remove_keyboard: Bool ,selective: Bool? = nil) {
            self.remove_keyboard = remove_keyboard
            self.selective = selective
        }
    }
}

extension TelegramAPI {
    /**
     * https://core.telegram.org/bots/api#inlinekeyboardmarkup  
     * This object represents an inline keyboard that appears right next to the message it belongs to.
    */
    public struct InlineKeyboardMarkup: Codable {
        /** Array of Array of InlineKeyboardButton | Array of button rows, each represented by an Array of InlineKeyboardButton objects */
        public let inline_keyboard: Array<Array<InlineKeyboardButton>>
        public init(inline_keyboard: Array<Array<InlineKeyboardButton>>) {
            self.inline_keyboard = inline_keyboard
        }
    }
}

extension TelegramAPI {
    /**
     * https://core.telegram.org/bots/api#inlinekeyboardbutton  
     * This object represents one button of an inline keyboard. Exactly one of the optional fields must be used to specify type of the button.
    */
    public struct InlineKeyboardButton: Codable {
        /** String | Label text on the button */
        public let text: String
        /** String | Optional. HTTP or tg:// URL to be opened when the button is pressed. Links tg://user?id=<user_id> can be used to mention a user by their identifier without using a username, if this is allowed by their privacy settings. */
        public let url: String?
        /** String | Optional. Data to be sent in a callback query to the bot when the button is pressed, 1-64 bytes */
        public let callback_data: String?
        /** WebAppInfo | Optional. Description of the Web App that will be launched when the user presses the button. The Web App will be able to send an arbitrary message on behalf of the user using the method answerWebAppQuery. Available only in private chats between a user and the bot. Not supported for messages sent on behalf of a Telegram Business account. */
        public let web_app: WebAppInfo?
        /** LoginUrl | Optional. An HTTPS URL used to automatically authorize the user. Can be used as a replacement for the Telegram Login Widget. */
        public let login_url: LoginUrl?
        /** String | Optional. If set, pressing the button will prompt the user to select one of their chats, open that chat and insert the bot's username and the specified inline query in the input field. May be empty, in which case just the bot's username will be inserted. Not supported for messages sent on behalf of a Telegram Business account. */
        public let switch_inline_query: String?
        /** String | Optional. If set, pressing the button will insert the bot's username and the specified inline query in the current chat's input field. May be empty, in which case only the bot's username will be inserted. This offers a quick way for the user to open your bot in inline mode in the same chat - good for selecting something from multiple options. Not supported in channels and for messages sent on behalf of a Telegram Business account. */
        public let switch_inline_query_current_chat: String?
        /** SwitchInlineQueryChosenChat | Optional. If set, pressing the button will prompt the user to select one of their chats of the specified type, open that chat and insert the bot's username and the specified inline query in the input field. Not supported for messages sent on behalf of a Telegram Business account. */
        public let switch_inline_query_chosen_chat: SwitchInlineQueryChosenChat?
        /** CopyTextButton | Optional. Description of the button that copies the specified text to the clipboard. */
        public let copy_text: CopyTextButton?
        /** CallbackGame | Optional. Description of the game that will be launched when the user presses the button. NOTE: This type of button must always be the first button in the first row. */
        public let callback_game: CallbackGame?
        /** Boolean | Optional. Specify True, to send a Pay button. Substrings "" and "XTR" in the buttons's text will be replaced with a Telegram Star icon. NOTE: This type of button must always be the first button in the first row and can only be used in invoice messages. */
        public let pay: Bool?
        public init(text: String ,url: String? = nil ,callback_data: String? = nil ,web_app: WebAppInfo? = nil ,login_url: LoginUrl? = nil ,switch_inline_query: String? = nil ,switch_inline_query_current_chat: String? = nil ,switch_inline_query_chosen_chat: SwitchInlineQueryChosenChat? = nil ,copy_text: CopyTextButton? = nil ,callback_game: CallbackGame? = nil ,pay: Bool? = nil) {
            self.text = text
            self.url = url
            self.callback_data = callback_data
            self.web_app = web_app
            self.login_url = login_url
            self.switch_inline_query = switch_inline_query
            self.switch_inline_query_current_chat = switch_inline_query_current_chat
            self.switch_inline_query_chosen_chat = switch_inline_query_chosen_chat
            self.copy_text = copy_text
            self.callback_game = callback_game
            self.pay = pay
        }
    }
}

extension TelegramAPI {
    /**
     * https://core.telegram.org/bots/api#loginurl  
     * This object represents a parameter of the inline keyboard button used to automatically authorize a user. Serves as a great replacement for the Telegram Login Widget when the user is coming from Telegram. All the user needs to do is tap/click a button and confirm that they want to log in:
     * Telegram apps support these buttons as of version 5.7.
    */
    public struct LoginUrl: Codable {
        /** String | An HTTPS URL to be opened with user authorization data added to the query string when the button is pressed. If the user refuses to provide authorization data, the original URL without information about the user will be opened. The data added is the same as described in Receiving authorization data. NOTE: You must always check the hash of the received data to verify the authentication and the integrity of the data as described in Checking authorization. */
        public let url: String
        /** String | Optional. New text of the button in forwarded messages. */
        public let forward_text: String?
        /** String | Optional. Username of a bot, which will be used for user authorization. See Setting up a bot for more details. If not specified, the current bot's username will be assumed. The url's domain must be the same as the domain linked with the bot. See Linking your domain to the bot for more details. */
        public let bot_username: String?
        /** Boolean | Optional. Pass True to request the permission for your bot to send messages to the user. */
        public let request_write_access: Bool?
        public init(url: String ,forward_text: String? = nil ,bot_username: String? = nil ,request_write_access: Bool? = nil) {
            self.url = url
            self.forward_text = forward_text
            self.bot_username = bot_username
            self.request_write_access = request_write_access
        }
    }
}

extension TelegramAPI {
    /**
     * https://core.telegram.org/bots/api#switchinlinequerychosenchat  
     * This object represents an inline button that switches the current user to inline mode in a chosen chat, with an optional default inline query.
    */
    public struct SwitchInlineQueryChosenChat: Codable {
        /** String | Optional. The default inline query to be inserted in the input field. If left empty, only the bot's username will be inserted */
        public let query: String?
        /** Boolean | Optional. True, if private chats with users can be chosen */
        public let allow_user_chats: Bool?
        /** Boolean | Optional. True, if private chats with bots can be chosen */
        public let allow_bot_chats: Bool?
        /** Boolean | Optional. True, if group and supergroup chats can be chosen */
        public let allow_group_chats: Bool?
        /** Boolean | Optional. True, if channel chats can be chosen */
        public let allow_channel_chats: Bool?
        public init(query: String? = nil ,allow_user_chats: Bool? = nil ,allow_bot_chats: Bool? = nil ,allow_group_chats: Bool? = nil ,allow_channel_chats: Bool? = nil) {
            self.query = query
            self.allow_user_chats = allow_user_chats
            self.allow_bot_chats = allow_bot_chats
            self.allow_group_chats = allow_group_chats
            self.allow_channel_chats = allow_channel_chats
        }
    }
}

extension TelegramAPI {
    /**
     * https://core.telegram.org/bots/api#copytextbutton  
     * This object represents an inline keyboard button that copies specified text to the clipboard.
    */
    public struct CopyTextButton: Codable {
        /** String | The text to be copied to the clipboard; 1-256 characters */
        public let text: String
        public init(text: String) {
            self.text = text
        }
    }
}

extension TelegramAPI {
    /**
     * https://core.telegram.org/bots/api#callbackquery  
     * This object represents an incoming callback query from a callback button in an inline keyboard. If the button that originated the query was attached to a message sent by the bot, the field message will be present. If the button was attached to a message sent via the bot (in inline mode), the field inline_message_id will be present. Exactly one of the fields data or game_short_name will be present.
    */
    public struct CallbackQuery: Codable {
        /** String | Unique identifier for this query */
        public let id: String
        /** User | Sender */
        public let from: User
        /** MaybeInaccessibleMessage | Optional. Message sent by the bot with the callback button that originated the query */
        public let message: MaybeInaccessibleMessage?
        /** String | Optional. Identifier of the message sent via the bot in inline mode, that originated the query. */
        public let inline_message_id: String?
        /** String | Global identifier, uniquely corresponding to the chat to which the message with the callback button was sent. Useful for high scores in games. */
        public let chat_instance: String
        /** String | Optional. Data associated with the callback button. Be aware that the message originated the query can contain no callback buttons with this data. */
        public let data: String?
        /** String | Optional. Short name of a Game to be returned, serves as the unique identifier for the game */
        public let game_short_name: String?
        public init(id: String ,from: User ,message: MaybeInaccessibleMessage? = nil ,inline_message_id: String? = nil ,chat_instance: String ,data: String? = nil ,game_short_name: String? = nil) {
            self.id = id
            self.from = from
            self.message = message
            self.inline_message_id = inline_message_id
            self.chat_instance = chat_instance
            self.data = data
            self.game_short_name = game_short_name
        }
    }
}

extension TelegramAPI {
    /**
     * https://core.telegram.org/bots/api#forcereply  
     * Upon receiving a message with this object, Telegram clients will display a reply interface to the user (act as if the user has selected the bot's message and tapped 'Reply'). This can be extremely useful if you want to create user-friendly step-by-step interfaces without having to sacrifice privacy mode. Not supported in channels and for messages sent on behalf of a Telegram Business account.
    */
    public struct ForceReply: Codable {
        /** Boolean | Shows reply interface to the user, as if they manually selected the bot's message and tapped 'Reply' */
        public let force_reply: Bool
        /** String | Optional. The placeholder to be shown in the input field when the reply is active; 1-64 characters */
        public let input_field_placeholder: String?
        /** Boolean | Optional. Use this parameter if you want to force reply from specific users only. Targets: 1) users that are @mentioned in the text of the Message object; 2) if the bot's message is a reply to a message in the same chat and forum topic, sender of the original message. */
        public let selective: Bool?
        public init(force_reply: Bool ,input_field_placeholder: String? = nil ,selective: Bool? = nil) {
            self.force_reply = force_reply
            self.input_field_placeholder = input_field_placeholder
            self.selective = selective
        }
    }
}

extension TelegramAPI {
    /**
     * https://core.telegram.org/bots/api#chatphoto  
     * This object represents a chat photo.
    */
    public struct ChatPhoto: Codable {
        /** String | File identifier of small (160x160) chat photo. This file_id can be used only for photo download and only for as long as the photo is not changed. */
        public let small_file_id: String
        /** String | Unique file identifier of small (160x160) chat photo, which is supposed to be the same over time and for different bots. Can't be used to download or reuse the file. */
        public let small_file_unique_id: String
        /** String | File identifier of big (640x640) chat photo. This file_id can be used only for photo download and only for as long as the photo is not changed. */
        public let big_file_id: String
        /** String | Unique file identifier of big (640x640) chat photo, which is supposed to be the same over time and for different bots. Can't be used to download or reuse the file. */
        public let big_file_unique_id: String
        public init(small_file_id: String ,small_file_unique_id: String ,big_file_id: String ,big_file_unique_id: String) {
            self.small_file_id = small_file_id
            self.small_file_unique_id = small_file_unique_id
            self.big_file_id = big_file_id
            self.big_file_unique_id = big_file_unique_id
        }
    }
}

extension TelegramAPI {
    /**
     * https://core.telegram.org/bots/api#chatinvitelink  
     * Represents an invite link for a chat.
    */
    public struct ChatInviteLink: Codable {
        /** String | The invite link. If the link was created by another chat administrator, then the second part of the link will be replaced with "...". */
        public let invite_link: String
        /** User | Creator of the link */
        public let creator: User
        /** Boolean | True, if users joining the chat via the link need to be approved by chat administrators */
        public let creates_join_request: Bool
        /** Boolean | True, if the link is primary */
        public let is_primary: Bool
        /** Boolean | True, if the link is revoked */
        public let is_revoked: Bool
        /** String | Optional. Invite link name */
        public let name: String?
        /** Integer | Optional. Point in time (Unix timestamp) when the link will expire or has been expired */
        public let expire_date: Int?
        /** Integer | Optional. The maximum number of users that can be members of the chat simultaneously after joining the chat via this invite link; 1-99999 */
        public let member_limit: Int?
        /** Integer | Optional. Number of pending join requests created using this link */
        public let pending_join_request_count: Int?
        /** Integer | Optional. The number of seconds the subscription will be active for before the next payment */
        public let subscription_period: Int?
        /** Integer | Optional. The amount of Telegram Stars a user must pay initially and after each subsequent subscription period to be a member of the chat using the link */
        public let subscription_price: Int?
        public init(invite_link: String ,creator: User ,creates_join_request: Bool ,is_primary: Bool ,is_revoked: Bool ,name: String? = nil ,expire_date: Int? = nil ,member_limit: Int? = nil ,pending_join_request_count: Int? = nil ,subscription_period: Int? = nil ,subscription_price: Int? = nil) {
            self.invite_link = invite_link
            self.creator = creator
            self.creates_join_request = creates_join_request
            self.is_primary = is_primary
            self.is_revoked = is_revoked
            self.name = name
            self.expire_date = expire_date
            self.member_limit = member_limit
            self.pending_join_request_count = pending_join_request_count
            self.subscription_period = subscription_period
            self.subscription_price = subscription_price
        }
    }
}

extension TelegramAPI {
    /**
     * https://core.telegram.org/bots/api#chatadministratorrights  
     * Represents the rights of an administrator in a chat.
    */
    public struct ChatAdministratorRights: Codable {
        /** Boolean | True, if the user's presence in the chat is hidden */
        public let is_anonymous: Bool
        /** Boolean | True, if the administrator can access the chat event log, get boost list, see hidden supergroup and channel members, report spam messages and ignore slow mode. Implied by any other administrator privilege. */
        public let can_manage_chat: Bool
        /** Boolean | True, if the administrator can delete messages of other users */
        public let can_delete_messages: Bool
        /** Boolean | True, if the administrator can manage video chats */
        public let can_manage_video_chats: Bool
        /** Boolean | True, if the administrator can restrict, ban or unban chat members, or access supergroup statistics */
        public let can_restrict_members: Bool
        /** Boolean | True, if the administrator can add new administrators with a subset of their own privileges or demote administrators that they have promoted, directly or indirectly (promoted by administrators that were appointed by the user) */
        public let can_promote_members: Bool
        /** Boolean | True, if the user is allowed to change the chat title, photo and other settings */
        public let can_change_info: Bool
        /** Boolean | True, if the user is allowed to invite new users to the chat */
        public let can_invite_users: Bool
        /** Boolean | True, if the administrator can post stories to the chat */
        public let can_post_stories: Bool
        /** Boolean | True, if the administrator can edit stories posted by other users, post stories to the chat page, pin chat stories, and access the chat's story archive */
        public let can_edit_stories: Bool
        /** Boolean | True, if the administrator can delete stories posted by other users */
        public let can_delete_stories: Bool
        /** Boolean | Optional. True, if the administrator can post messages in the channel, or access channel statistics; for channels only */
        public let can_post_messages: Bool?
        /** Boolean | Optional. True, if the administrator can edit messages of other users and can pin messages; for channels only */
        public let can_edit_messages: Bool?
        /** Boolean | Optional. True, if the user is allowed to pin messages; for groups and supergroups only */
        public let can_pin_messages: Bool?
        /** Boolean | Optional. True, if the user is allowed to create, rename, close, and reopen forum topics; for supergroups only */
        public let can_manage_topics: Bool?
        public init(is_anonymous: Bool ,can_manage_chat: Bool ,can_delete_messages: Bool ,can_manage_video_chats: Bool ,can_restrict_members: Bool ,can_promote_members: Bool ,can_change_info: Bool ,can_invite_users: Bool ,can_post_stories: Bool ,can_edit_stories: Bool ,can_delete_stories: Bool ,can_post_messages: Bool? = nil ,can_edit_messages: Bool? = nil ,can_pin_messages: Bool? = nil ,can_manage_topics: Bool? = nil) {
            self.is_anonymous = is_anonymous
            self.can_manage_chat = can_manage_chat
            self.can_delete_messages = can_delete_messages
            self.can_manage_video_chats = can_manage_video_chats
            self.can_restrict_members = can_restrict_members
            self.can_promote_members = can_promote_members
            self.can_change_info = can_change_info
            self.can_invite_users = can_invite_users
            self.can_post_stories = can_post_stories
            self.can_edit_stories = can_edit_stories
            self.can_delete_stories = can_delete_stories
            self.can_post_messages = can_post_messages
            self.can_edit_messages = can_edit_messages
            self.can_pin_messages = can_pin_messages
            self.can_manage_topics = can_manage_topics
        }
    }
}

extension TelegramAPI {
    /**
     * https://core.telegram.org/bots/api#chatmemberupdated  
     * This object represents changes in the status of a chat member.
    */
    public struct ChatMemberUpdated: Codable {
        /** Chat | Chat the user belongs to */
        public let chat: Chat
        /** User | Performer of the action, which resulted in the change */
        public let from: User
        /** Integer | Date the change was done in Unix time */
        public let date: Int
        /** ChatMember | Previous information about the chat member */
        public let old_chat_member: ChatMember
        /** ChatMember | New information about the chat member */
        public let new_chat_member: ChatMember
        /** ChatInviteLink | Optional. Chat invite link, which was used by the user to join the chat; for joining by invite link events only. */
        public let invite_link: ChatInviteLink?
        /** Boolean | Optional. True, if the user joined the chat after sending a direct join request without using an invite link and being approved by an administrator */
        public let via_join_request: Bool?
        /** Boolean | Optional. True, if the user joined the chat via a chat folder invite link */
        public let via_chat_folder_invite_link: Bool?
        public init(chat: Chat ,from: User ,date: Int ,old_chat_member: ChatMember ,new_chat_member: ChatMember ,invite_link: ChatInviteLink? = nil ,via_join_request: Bool? = nil ,via_chat_folder_invite_link: Bool? = nil) {
            self.chat = chat
            self.from = from
            self.date = date
            self.old_chat_member = old_chat_member
            self.new_chat_member = new_chat_member
            self.invite_link = invite_link
            self.via_join_request = via_join_request
            self.via_chat_folder_invite_link = via_chat_folder_invite_link
        }
    }
}

extension TelegramAPI {
    /**
     * https://core.telegram.org/bots/api#chatmember  
     * This object contains information about one member of a chat. Currently, the following 6 types of chat members are supported:
     * - ChatMemberOwner
     * - ChatMemberAdministrator
     * - ChatMemberMember
     * - ChatMemberRestricted
     * - ChatMemberLeft
     * - ChatMemberBanned
    */
    public indirect enum ChatMember: Codable {
        case chatMemberOwner(ChatMemberOwner)
        case chatMemberAdministrator(ChatMemberAdministrator)
        case chatMemberMember(ChatMemberMember)
        case chatMemberRestricted(ChatMemberRestricted)
        case chatMemberLeft(ChatMemberLeft)
        case chatMemberBanned(ChatMemberBanned)

        public init(from decoder: Decoder) throws {
            let container = try decoder.singleValueContainer()
            if let value = try? container.decode(ChatMemberOwner.self) {
                self = .chatMemberOwner(value)
            }
            else if let value = try? container.decode(ChatMemberAdministrator.self) {
                self = .chatMemberAdministrator(value)
            }
            else if let value = try? container.decode(ChatMemberMember.self) {
                self = .chatMemberMember(value)
            }
            else if let value = try? container.decode(ChatMemberRestricted.self) {
                self = .chatMemberRestricted(value)
            }
            else if let value = try? container.decode(ChatMemberLeft.self) {
                self = .chatMemberLeft(value)
            }
            else if let value = try? container.decode(ChatMemberBanned.self) {
                self = .chatMemberBanned(value)
            }else {
                throw DecodingError.typeMismatch(ChatMember.self, DecodingError.Context(codingPath: decoder.codingPath, debugDescription: "Wrong type for ChatMember"))
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.singleValueContainer()
            switch self {
                case .chatMemberOwner(let value):
                    try container.encode(value)
                case .chatMemberAdministrator(let value):
                    try container.encode(value)
                case .chatMemberMember(let value):
                    try container.encode(value)
                case .chatMemberRestricted(let value):
                    try container.encode(value)
                case .chatMemberLeft(let value):
                    try container.encode(value)
                case .chatMemberBanned(let value):
                    try container.encode(value)
            }
        }
    }
}

extension TelegramAPI {
    /**
     * https://core.telegram.org/bots/api#chatmemberowner  
     * Represents a chat member that owns the chat and has all administrator privileges.
    */
    public struct ChatMemberOwner: Codable {
        /** String | The member's status in the chat, always "creator" */
        public let status: String
        /** User | Information about the user */
        public let user: User
        /** Boolean | True, if the user's presence in the chat is hidden */
        public let is_anonymous: Bool
        /** String | Optional. Custom title for this user */
        public let custom_title: String?
        public init(status: String ,user: User ,is_anonymous: Bool ,custom_title: String? = nil) {
            self.status = status
            self.user = user
            self.is_anonymous = is_anonymous
            self.custom_title = custom_title
        }
    }
}

extension TelegramAPI {
    /**
     * https://core.telegram.org/bots/api#chatmemberadministrator  
     * Represents a chat member that has some additional privileges.
    */
    public struct ChatMemberAdministrator: Codable {
        /** String | The member's status in the chat, always "administrator" */
        public let status: String
        /** User | Information about the user */
        public let user: User
        /** Boolean | True, if the bot is allowed to edit administrator privileges of that user */
        public let can_be_edited: Bool
        /** Boolean | True, if the user's presence in the chat is hidden */
        public let is_anonymous: Bool
        /** Boolean | True, if the administrator can access the chat event log, get boost list, see hidden supergroup and channel members, report spam messages and ignore slow mode. Implied by any other administrator privilege. */
        public let can_manage_chat: Bool
        /** Boolean | True, if the administrator can delete messages of other users */
        public let can_delete_messages: Bool
        /** Boolean | True, if the administrator can manage video chats */
        public let can_manage_video_chats: Bool
        /** Boolean | True, if the administrator can restrict, ban or unban chat members, or access supergroup statistics */
        public let can_restrict_members: Bool
        /** Boolean | True, if the administrator can add new administrators with a subset of their own privileges or demote administrators that they have promoted, directly or indirectly (promoted by administrators that were appointed by the user) */
        public let can_promote_members: Bool
        /** Boolean | True, if the user is allowed to change the chat title, photo and other settings */
        public let can_change_info: Bool
        /** Boolean | True, if the user is allowed to invite new users to the chat */
        public let can_invite_users: Bool
        /** Boolean | True, if the administrator can post stories to the chat */
        public let can_post_stories: Bool
        /** Boolean | True, if the administrator can edit stories posted by other users, post stories to the chat page, pin chat stories, and access the chat's story archive */
        public let can_edit_stories: Bool
        /** Boolean | True, if the administrator can delete stories posted by other users */
        public let can_delete_stories: Bool
        /** Boolean | Optional. True, if the administrator can post messages in the channel, or access channel statistics; for channels only */
        public let can_post_messages: Bool?
        /** Boolean | Optional. True, if the administrator can edit messages of other users and can pin messages; for channels only */
        public let can_edit_messages: Bool?
        /** Boolean | Optional. True, if the user is allowed to pin messages; for groups and supergroups only */
        public let can_pin_messages: Bool?
        /** Boolean | Optional. True, if the user is allowed to create, rename, close, and reopen forum topics; for supergroups only */
        public let can_manage_topics: Bool?
        /** String | Optional. Custom title for this user */
        public let custom_title: String?
        public init(status: String ,user: User ,can_be_edited: Bool ,is_anonymous: Bool ,can_manage_chat: Bool ,can_delete_messages: Bool ,can_manage_video_chats: Bool ,can_restrict_members: Bool ,can_promote_members: Bool ,can_change_info: Bool ,can_invite_users: Bool ,can_post_stories: Bool ,can_edit_stories: Bool ,can_delete_stories: Bool ,can_post_messages: Bool? = nil ,can_edit_messages: Bool? = nil ,can_pin_messages: Bool? = nil ,can_manage_topics: Bool? = nil ,custom_title: String? = nil) {
            self.status = status
            self.user = user
            self.can_be_edited = can_be_edited
            self.is_anonymous = is_anonymous
            self.can_manage_chat = can_manage_chat
            self.can_delete_messages = can_delete_messages
            self.can_manage_video_chats = can_manage_video_chats
            self.can_restrict_members = can_restrict_members
            self.can_promote_members = can_promote_members
            self.can_change_info = can_change_info
            self.can_invite_users = can_invite_users
            self.can_post_stories = can_post_stories
            self.can_edit_stories = can_edit_stories
            self.can_delete_stories = can_delete_stories
            self.can_post_messages = can_post_messages
            self.can_edit_messages = can_edit_messages
            self.can_pin_messages = can_pin_messages
            self.can_manage_topics = can_manage_topics
            self.custom_title = custom_title
        }
    }
}

extension TelegramAPI {
    /**
     * https://core.telegram.org/bots/api#chatmembermember  
     * Represents a chat member that has no additional privileges or restrictions.
    */
    public struct ChatMemberMember: Codable {
        /** String | The member's status in the chat, always "member" */
        public let status: String
        /** User | Information about the user */
        public let user: User
        /** Integer | Optional. Date when the user's subscription will expire; Unix time */
        public let until_date: Int?
        public init(status: String ,user: User ,until_date: Int? = nil) {
            self.status = status
            self.user = user
            self.until_date = until_date
        }
    }
}

extension TelegramAPI {
    /**
     * https://core.telegram.org/bots/api#chatmemberrestricted  
     * Represents a chat member that is under certain restrictions in the chat. Supergroups only.
    */
    public struct ChatMemberRestricted: Codable {
        /** String | The member's status in the chat, always "restricted" */
        public let status: String
        /** User | Information about the user */
        public let user: User
        /** Boolean | True, if the user is a member of the chat at the moment of the request */
        public let is_member: Bool
        /** Boolean | True, if the user is allowed to send text messages, contacts, giveaways, giveaway winners, invoices, locations and venues */
        public let can_send_messages: Bool
        /** Boolean | True, if the user is allowed to send audios */
        public let can_send_audios: Bool
        /** Boolean | True, if the user is allowed to send documents */
        public let can_send_documents: Bool
        /** Boolean | True, if the user is allowed to send photos */
        public let can_send_photos: Bool
        /** Boolean | True, if the user is allowed to send videos */
        public let can_send_videos: Bool
        /** Boolean | True, if the user is allowed to send video notes */
        public let can_send_video_notes: Bool
        /** Boolean | True, if the user is allowed to send voice notes */
        public let can_send_voice_notes: Bool
        /** Boolean | True, if the user is allowed to send polls */
        public let can_send_polls: Bool
        /** Boolean | True, if the user is allowed to send animations, games, stickers and use inline bots */
        public let can_send_other_messages: Bool
        /** Boolean | True, if the user is allowed to add web page previews to their messages */
        public let can_add_web_page_previews: Bool
        /** Boolean | True, if the user is allowed to change the chat title, photo and other settings */
        public let can_change_info: Bool
        /** Boolean | True, if the user is allowed to invite new users to the chat */
        public let can_invite_users: Bool
        /** Boolean | True, if the user is allowed to pin messages */
        public let can_pin_messages: Bool
        /** Boolean | True, if the user is allowed to create forum topics */
        public let can_manage_topics: Bool
        /** Integer | Date when restrictions will be lifted for this user; Unix time. If 0, then the user is restricted forever */
        public let until_date: Int
        public init(status: String ,user: User ,is_member: Bool ,can_send_messages: Bool ,can_send_audios: Bool ,can_send_documents: Bool ,can_send_photos: Bool ,can_send_videos: Bool ,can_send_video_notes: Bool ,can_send_voice_notes: Bool ,can_send_polls: Bool ,can_send_other_messages: Bool ,can_add_web_page_previews: Bool ,can_change_info: Bool ,can_invite_users: Bool ,can_pin_messages: Bool ,can_manage_topics: Bool ,until_date: Int) {
            self.status = status
            self.user = user
            self.is_member = is_member
            self.can_send_messages = can_send_messages
            self.can_send_audios = can_send_audios
            self.can_send_documents = can_send_documents
            self.can_send_photos = can_send_photos
            self.can_send_videos = can_send_videos
            self.can_send_video_notes = can_send_video_notes
            self.can_send_voice_notes = can_send_voice_notes
            self.can_send_polls = can_send_polls
            self.can_send_other_messages = can_send_other_messages
            self.can_add_web_page_previews = can_add_web_page_previews
            self.can_change_info = can_change_info
            self.can_invite_users = can_invite_users
            self.can_pin_messages = can_pin_messages
            self.can_manage_topics = can_manage_topics
            self.until_date = until_date
        }
    }
}

extension TelegramAPI {
    /**
     * https://core.telegram.org/bots/api#chatmemberleft  
     * Represents a chat member that isn't currently a member of the chat, but may join it themselves.
    */
    public struct ChatMemberLeft: Codable {
        /** String | The member's status in the chat, always "left" */
        public let status: String
        /** User | Information about the user */
        public let user: User
        public init(status: String ,user: User) {
            self.status = status
            self.user = user
        }
    }
}

extension TelegramAPI {
    /**
     * https://core.telegram.org/bots/api#chatmemberbanned  
     * Represents a chat member that was banned in the chat and can't return to the chat or view chat messages.
    */
    public struct ChatMemberBanned: Codable {
        /** String | The member's status in the chat, always "kicked" */
        public let status: String
        /** User | Information about the user */
        public let user: User
        /** Integer | Date when restrictions will be lifted for this user; Unix time. If 0, then the user is banned forever */
        public let until_date: Int
        public init(status: String ,user: User ,until_date: Int) {
            self.status = status
            self.user = user
            self.until_date = until_date
        }
    }
}

extension TelegramAPI {
    /**
     * https://core.telegram.org/bots/api#chatjoinrequest  
     * Represents a join request sent to a chat.
    */
    public struct ChatJoinRequest: Codable {
        /** Chat | Chat to which the request was sent */
        public let chat: Chat
        /** User | User that sent the join request */
        public let from: User
        /** Integer | Identifier of a private chat with the user who sent the join request. This number may have more than 32 significant bits and some programming languages may have difficulty/silent defects in interpreting it. But it has at most 52 significant bits, so a 64-bit integer or double-precision float type are safe for storing this identifier. The bot can use this identifier for 5 minutes to send messages until the join request is processed, assuming no other administrator contacted the user. */
        public let user_chat_id: Int
        /** Integer | Date the request was sent in Unix time */
        public let date: Int
        /** String | Optional. Bio of the user. */
        public let bio: String?
        /** ChatInviteLink | Optional. Chat invite link that was used by the user to send the join request */
        public let invite_link: ChatInviteLink?
        public init(chat: Chat ,from: User ,user_chat_id: Int ,date: Int ,bio: String? = nil ,invite_link: ChatInviteLink? = nil) {
            self.chat = chat
            self.from = from
            self.user_chat_id = user_chat_id
            self.date = date
            self.bio = bio
            self.invite_link = invite_link
        }
    }
}

extension TelegramAPI {
    /**
     * https://core.telegram.org/bots/api#chatpermissions  
     * Describes actions that a non-administrator user is allowed to take in a chat.
    */
    public struct ChatPermissions: Codable {
        /** Boolean | Optional. True, if the user is allowed to send text messages, contacts, giveaways, giveaway winners, invoices, locations and venues */
        public let can_send_messages: Bool?
        /** Boolean | Optional. True, if the user is allowed to send audios */
        public let can_send_audios: Bool?
        /** Boolean | Optional. True, if the user is allowed to send documents */
        public let can_send_documents: Bool?
        /** Boolean | Optional. True, if the user is allowed to send photos */
        public let can_send_photos: Bool?
        /** Boolean | Optional. True, if the user is allowed to send videos */
        public let can_send_videos: Bool?
        /** Boolean | Optional. True, if the user is allowed to send video notes */
        public let can_send_video_notes: Bool?
        /** Boolean | Optional. True, if the user is allowed to send voice notes */
        public let can_send_voice_notes: Bool?
        /** Boolean | Optional. True, if the user is allowed to send polls */
        public let can_send_polls: Bool?
        /** Boolean | Optional. True, if the user is allowed to send animations, games, stickers and use inline bots */
        public let can_send_other_messages: Bool?
        /** Boolean | Optional. True, if the user is allowed to add web page previews to their messages */
        public let can_add_web_page_previews: Bool?
        /** Boolean | Optional. True, if the user is allowed to change the chat title, photo and other settings. Ignored in public supergroups */
        public let can_change_info: Bool?
        /** Boolean | Optional. True, if the user is allowed to invite new users to the chat */
        public let can_invite_users: Bool?
        /** Boolean | Optional. True, if the user is allowed to pin messages. Ignored in public supergroups */
        public let can_pin_messages: Bool?
        /** Boolean | Optional. True, if the user is allowed to create forum topics. If omitted defaults to the value of can_pin_messages */
        public let can_manage_topics: Bool?
        public init(can_send_messages: Bool? = nil ,can_send_audios: Bool? = nil ,can_send_documents: Bool? = nil ,can_send_photos: Bool? = nil ,can_send_videos: Bool? = nil ,can_send_video_notes: Bool? = nil ,can_send_voice_notes: Bool? = nil ,can_send_polls: Bool? = nil ,can_send_other_messages: Bool? = nil ,can_add_web_page_previews: Bool? = nil ,can_change_info: Bool? = nil ,can_invite_users: Bool? = nil ,can_pin_messages: Bool? = nil ,can_manage_topics: Bool? = nil) {
            self.can_send_messages = can_send_messages
            self.can_send_audios = can_send_audios
            self.can_send_documents = can_send_documents
            self.can_send_photos = can_send_photos
            self.can_send_videos = can_send_videos
            self.can_send_video_notes = can_send_video_notes
            self.can_send_voice_notes = can_send_voice_notes
            self.can_send_polls = can_send_polls
            self.can_send_other_messages = can_send_other_messages
            self.can_add_web_page_previews = can_add_web_page_previews
            self.can_change_info = can_change_info
            self.can_invite_users = can_invite_users
            self.can_pin_messages = can_pin_messages
            self.can_manage_topics = can_manage_topics
        }
    }
}

extension TelegramAPI {
    /**
     * https://core.telegram.org/bots/api#birthdate  
     * Describes the birthdate of a user.
    */
    public struct Birthdate: Codable {
        /** Integer | Day of the user's birth; 1-31 */
        public let day: Int
        /** Integer | Month of the user's birth; 1-12 */
        public let month: Int
        /** Integer | Optional. Year of the user's birth */
        public let year: Int?
        public init(day: Int ,month: Int ,year: Int? = nil) {
            self.day = day
            self.month = month
            self.year = year
        }
    }
}

extension TelegramAPI {
    /**
     * https://core.telegram.org/bots/api#businessintro  
     * Contains information about the start page settings of a Telegram Business account.
    */
    public struct BusinessIntro: Codable {
        /** String | Optional. Title text of the business intro */
        public let title: String?
        /** String | Optional. Message text of the business intro */
        public let message: String?
        /** Sticker | Optional. Sticker of the business intro */
        public let sticker: Sticker?
        public init(title: String? = nil ,message: String? = nil ,sticker: Sticker? = nil) {
            self.title = title
            self.message = message
            self.sticker = sticker
        }
    }
}

extension TelegramAPI {
    /**
     * https://core.telegram.org/bots/api#businesslocation  
     * Contains information about the location of a Telegram Business account.
    */
    public struct BusinessLocation: Codable {
        /** String | Address of the business */
        public let address: String
        /** Location | Optional. Location of the business */
        public let location: Location?
        public init(address: String ,location: Location? = nil) {
            self.address = address
            self.location = location
        }
    }
}

extension TelegramAPI {
    /**
     * https://core.telegram.org/bots/api#businessopeninghoursinterval  
     * Describes an interval of time during which a business is open.
    */
    public struct BusinessOpeningHoursInterval: Codable {
        /** Integer | The minute's sequence number in a week, starting on Monday, marking the start of the time interval during which the business is open; 0 - 7 * 24 * 60 */
        public let opening_minute: Int
        /** Integer | The minute's sequence number in a week, starting on Monday, marking the end of the time interval during which the business is open; 0 - 8 * 24 * 60 */
        public let closing_minute: Int
        public init(opening_minute: Int ,closing_minute: Int) {
            self.opening_minute = opening_minute
            self.closing_minute = closing_minute
        }
    }
}

extension TelegramAPI {
    /**
     * https://core.telegram.org/bots/api#businessopeninghours  
     * Describes the opening hours of a business.
    */
    public struct BusinessOpeningHours: Codable {
        /** String | Unique name of the time zone for which the opening hours are defined */
        public let time_zone_name: String
        /** Array of BusinessOpeningHoursInterval | List of time intervals describing business opening hours */
        public let opening_hours: Array<BusinessOpeningHoursInterval>
        public init(time_zone_name: String ,opening_hours: Array<BusinessOpeningHoursInterval>) {
            self.time_zone_name = time_zone_name
            self.opening_hours = opening_hours
        }
    }
}

extension TelegramAPI {
    /**
     * https://core.telegram.org/bots/api#chatlocation  
     * Represents a location to which a chat is connected.
    */
    public struct ChatLocation: Codable {
        /** Location | The location to which the supergroup is connected. Can't be a live location. */
        public let location: Location
        /** String | Location address; 1-64 characters, as defined by the chat owner */
        public let address: String
        public init(location: Location ,address: String) {
            self.location = location
            self.address = address
        }
    }
}

extension TelegramAPI {
    /**
     * https://core.telegram.org/bots/api#reactiontype  
     * This object describes the type of a reaction. Currently, it can be one of
     * - ReactionTypeEmoji
     * - ReactionTypeCustomEmoji
     * - ReactionTypePaid
    */
    public indirect enum ReactionType: Codable {
        case reactionTypeEmoji(ReactionTypeEmoji)
        case reactionTypeCustomEmoji(ReactionTypeCustomEmoji)
        case reactionTypePaid(ReactionTypePaid)

        public init(from decoder: Decoder) throws {
            let container = try decoder.singleValueContainer()
            if let value = try? container.decode(ReactionTypeEmoji.self) {
                self = .reactionTypeEmoji(value)
            }
            else if let value = try? container.decode(ReactionTypeCustomEmoji.self) {
                self = .reactionTypeCustomEmoji(value)
            }
            else if let value = try? container.decode(ReactionTypePaid.self) {
                self = .reactionTypePaid(value)
            }else {
                throw DecodingError.typeMismatch(ReactionType.self, DecodingError.Context(codingPath: decoder.codingPath, debugDescription: "Wrong type for ReactionType"))
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.singleValueContainer()
            switch self {
                case .reactionTypeEmoji(let value):
                    try container.encode(value)
                case .reactionTypeCustomEmoji(let value):
                    try container.encode(value)
                case .reactionTypePaid(let value):
                    try container.encode(value)
            }
        }
    }
}

extension TelegramAPI {
    /**
     * https://core.telegram.org/bots/api#reactiontypeemoji  
     * The reaction is based on an emoji.
    */
    public struct ReactionTypeEmoji: Codable {
        /** String | Type of the reaction, always "emoji" */
        public let type: String
        /** String | Reaction emoji. Currently, it can be one of "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "" */
        public let emoji: String
        public init(type: String ,emoji: String) {
            self.type = type
            self.emoji = emoji
        }
    }
}

extension TelegramAPI {
    /**
     * https://core.telegram.org/bots/api#reactiontypecustomemoji  
     * The reaction is based on a custom emoji.
    */
    public struct ReactionTypeCustomEmoji: Codable {
        /** String | Type of the reaction, always "custom_emoji" */
        public let type: String
        /** String | Custom emoji identifier */
        public let custom_emoji_id: String
        public init(type: String ,custom_emoji_id: String) {
            self.type = type
            self.custom_emoji_id = custom_emoji_id
        }
    }
}

extension TelegramAPI {
    /**
     * https://core.telegram.org/bots/api#reactiontypepaid  
     * The reaction is paid.
    */
    public struct ReactionTypePaid: Codable {
        /** String | Type of the reaction, always "paid" */
        public let type: String
        public init(type: String) {
            self.type = type
        }
    }
}

extension TelegramAPI {
    /**
     * https://core.telegram.org/bots/api#reactioncount  
     * Represents a reaction added to a message along with the number of times it was added.
    */
    public struct ReactionCount: Codable {
        /** ReactionType | Type of the reaction */
        public let type: ReactionType
        /** Integer | Number of times the reaction was added */
        public let total_count: Int
        public init(type: ReactionType ,total_count: Int) {
            self.type = type
            self.total_count = total_count
        }
    }
}

extension TelegramAPI {
    /**
     * https://core.telegram.org/bots/api#messagereactionupdated  
     * This object represents a change of a reaction on a message performed by a user.
    */
    public struct MessageReactionUpdated: Codable {
        /** Chat | The chat containing the message the user reacted to */
        public let chat: Chat
        /** Integer | Unique identifier of the message inside the chat */
        public let message_id: Int
        /** User | Optional. The user that changed the reaction, if the user isn't anonymous */
        public let user: User?
        /** Chat | Optional. The chat on behalf of which the reaction was changed, if the user is anonymous */
        public let actor_chat: Chat?
        /** Integer | Date of the change in Unix time */
        public let date: Int
        /** Array of ReactionType | Previous list of reaction types that were set by the user */
        public let old_reaction: Array<ReactionType>
        /** Array of ReactionType | New list of reaction types that have been set by the user */
        public let new_reaction: Array<ReactionType>
        public init(chat: Chat ,message_id: Int ,user: User? = nil ,actor_chat: Chat? = nil ,date: Int ,old_reaction: Array<ReactionType> ,new_reaction: Array<ReactionType>) {
            self.chat = chat
            self.message_id = message_id
            self.user = user
            self.actor_chat = actor_chat
            self.date = date
            self.old_reaction = old_reaction
            self.new_reaction = new_reaction
        }
    }
}

extension TelegramAPI {
    /**
     * https://core.telegram.org/bots/api#messagereactioncountupdated  
     * This object represents reaction changes on a message with anonymous reactions.
    */
    public struct MessageReactionCountUpdated: Codable {
        /** Chat | The chat containing the message */
        public let chat: Chat
        /** Integer | Unique message identifier inside the chat */
        public let message_id: Int
        /** Integer | Date of the change in Unix time */
        public let date: Int
        /** Array of ReactionCount | List of reactions that are present on the message */
        public let reactions: Array<ReactionCount>
        public init(chat: Chat ,message_id: Int ,date: Int ,reactions: Array<ReactionCount>) {
            self.chat = chat
            self.message_id = message_id
            self.date = date
            self.reactions = reactions
        }
    }
}

extension TelegramAPI {
    /**
     * https://core.telegram.org/bots/api#forumtopic  
     * This object represents a forum topic.
    */
    public struct ForumTopic: Codable {
        /** Integer | Unique identifier of the forum topic */
        public let message_thread_id: Int
        /** String | Name of the topic */
        public let name: String
        /** Integer | Color of the topic icon in RGB format */
        public let icon_color: Int
        /** String | Optional. Unique identifier of the custom emoji shown as the topic icon */
        public let icon_custom_emoji_id: String?
        public init(message_thread_id: Int ,name: String ,icon_color: Int ,icon_custom_emoji_id: String? = nil) {
            self.message_thread_id = message_thread_id
            self.name = name
            self.icon_color = icon_color
            self.icon_custom_emoji_id = icon_custom_emoji_id
        }
    }
}

extension TelegramAPI {
    /**
     * https://core.telegram.org/bots/api#botcommand  
     * This object represents a bot command.
    */
    public struct BotCommand: Codable {
        /** String | Text of the command; 1-32 characters. Can contain only lowercase English letters, digits and underscores. */
        public let command: String
        /** String | Description of the command; 1-256 characters. */
        public let description: String
        public init(command: String ,description: String) {
            self.command = command
            self.description = description
        }
    }
}

extension TelegramAPI {
    /**
     * https://core.telegram.org/bots/api#botcommandscope  
     * This object represents the scope to which bot commands are applied. Currently, the following 7 scopes are supported:
     * - BotCommandScopeDefault
     * - BotCommandScopeAllPrivateChats
     * - BotCommandScopeAllGroupChats
     * - BotCommandScopeAllChatAdministrators
     * - BotCommandScopeChat
     * - BotCommandScopeChatAdministrators
     * - BotCommandScopeChatMember
    */
    public indirect enum BotCommandScope: Codable {
        case botCommandScopeDefault(BotCommandScopeDefault)
        case botCommandScopeAllPrivateChats(BotCommandScopeAllPrivateChats)
        case botCommandScopeAllGroupChats(BotCommandScopeAllGroupChats)
        case botCommandScopeAllChatAdministrators(BotCommandScopeAllChatAdministrators)
        case botCommandScopeChat(BotCommandScopeChat)
        case botCommandScopeChatAdministrators(BotCommandScopeChatAdministrators)
        case botCommandScopeChatMember(BotCommandScopeChatMember)

        public init(from decoder: Decoder) throws {
            let container = try decoder.singleValueContainer()
            if let value = try? container.decode(BotCommandScopeDefault.self) {
                self = .botCommandScopeDefault(value)
            }
            else if let value = try? container.decode(BotCommandScopeAllPrivateChats.self) {
                self = .botCommandScopeAllPrivateChats(value)
            }
            else if let value = try? container.decode(BotCommandScopeAllGroupChats.self) {
                self = .botCommandScopeAllGroupChats(value)
            }
            else if let value = try? container.decode(BotCommandScopeAllChatAdministrators.self) {
                self = .botCommandScopeAllChatAdministrators(value)
            }
            else if let value = try? container.decode(BotCommandScopeChat.self) {
                self = .botCommandScopeChat(value)
            }
            else if let value = try? container.decode(BotCommandScopeChatAdministrators.self) {
                self = .botCommandScopeChatAdministrators(value)
            }
            else if let value = try? container.decode(BotCommandScopeChatMember.self) {
                self = .botCommandScopeChatMember(value)
            }else {
                throw DecodingError.typeMismatch(BotCommandScope.self, DecodingError.Context(codingPath: decoder.codingPath, debugDescription: "Wrong type for BotCommandScope"))
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.singleValueContainer()
            switch self {
                case .botCommandScopeDefault(let value):
                    try container.encode(value)
                case .botCommandScopeAllPrivateChats(let value):
                    try container.encode(value)
                case .botCommandScopeAllGroupChats(let value):
                    try container.encode(value)
                case .botCommandScopeAllChatAdministrators(let value):
                    try container.encode(value)
                case .botCommandScopeChat(let value):
                    try container.encode(value)
                case .botCommandScopeChatAdministrators(let value):
                    try container.encode(value)
                case .botCommandScopeChatMember(let value):
                    try container.encode(value)
            }
        }
    }
}

extension TelegramAPI {
    /**
     * https://core.telegram.org/bots/api#botcommandscopedefault  
     * Represents the default scope of bot commands. Default commands are used if no commands with a narrower scope are specified for the user.
    */
    public struct BotCommandScopeDefault: Codable {
        /** String | Scope type, must be default */
        public let type: String
        public init(type: String) {
            self.type = type
        }
    }
}

extension TelegramAPI {
    /**
     * https://core.telegram.org/bots/api#botcommandscopeallprivatechats  
     * Represents the scope of bot commands, covering all private chats.
    */
    public struct BotCommandScopeAllPrivateChats: Codable {
        /** String | Scope type, must be all_private_chats */
        public let type: String
        public init(type: String) {
            self.type = type
        }
    }
}

extension TelegramAPI {
    /**
     * https://core.telegram.org/bots/api#botcommandscopeallgroupchats  
     * Represents the scope of bot commands, covering all group and supergroup chats.
    */
    public struct BotCommandScopeAllGroupChats: Codable {
        /** String | Scope type, must be all_group_chats */
        public let type: String
        public init(type: String) {
            self.type = type
        }
    }
}

extension TelegramAPI {
    /**
     * https://core.telegram.org/bots/api#botcommandscopeallchatadministrators  
     * Represents the scope of bot commands, covering all group and supergroup chat administrators.
    */
    public struct BotCommandScopeAllChatAdministrators: Codable {
        /** String | Scope type, must be all_chat_administrators */
        public let type: String
        public init(type: String) {
            self.type = type
        }
    }
}

extension TelegramAPI {
    /**
     * https://core.telegram.org/bots/api#botcommandscopechat  
     * Represents the scope of bot commands, covering a specific chat.
    */
    public struct BotCommandScopeChat: Codable {
        /** String | Scope type, must be chat */
        public let type: String
        /** Integer or String | Unique identifier for the target chat or username of the target supergroup (in the format @supergroupusername) */
        public let chat_id: Either2<Int, String>
        public init(type: String ,chat_id: Either2<Int, String>) {
            self.type = type
            self.chat_id = chat_id
        }
    }
}

extension TelegramAPI {
    /**
     * https://core.telegram.org/bots/api#botcommandscopechatadministrators  
     * Represents the scope of bot commands, covering all administrators of a specific group or supergroup chat.
    */
    public struct BotCommandScopeChatAdministrators: Codable {
        /** String | Scope type, must be chat_administrators */
        public let type: String
        /** Integer or String | Unique identifier for the target chat or username of the target supergroup (in the format @supergroupusername) */
        public let chat_id: Either2<Int, String>
        public init(type: String ,chat_id: Either2<Int, String>) {
            self.type = type
            self.chat_id = chat_id
        }
    }
}

extension TelegramAPI {
    /**
     * https://core.telegram.org/bots/api#botcommandscopechatmember  
     * Represents the scope of bot commands, covering a specific member of a group or supergroup chat.
    */
    public struct BotCommandScopeChatMember: Codable {
        /** String | Scope type, must be chat_member */
        public let type: String
        /** Integer or String | Unique identifier for the target chat or username of the target supergroup (in the format @supergroupusername) */
        public let chat_id: Either2<Int, String>
        /** Integer | Unique identifier of the target user */
        public let user_id: Int
        public init(type: String ,chat_id: Either2<Int, String> ,user_id: Int) {
            self.type = type
            self.chat_id = chat_id
            self.user_id = user_id
        }
    }
}

extension TelegramAPI {
    /**
     * https://core.telegram.org/bots/api#botname  
     * This object represents the bot's name.
    */
    public struct BotName: Codable {
        /** String | The bot's name */
        public let name: String
        public init(name: String) {
            self.name = name
        }
    }
}

extension TelegramAPI {
    /**
     * https://core.telegram.org/bots/api#botdescription  
     * This object represents the bot's description.
    */
    public struct BotDescription: Codable {
        /** String | The bot's description */
        public let description: String
        public init(description: String) {
            self.description = description
        }
    }
}

extension TelegramAPI {
    /**
     * https://core.telegram.org/bots/api#botshortdescription  
     * This object represents the bot's short description.
    */
    public struct BotShortDescription: Codable {
        /** String | The bot's short description */
        public let short_description: String
        public init(short_description: String) {
            self.short_description = short_description
        }
    }
}

extension TelegramAPI {
    /**
     * https://core.telegram.org/bots/api#menubutton  
     * This object describes the bot's menu button in a private chat. It should be one of
     * - MenuButtonCommands
     * - MenuButtonWebApp
     * - MenuButtonDefault
     * If a menu button other than MenuButtonDefault is set for a private chat, then it is applied in the chat. Otherwise the default menu button is applied. By default, the menu button opens the list of bot commands.
    */
    public indirect enum MenuButton: Codable {
        case menuButtonCommands(MenuButtonCommands)
        case menuButtonWebApp(MenuButtonWebApp)
        case menuButtonDefault(MenuButtonDefault)

        public init(from decoder: Decoder) throws {
            let container = try decoder.singleValueContainer()
            if let value = try? container.decode(MenuButtonCommands.self) {
                self = .menuButtonCommands(value)
            }
            else if let value = try? container.decode(MenuButtonWebApp.self) {
                self = .menuButtonWebApp(value)
            }
            else if let value = try? container.decode(MenuButtonDefault.self) {
                self = .menuButtonDefault(value)
            }else {
                throw DecodingError.typeMismatch(MenuButton.self, DecodingError.Context(codingPath: decoder.codingPath, debugDescription: "Wrong type for MenuButton"))
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.singleValueContainer()
            switch self {
                case .menuButtonCommands(let value):
                    try container.encode(value)
                case .menuButtonWebApp(let value):
                    try container.encode(value)
                case .menuButtonDefault(let value):
                    try container.encode(value)
            }
        }
    }
}

extension TelegramAPI {
    /**
     * https://core.telegram.org/bots/api#menubuttoncommands  
     * Represents a menu button, which opens the bot's list of commands.
    */
    public struct MenuButtonCommands: Codable {
        /** String | Type of the button, must be commands */
        public let type: String
        public init(type: String) {
            self.type = type
        }
    }
}

extension TelegramAPI {
    /**
     * https://core.telegram.org/bots/api#menubuttonwebapp  
     * Represents a menu button, which launches a Web App.
    */
    public struct MenuButtonWebApp: Codable {
        /** String | Type of the button, must be web_app */
        public let type: String
        /** String | Text on the button */
        public let text: String
        /** WebAppInfo | Description of the Web App that will be launched when the user presses the button. The Web App will be able to send an arbitrary message on behalf of the user using the method answerWebAppQuery. Alternatively, a t.me link to a Web App of the bot can be specified in the object instead of the Web App's URL, in which case the Web App will be opened as if the user pressed the link. */
        public let web_app: WebAppInfo
        public init(type: String ,text: String ,web_app: WebAppInfo) {
            self.type = type
            self.text = text
            self.web_app = web_app
        }
    }
}

extension TelegramAPI {
    /**
     * https://core.telegram.org/bots/api#menubuttondefault  
     * Describes that no specific value for the menu button was set.
    */
    public struct MenuButtonDefault: Codable {
        /** String | Type of the button, must be default */
        public let type: String
        public init(type: String) {
            self.type = type
        }
    }
}

extension TelegramAPI {
    /**
     * https://core.telegram.org/bots/api#chatboostsource  
     * This object describes the source of a chat boost. It can be one of
     * - ChatBoostSourcePremium
     * - ChatBoostSourceGiftCode
     * - ChatBoostSourceGiveaway
    */
    public indirect enum ChatBoostSource: Codable {
        case chatBoostSourcePremium(ChatBoostSourcePremium)
        case chatBoostSourceGiftCode(ChatBoostSourceGiftCode)
        case chatBoostSourceGiveaway(ChatBoostSourceGiveaway)

        public init(from decoder: Decoder) throws {
            let container = try decoder.singleValueContainer()
            if let value = try? container.decode(ChatBoostSourcePremium.self) {
                self = .chatBoostSourcePremium(value)
            }
            else if let value = try? container.decode(ChatBoostSourceGiftCode.self) {
                self = .chatBoostSourceGiftCode(value)
            }
            else if let value = try? container.decode(ChatBoostSourceGiveaway.self) {
                self = .chatBoostSourceGiveaway(value)
            }else {
                throw DecodingError.typeMismatch(ChatBoostSource.self, DecodingError.Context(codingPath: decoder.codingPath, debugDescription: "Wrong type for ChatBoostSource"))
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.singleValueContainer()
            switch self {
                case .chatBoostSourcePremium(let value):
                    try container.encode(value)
                case .chatBoostSourceGiftCode(let value):
                    try container.encode(value)
                case .chatBoostSourceGiveaway(let value):
                    try container.encode(value)
            }
        }
    }
}

extension TelegramAPI {
    /**
     * https://core.telegram.org/bots/api#chatboostsourcepremium  
     * The boost was obtained by subscribing to Telegram Premium or by gifting a Telegram Premium subscription to another user.
    */
    public struct ChatBoostSourcePremium: Codable {
        /** String | Source of the boost, always "premium" */
        public let source: String
        /** User | User that boosted the chat */
        public let user: User
        public init(source: String ,user: User) {
            self.source = source
            self.user = user
        }
    }
}

extension TelegramAPI {
    /**
     * https://core.telegram.org/bots/api#chatboostsourcegiftcode  
     * The boost was obtained by the creation of Telegram Premium gift codes to boost a chat. Each such code boosts the chat 4 times for the duration of the corresponding Telegram Premium subscription.
    */
    public struct ChatBoostSourceGiftCode: Codable {
        /** String | Source of the boost, always "gift_code" */
        public let source: String
        /** User | User for which the gift code was created */
        public let user: User
        public init(source: String ,user: User) {
            self.source = source
            self.user = user
        }
    }
}

extension TelegramAPI {
    /**
     * https://core.telegram.org/bots/api#chatboostsourcegiveaway  
     * The boost was obtained by the creation of a Telegram Premium or a Telegram Star giveaway. This boosts the chat 4 times for the duration of the corresponding Telegram Premium subscription for Telegram Premium giveaways and prize_star_count / 500 times for one year for Telegram Star giveaways.
    */
    public struct ChatBoostSourceGiveaway: Codable {
        /** String | Source of the boost, always "giveaway" */
        public let source: String
        /** Integer | Identifier of a message in the chat with the giveaway; the message could have been deleted already. May be 0 if the message isn't sent yet. */
        public let giveaway_message_id: Int
        /** User | Optional. User that won the prize in the giveaway if any; for Telegram Premium giveaways only */
        public let user: User?
        /** Integer | Optional. The number of Telegram Stars to be split between giveaway winners; for Telegram Star giveaways only */
        public let prize_star_count: Int?
        /** Boolean | Optional. True, if the giveaway was completed, but there was no user to win the prize */
        public let is_unclaimed: Bool?
        public init(source: String ,giveaway_message_id: Int ,user: User? = nil ,prize_star_count: Int? = nil ,is_unclaimed: Bool? = nil) {
            self.source = source
            self.giveaway_message_id = giveaway_message_id
            self.user = user
            self.prize_star_count = prize_star_count
            self.is_unclaimed = is_unclaimed
        }
    }
}

extension TelegramAPI {
    /**
     * https://core.telegram.org/bots/api#chatboost  
     * This object contains information about a chat boost.
    */
    public struct ChatBoost: Codable {
        /** String | Unique identifier of the boost */
        public let boost_id: String
        /** Integer | Point in time (Unix timestamp) when the chat was boosted */
        public let add_date: Int
        /** Integer | Point in time (Unix timestamp) when the boost will automatically expire, unless the booster's Telegram Premium subscription is prolonged */
        public let expiration_date: Int
        /** ChatBoostSource | Source of the added boost */
        public let source: ChatBoostSource
        public init(boost_id: String ,add_date: Int ,expiration_date: Int ,source: ChatBoostSource) {
            self.boost_id = boost_id
            self.add_date = add_date
            self.expiration_date = expiration_date
            self.source = source
        }
    }
}

extension TelegramAPI {
    /**
     * https://core.telegram.org/bots/api#chatboostupdated  
     * This object represents a boost added to a chat or changed.
    */
    public struct ChatBoostUpdated: Codable {
        /** Chat | Chat which was boosted */
        public let chat: Chat
        /** ChatBoost | Information about the chat boost */
        public let boost: ChatBoost
        public init(chat: Chat ,boost: ChatBoost) {
            self.chat = chat
            self.boost = boost
        }
    }
}

extension TelegramAPI {
    /**
     * https://core.telegram.org/bots/api#chatboostremoved  
     * This object represents a boost removed from a chat.
    */
    public struct ChatBoostRemoved: Codable {
        /** Chat | Chat which was boosted */
        public let chat: Chat
        /** String | Unique identifier of the boost */
        public let boost_id: String
        /** Integer | Point in time (Unix timestamp) when the boost was removed */
        public let remove_date: Int
        /** ChatBoostSource | Source of the removed boost */
        public let source: ChatBoostSource
        public init(chat: Chat ,boost_id: String ,remove_date: Int ,source: ChatBoostSource) {
            self.chat = chat
            self.boost_id = boost_id
            self.remove_date = remove_date
            self.source = source
        }
    }
}

extension TelegramAPI {
    /**
     * https://core.telegram.org/bots/api#userchatboosts  
     * This object represents a list of boosts added to a chat by a user.
    */
    public struct UserChatBoosts: Codable {
        /** Array of ChatBoost | The list of boosts added to the chat by the user */
        public let boosts: Array<ChatBoost>
        public init(boosts: Array<ChatBoost>) {
            self.boosts = boosts
        }
    }
}

extension TelegramAPI {
    /**
     * https://core.telegram.org/bots/api#businessconnection  
     * Describes the connection of the bot with a business account.
    */
    public struct BusinessConnection: Codable {
        /** String | Unique identifier of the business connection */
        public let id: String
        /** User | Business account user that created the business connection */
        public let user: User
        /** Integer | Identifier of a private chat with the user who created the business connection. This number may have more than 32 significant bits and some programming languages may have difficulty/silent defects in interpreting it. But it has at most 52 significant bits, so a 64-bit integer or double-precision float type are safe for storing this identifier. */
        public let user_chat_id: Int
        /** Integer | Date the connection was established in Unix time */
        public let date: Int
        /** Boolean | True, if the bot can act on behalf of the business account in chats that were active in the last 24 hours */
        public let can_reply: Bool
        /** Boolean | True, if the connection is active */
        public let is_enabled: Bool
        public init(id: String ,user: User ,user_chat_id: Int ,date: Int ,can_reply: Bool ,is_enabled: Bool) {
            self.id = id
            self.user = user
            self.user_chat_id = user_chat_id
            self.date = date
            self.can_reply = can_reply
            self.is_enabled = is_enabled
        }
    }
}

extension TelegramAPI {
    /**
     * https://core.telegram.org/bots/api#businessmessagesdeleted  
     * This object is received when messages are deleted from a connected business account.
    */
    public struct BusinessMessagesDeleted: Codable {
        /** String | Unique identifier of the business connection */
        public let business_connection_id: String
        /** Chat | Information about a chat in the business account. The bot may not have access to the chat or the corresponding user. */
        public let chat: Chat
        /** Array of Integer | The list of identifiers of deleted messages in the chat of the business account */
        public let message_ids: Array<Int>
        public init(business_connection_id: String ,chat: Chat ,message_ids: Array<Int>) {
            self.business_connection_id = business_connection_id
            self.chat = chat
            self.message_ids = message_ids
        }
    }
}

extension TelegramAPI {
    /**
     * https://core.telegram.org/bots/api#responseparameters  
     * Describes why a request was unsuccessful.
    */
    public struct ResponseParameters: Codable {
        /** Integer | Optional. The group has been migrated to a supergroup with the specified identifier. This number may have more than 32 significant bits and some programming languages may have difficulty/silent defects in interpreting it. But it has at most 52 significant bits, so a signed 64-bit integer or double-precision float type are safe for storing this identifier. */
        public let migrate_to_chat_id: Int?
        /** Integer | Optional. In case of exceeding flood control, the number of seconds left to wait before the request can be repeated */
        public let retry_after: Int?
        public init(migrate_to_chat_id: Int? = nil ,retry_after: Int? = nil) {
            self.migrate_to_chat_id = migrate_to_chat_id
            self.retry_after = retry_after
        }
    }
}

extension TelegramAPI {
    /**
     * https://core.telegram.org/bots/api#inputmedia  
     * This object represents the content of a media message to be sent. It should be one of
     * - InputMediaAnimation
     * - InputMediaDocument
     * - InputMediaAudio
     * - InputMediaPhoto
     * - InputMediaVideo
    */
    public indirect enum InputMedia: Codable {
        case inputMediaAnimation(InputMediaAnimation)
        case inputMediaDocument(InputMediaDocument)
        case inputMediaAudio(InputMediaAudio)
        case inputMediaPhoto(InputMediaPhoto)
        case inputMediaVideo(InputMediaVideo)

        public init(from decoder: Decoder) throws {
            let container = try decoder.singleValueContainer()
            if let value = try? container.decode(InputMediaAnimation.self) {
                self = .inputMediaAnimation(value)
            }
            else if let value = try? container.decode(InputMediaDocument.self) {
                self = .inputMediaDocument(value)
            }
            else if let value = try? container.decode(InputMediaAudio.self) {
                self = .inputMediaAudio(value)
            }
            else if let value = try? container.decode(InputMediaPhoto.self) {
                self = .inputMediaPhoto(value)
            }
            else if let value = try? container.decode(InputMediaVideo.self) {
                self = .inputMediaVideo(value)
            }else {
                throw DecodingError.typeMismatch(InputMedia.self, DecodingError.Context(codingPath: decoder.codingPath, debugDescription: "Wrong type for InputMedia"))
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.singleValueContainer()
            switch self {
                case .inputMediaAnimation(let value):
                    try container.encode(value)
                case .inputMediaDocument(let value):
                    try container.encode(value)
                case .inputMediaAudio(let value):
                    try container.encode(value)
                case .inputMediaPhoto(let value):
                    try container.encode(value)
                case .inputMediaVideo(let value):
                    try container.encode(value)
            }
        }
    }
}

extension TelegramAPI {
    /**
     * https://core.telegram.org/bots/api#inputmediaphoto  
     * Represents a photo to be sent.
    */
    public struct InputMediaPhoto: Codable {
        /** String | Type of the result, must be photo */
        public let type: String
        /** String | File to send. Pass a file_id to send a file that exists on the Telegram servers (recommended), pass an HTTP URL for Telegram to get a file from the Internet, or pass "attach://<file_attach_name>" to upload a new one using multipart/form-data under <file_attach_name> name. More information on Sending Files: https://core.telegram.org/bots/api#sending-files */
        public let media: String
        /** String | Optional. Caption of the photo to be sent, 0-1024 characters after entities parsing */
        public let caption: String?
        /** String | Optional. Mode for parsing entities in the photo caption. See formatting options for more details. */
        public let parse_mode: String?
        /** Array of MessageEntity | Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode */
        public let caption_entities: Array<MessageEntity>?
        /** Boolean | Optional. Pass True, if the caption must be shown above the message media */
        public let show_caption_above_media: Bool?
        /** Boolean | Optional. Pass True if the photo needs to be covered with a spoiler animation */
        public let has_spoiler: Bool?
        public init(type: String ,media: String ,caption: String? = nil ,parse_mode: String? = nil ,caption_entities: Array<MessageEntity>? = nil ,show_caption_above_media: Bool? = nil ,has_spoiler: Bool? = nil) {
            self.type = type
            self.media = media
            self.caption = caption
            self.parse_mode = parse_mode
            self.caption_entities = caption_entities
            self.show_caption_above_media = show_caption_above_media
            self.has_spoiler = has_spoiler
        }
    }
}

extension TelegramAPI {
    /**
     * https://core.telegram.org/bots/api#inputmediavideo  
     * Represents a video to be sent.
    */
    public struct InputMediaVideo: Codable {
        /** String | Type of the result, must be video */
        public let type: String
        /** String | File to send. Pass a file_id to send a file that exists on the Telegram servers (recommended), pass an HTTP URL for Telegram to get a file from the Internet, or pass "attach://<file_attach_name>" to upload a new one using multipart/form-data under <file_attach_name> name. More information on Sending Files: https://core.telegram.org/bots/api#sending-files */
        public let media: String
        /** InputFile or String | Optional. Thumbnail of the file sent; can be ignored if thumbnail generation for the file is supported server-side. The thumbnail should be in JPEG format and less than 200 kB in size. A thumbnail's width and height should not exceed 320. Ignored if the file is not uploaded using multipart/form-data. Thumbnails can't be reused and can be only uploaded as a new file, so you can pass "attach://<file_attach_name>" if the thumbnail was uploaded using multipart/form-data under <file_attach_name>. More information on Sending Files: https://core.telegram.org/bots/api#sending-files */
        public let thumbnail: Either2<InputFile, String>?
        /** String | Optional. Caption of the video to be sent, 0-1024 characters after entities parsing */
        public let caption: String?
        /** String | Optional. Mode for parsing entities in the video caption. See formatting options for more details. */
        public let parse_mode: String?
        /** Array of MessageEntity | Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode */
        public let caption_entities: Array<MessageEntity>?
        /** Boolean | Optional. Pass True, if the caption must be shown above the message media */
        public let show_caption_above_media: Bool?
        /** Integer | Optional. Video width */
        public let width: Int?
        /** Integer | Optional. Video height */
        public let height: Int?
        /** Integer | Optional. Video duration in seconds */
        public let duration: Int?
        /** Boolean | Optional. Pass True if the uploaded video is suitable for streaming */
        public let supports_streaming: Bool?
        /** Boolean | Optional. Pass True if the video needs to be covered with a spoiler animation */
        public let has_spoiler: Bool?
        public init(type: String ,media: String ,thumbnail: Either2<InputFile, String>? = nil ,caption: String? = nil ,parse_mode: String? = nil ,caption_entities: Array<MessageEntity>? = nil ,show_caption_above_media: Bool? = nil ,width: Int? = nil ,height: Int? = nil ,duration: Int? = nil ,supports_streaming: Bool? = nil ,has_spoiler: Bool? = nil) {
            self.type = type
            self.media = media
            self.thumbnail = thumbnail
            self.caption = caption
            self.parse_mode = parse_mode
            self.caption_entities = caption_entities
            self.show_caption_above_media = show_caption_above_media
            self.width = width
            self.height = height
            self.duration = duration
            self.supports_streaming = supports_streaming
            self.has_spoiler = has_spoiler
        }
    }
}

extension TelegramAPI {
    /**
     * https://core.telegram.org/bots/api#inputmediaanimation  
     * Represents an animation file (GIF or H.264/MPEG-4 AVC video without sound) to be sent.
    */
    public struct InputMediaAnimation: Codable {
        /** String | Type of the result, must be animation */
        public let type: String
        /** String | File to send. Pass a file_id to send a file that exists on the Telegram servers (recommended), pass an HTTP URL for Telegram to get a file from the Internet, or pass "attach://<file_attach_name>" to upload a new one using multipart/form-data under <file_attach_name> name. More information on Sending Files: https://core.telegram.org/bots/api#sending-files */
        public let media: String
        /** InputFile or String | Optional. Thumbnail of the file sent; can be ignored if thumbnail generation for the file is supported server-side. The thumbnail should be in JPEG format and less than 200 kB in size. A thumbnail's width and height should not exceed 320. Ignored if the file is not uploaded using multipart/form-data. Thumbnails can't be reused and can be only uploaded as a new file, so you can pass "attach://<file_attach_name>" if the thumbnail was uploaded using multipart/form-data under <file_attach_name>. More information on Sending Files: https://core.telegram.org/bots/api#sending-files */
        public let thumbnail: Either2<InputFile, String>?
        /** String | Optional. Caption of the animation to be sent, 0-1024 characters after entities parsing */
        public let caption: String?
        /** String | Optional. Mode for parsing entities in the animation caption. See formatting options for more details. */
        public let parse_mode: String?
        /** Array of MessageEntity | Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode */
        public let caption_entities: Array<MessageEntity>?
        /** Boolean | Optional. Pass True, if the caption must be shown above the message media */
        public let show_caption_above_media: Bool?
        /** Integer | Optional. Animation width */
        public let width: Int?
        /** Integer | Optional. Animation height */
        public let height: Int?
        /** Integer | Optional. Animation duration in seconds */
        public let duration: Int?
        /** Boolean | Optional. Pass True if the animation needs to be covered with a spoiler animation */
        public let has_spoiler: Bool?
        public init(type: String ,media: String ,thumbnail: Either2<InputFile, String>? = nil ,caption: String? = nil ,parse_mode: String? = nil ,caption_entities: Array<MessageEntity>? = nil ,show_caption_above_media: Bool? = nil ,width: Int? = nil ,height: Int? = nil ,duration: Int? = nil ,has_spoiler: Bool? = nil) {
            self.type = type
            self.media = media
            self.thumbnail = thumbnail
            self.caption = caption
            self.parse_mode = parse_mode
            self.caption_entities = caption_entities
            self.show_caption_above_media = show_caption_above_media
            self.width = width
            self.height = height
            self.duration = duration
            self.has_spoiler = has_spoiler
        }
    }
}

extension TelegramAPI {
    /**
     * https://core.telegram.org/bots/api#inputmediaaudio  
     * Represents an audio file to be treated as music to be sent.
    */
    public struct InputMediaAudio: Codable {
        /** String | Type of the result, must be audio */
        public let type: String
        /** String | File to send. Pass a file_id to send a file that exists on the Telegram servers (recommended), pass an HTTP URL for Telegram to get a file from the Internet, or pass "attach://<file_attach_name>" to upload a new one using multipart/form-data under <file_attach_name> name. More information on Sending Files: https://core.telegram.org/bots/api#sending-files */
        public let media: String
        /** InputFile or String | Optional. Thumbnail of the file sent; can be ignored if thumbnail generation for the file is supported server-side. The thumbnail should be in JPEG format and less than 200 kB in size. A thumbnail's width and height should not exceed 320. Ignored if the file is not uploaded using multipart/form-data. Thumbnails can't be reused and can be only uploaded as a new file, so you can pass "attach://<file_attach_name>" if the thumbnail was uploaded using multipart/form-data under <file_attach_name>. More information on Sending Files: https://core.telegram.org/bots/api#sending-files */
        public let thumbnail: Either2<InputFile, String>?
        /** String | Optional. Caption of the audio to be sent, 0-1024 characters after entities parsing */
        public let caption: String?
        /** String | Optional. Mode for parsing entities in the audio caption. See formatting options for more details. */
        public let parse_mode: String?
        /** Array of MessageEntity | Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode */
        public let caption_entities: Array<MessageEntity>?
        /** Integer | Optional. Duration of the audio in seconds */
        public let duration: Int?
        /** String | Optional. Performer of the audio */
        public let performer: String?
        /** String | Optional. Title of the audio */
        public let title: String?
        public init(type: String ,media: String ,thumbnail: Either2<InputFile, String>? = nil ,caption: String? = nil ,parse_mode: String? = nil ,caption_entities: Array<MessageEntity>? = nil ,duration: Int? = nil ,performer: String? = nil ,title: String? = nil) {
            self.type = type
            self.media = media
            self.thumbnail = thumbnail
            self.caption = caption
            self.parse_mode = parse_mode
            self.caption_entities = caption_entities
            self.duration = duration
            self.performer = performer
            self.title = title
        }
    }
}

extension TelegramAPI {
    /**
     * https://core.telegram.org/bots/api#inputmediadocument  
     * Represents a general file to be sent.
    */
    public struct InputMediaDocument: Codable {
        /** String | Type of the result, must be document */
        public let type: String
        /** String | File to send. Pass a file_id to send a file that exists on the Telegram servers (recommended), pass an HTTP URL for Telegram to get a file from the Internet, or pass "attach://<file_attach_name>" to upload a new one using multipart/form-data under <file_attach_name> name. More information on Sending Files: https://core.telegram.org/bots/api#sending-files */
        public let media: String
        /** InputFile or String | Optional. Thumbnail of the file sent; can be ignored if thumbnail generation for the file is supported server-side. The thumbnail should be in JPEG format and less than 200 kB in size. A thumbnail's width and height should not exceed 320. Ignored if the file is not uploaded using multipart/form-data. Thumbnails can't be reused and can be only uploaded as a new file, so you can pass "attach://<file_attach_name>" if the thumbnail was uploaded using multipart/form-data under <file_attach_name>. More information on Sending Files: https://core.telegram.org/bots/api#sending-files */
        public let thumbnail: Either2<InputFile, String>?
        /** String | Optional. Caption of the document to be sent, 0-1024 characters after entities parsing */
        public let caption: String?
        /** String | Optional. Mode for parsing entities in the document caption. See formatting options for more details. */
        public let parse_mode: String?
        /** Array of MessageEntity | Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode */
        public let caption_entities: Array<MessageEntity>?
        /** Boolean | Optional. Disables automatic server-side content type detection for files uploaded using multipart/form-data. Always True, if the document is sent as part of an album. */
        public let disable_content_type_detection: Bool?
        public init(type: String ,media: String ,thumbnail: Either2<InputFile, String>? = nil ,caption: String? = nil ,parse_mode: String? = nil ,caption_entities: Array<MessageEntity>? = nil ,disable_content_type_detection: Bool? = nil) {
            self.type = type
            self.media = media
            self.thumbnail = thumbnail
            self.caption = caption
            self.parse_mode = parse_mode
            self.caption_entities = caption_entities
            self.disable_content_type_detection = disable_content_type_detection
        }
    }
}

extension TelegramAPI {
    /**
     * https://core.telegram.org/bots/api#inputfile  
     * This object represents the contents of a file to be uploaded. Must be posted using multipart/form-data in the usual way that files are uploaded via the browser.
    */
    public typealias InputFile = Data
}

extension TelegramAPI {
    /**
     * https://core.telegram.org/bots/api#inputpaidmedia  
     * This object describes the paid media to be sent. Currently, it can be one of
     * - InputPaidMediaPhoto
     * - InputPaidMediaVideo
    */
    public indirect enum InputPaidMedia: Codable {
        case inputPaidMediaPhoto(InputPaidMediaPhoto)
        case inputPaidMediaVideo(InputPaidMediaVideo)

        public init(from decoder: Decoder) throws {
            let container = try decoder.singleValueContainer()
            if let value = try? container.decode(InputPaidMediaPhoto.self) {
                self = .inputPaidMediaPhoto(value)
            }
            else if let value = try? container.decode(InputPaidMediaVideo.self) {
                self = .inputPaidMediaVideo(value)
            }else {
                throw DecodingError.typeMismatch(InputPaidMedia.self, DecodingError.Context(codingPath: decoder.codingPath, debugDescription: "Wrong type for InputPaidMedia"))
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.singleValueContainer()
            switch self {
                case .inputPaidMediaPhoto(let value):
                    try container.encode(value)
                case .inputPaidMediaVideo(let value):
                    try container.encode(value)
            }
        }
    }
}

extension TelegramAPI {
    /**
     * https://core.telegram.org/bots/api#inputpaidmediaphoto  
     * The paid media to send is a photo.
    */
    public struct InputPaidMediaPhoto: Codable {
        /** String | Type of the media, must be photo */
        public let type: String
        /** String | File to send. Pass a file_id to send a file that exists on the Telegram servers (recommended), pass an HTTP URL for Telegram to get a file from the Internet, or pass "attach://<file_attach_name>" to upload a new one using multipart/form-data under <file_attach_name> name. More information on Sending Files: https://core.telegram.org/bots/api#sending-files */
        public let media: String
        public init(type: String ,media: String) {
            self.type = type
            self.media = media
        }
    }
}

extension TelegramAPI {
    /**
     * https://core.telegram.org/bots/api#inputpaidmediavideo  
     * The paid media to send is a video.
    */
    public struct InputPaidMediaVideo: Codable {
        /** String | Type of the media, must be video */
        public let type: String
        /** String | File to send. Pass a file_id to send a file that exists on the Telegram servers (recommended), pass an HTTP URL for Telegram to get a file from the Internet, or pass "attach://<file_attach_name>" to upload a new one using multipart/form-data under <file_attach_name> name. More information on Sending Files: https://core.telegram.org/bots/api#sending-files */
        public let media: String
        /** InputFile or String | Optional. Thumbnail of the file sent; can be ignored if thumbnail generation for the file is supported server-side. The thumbnail should be in JPEG format and less than 200 kB in size. A thumbnail's width and height should not exceed 320. Ignored if the file is not uploaded using multipart/form-data. Thumbnails can't be reused and can be only uploaded as a new file, so you can pass "attach://<file_attach_name>" if the thumbnail was uploaded using multipart/form-data under <file_attach_name>. More information on Sending Files: https://core.telegram.org/bots/api#sending-files */
        public let thumbnail: Either2<InputFile, String>?
        /** Integer | Optional. Video width */
        public let width: Int?
        /** Integer | Optional. Video height */
        public let height: Int?
        /** Integer | Optional. Video duration in seconds */
        public let duration: Int?
        /** Boolean | Optional. Pass True if the uploaded video is suitable for streaming */
        public let supports_streaming: Bool?
        public init(type: String ,media: String ,thumbnail: Either2<InputFile, String>? = nil ,width: Int? = nil ,height: Int? = nil ,duration: Int? = nil ,supports_streaming: Bool? = nil) {
            self.type = type
            self.media = media
            self.thumbnail = thumbnail
            self.width = width
            self.height = height
            self.duration = duration
            self.supports_streaming = supports_streaming
        }
    }
}

extension TelegramAPI {
    /**
     * https://core.telegram.org/bots/api#sticker  
     * This object represents a sticker.
    */
    public struct Sticker: Codable {
        /** String | Identifier for this file, which can be used to download or reuse the file */
        public let file_id: String
        /** String | Unique identifier for this file, which is supposed to be the same over time and for different bots. Can't be used to download or reuse the file. */
        public let file_unique_id: String
        /** String | Type of the sticker, currently one of "regular", "mask", "custom_emoji". The type of the sticker is independent from its format, which is determined by the fields is_animated and is_video. */
        public let type: String
        /** Integer | Sticker width */
        public let width: Int
        /** Integer | Sticker height */
        public let height: Int
        /** Boolean | True, if the sticker is animated */
        public let is_animated: Bool
        /** Boolean | True, if the sticker is a video sticker */
        public let is_video: Bool
        /** PhotoSize | Optional. Sticker thumbnail in the .WEBP or .JPG format */
        public let thumbnail: PhotoSize?
        /** String | Optional. Emoji associated with the sticker */
        public let emoji: String?
        /** String | Optional. Name of the sticker set to which the sticker belongs */
        public let set_name: String?
        /** File | Optional. For premium regular stickers, premium animation for the sticker */
        public let premium_animation: File?
        /** MaskPosition | Optional. For mask stickers, the position where the mask should be placed */
        public let mask_position: MaskPosition?
        /** String | Optional. For custom emoji stickers, unique identifier of the custom emoji */
        public let custom_emoji_id: String?
        /** Boolean | Optional. True, if the sticker must be repainted to a text color in messages, the color of the Telegram Premium badge in emoji status, white color on chat photos, or another appropriate color in other places */
        public let needs_repainting: Bool?
        /** Integer | Optional. File size in bytes */
        public let file_size: Int?
        public init(file_id: String ,file_unique_id: String ,type: String ,width: Int ,height: Int ,is_animated: Bool ,is_video: Bool ,thumbnail: PhotoSize? = nil ,emoji: String? = nil ,set_name: String? = nil ,premium_animation: File? = nil ,mask_position: MaskPosition? = nil ,custom_emoji_id: String? = nil ,needs_repainting: Bool? = nil ,file_size: Int? = nil) {
            self.file_id = file_id
            self.file_unique_id = file_unique_id
            self.type = type
            self.width = width
            self.height = height
            self.is_animated = is_animated
            self.is_video = is_video
            self.thumbnail = thumbnail
            self.emoji = emoji
            self.set_name = set_name
            self.premium_animation = premium_animation
            self.mask_position = mask_position
            self.custom_emoji_id = custom_emoji_id
            self.needs_repainting = needs_repainting
            self.file_size = file_size
        }
    }
}

extension TelegramAPI {
    /**
     * https://core.telegram.org/bots/api#stickerset  
     * This object represents a sticker set.
    */
    public struct StickerSet: Codable {
        /** String | Sticker set name */
        public let name: String
        /** String | Sticker set title */
        public let title: String
        /** String | Type of stickers in the set, currently one of "regular", "mask", "custom_emoji" */
        public let sticker_type: String
        /** Array of Sticker | List of all set stickers */
        public let stickers: Array<Sticker>
        /** PhotoSize | Optional. Sticker set thumbnail in the .WEBP, .TGS, or .WEBM format */
        public let thumbnail: PhotoSize?
        public init(name: String ,title: String ,sticker_type: String ,stickers: Array<Sticker> ,thumbnail: PhotoSize? = nil) {
            self.name = name
            self.title = title
            self.sticker_type = sticker_type
            self.stickers = stickers
            self.thumbnail = thumbnail
        }
    }
}

extension TelegramAPI {
    /**
     * https://core.telegram.org/bots/api#maskposition  
     * This object describes the position on faces where a mask should be placed by default.
    */
    public struct MaskPosition: Codable {
        /** String | The part of the face relative to which the mask should be placed. One of "forehead", "eyes", "mouth", or "chin". */
        public let point: String
        /** Float | Shift by X-axis measured in widths of the mask scaled to the face size, from left to right. For example, choosing -1.0 will place mask just to the left of the default mask position. */
        public let x_shift: Float
        /** Float | Shift by Y-axis measured in heights of the mask scaled to the face size, from top to bottom. For example, 1.0 will place the mask just below the default mask position. */
        public let y_shift: Float
        /** Float | Mask scaling coefficient. For example, 2.0 means double size. */
        public let scale: Float
        public init(point: String ,x_shift: Float ,y_shift: Float ,scale: Float) {
            self.point = point
            self.x_shift = x_shift
            self.y_shift = y_shift
            self.scale = scale
        }
    }
}

extension TelegramAPI {
    /**
     * https://core.telegram.org/bots/api#inputsticker  
     * This object describes a sticker to be added to a sticker set.
    */
    public struct InputSticker: Codable {
        /** InputFile or String | The added sticker. Pass a file_id as a String to send a file that already exists on the Telegram servers, pass an HTTP URL as a String for Telegram to get a file from the Internet, upload a new one using multipart/form-data, or pass "attach://<file_attach_name>" to upload a new one using multipart/form-data under <file_attach_name> name. Animated and video stickers can't be uploaded via HTTP URL. More information on Sending Files: https://core.telegram.org/bots/api#sending-files */
        public let sticker: Either2<InputFile, String>
        /** String | Format of the added sticker, must be one of "static" for a .WEBP or .PNG image, "animated" for a .TGS animation, "video" for a .WEBM video */
        public let format: String
        /** Array of String | List of 1-20 emoji associated with the sticker */
        public let emoji_list: Array<String>
        /** MaskPosition | Optional. Position where the mask should be placed on faces. For "mask" stickers only. */
        public let mask_position: MaskPosition?
        /** Array of String | Optional. List of 0-20 search keywords for the sticker with total length of up to 64 characters. For "regular" and "custom_emoji" stickers only. */
        public let keywords: Array<String>?
        public init(sticker: Either2<InputFile, String> ,format: String ,emoji_list: Array<String> ,mask_position: MaskPosition? = nil ,keywords: Array<String>? = nil) {
            self.sticker = sticker
            self.format = format
            self.emoji_list = emoji_list
            self.mask_position = mask_position
            self.keywords = keywords
        }
    }
}

extension TelegramAPI {
    /**
     * https://core.telegram.org/bots/api#gift  
     * This object represents a gift that can be sent by the bot.
    */
    public struct Gift: Codable {
        /** String | Unique identifier of the gift */
        public let id: String
        /** Sticker | The sticker that represents the gift */
        public let sticker: Sticker
        /** Integer | The number of Telegram Stars that must be paid to send the sticker */
        public let star_count: Int
        /** Integer | Optional. The number of Telegram Stars that must be paid to upgrade the gift to a unique one */
        public let upgrade_star_count: Int?
        /** Integer | Optional. The total number of the gifts of this type that can be sent; for limited gifts only */
        public let total_count: Int?
        /** Integer | Optional. The number of remaining gifts of this type that can be sent; for limited gifts only */
        public let remaining_count: Int?
        public init(id: String ,sticker: Sticker ,star_count: Int ,upgrade_star_count: Int? = nil ,total_count: Int? = nil ,remaining_count: Int? = nil) {
            self.id = id
            self.sticker = sticker
            self.star_count = star_count
            self.upgrade_star_count = upgrade_star_count
            self.total_count = total_count
            self.remaining_count = remaining_count
        }
    }
}

extension TelegramAPI {
    /**
     * https://core.telegram.org/bots/api#gifts  
     * This object represent a list of gifts.
    */
    public struct Gifts: Codable {
        /** Array of Gift | The list of gifts */
        public let gifts: Array<Gift>
        public init(gifts: Array<Gift>) {
            self.gifts = gifts
        }
    }
}

extension TelegramAPI {
    /**
     * https://core.telegram.org/bots/api#inlinequery  
     * This object represents an incoming inline query. When the user sends an empty query, your bot could return some default or trending results.
    */
    public struct InlineQuery: Codable {
        /** String | Unique identifier for this query */
        public let id: String
        /** User | Sender */
        public let from: User
        /** String | Text of the query (up to 256 characters) */
        public let query: String
        /** String | Offset of the results to be returned, can be controlled by the bot */
        public let offset: String
        /** ChatType | Optional. Type of the chat from which the inline query was sent. Can be either "sender" for a private chat with the inline query sender, "private", "group", "supergroup", or "channel". The chat type should be always known for requests sent from official clients and most third-party clients, unless the request was sent from a secret chat */
        public let chat_type: ChatType?
        /** Location | Optional. Sender location, only for bots that request user location */
        public let location: Location?
        public init(id: String ,from: User ,query: String ,offset: String ,chat_type: ChatType? = nil ,location: Location? = nil) {
            self.id = id
            self.from = from
            self.query = query
            self.offset = offset
            self.chat_type = chat_type
            self.location = location
        }
    }
}

extension TelegramAPI {
    /**
     * https://core.telegram.org/bots/api#inlinequeryresultsbutton  
     * This object represents a button to be shown above inline query results. You must use exactly one of the optional fields.
    */
    public struct InlineQueryResultsButton: Codable {
        /** String | Label text on the button */
        public let text: String
        /** WebAppInfo | Optional. Description of the Web App that will be launched when the user presses the button. The Web App will be able to switch back to the inline mode using the method switchInlineQuery inside the Web App. */
        public let web_app: WebAppInfo?
        /** String | Optional. Deep-linking parameter for the /start message sent to the bot when a user presses the button. 1-64 characters, only A-Z, a-z, 0-9, _ and - are allowed. Example: An inline bot that sends YouTube videos can ask the user to connect the bot to their YouTube account to adapt search results accordingly. To do this, it displays a 'Connect your YouTube account' button above the results, or even before showing any. The user presses the button, switches to a private chat with the bot and, in doing so, passes a start parameter that instructs the bot to return an OAuth link. Once done, the bot can offer a switch_inline button so that the user can easily return to the chat where they wanted to use the bot's inline capabilities. */
        public let start_parameter: String?
        public init(text: String ,web_app: WebAppInfo? = nil ,start_parameter: String? = nil) {
            self.text = text
            self.web_app = web_app
            self.start_parameter = start_parameter
        }
    }
}

extension TelegramAPI {
    /**
     * https://core.telegram.org/bots/api#inlinequeryresult  
     * This object represents one result of an inline query. Telegram clients currently support results of the following 20 types:
     * - InlineQueryResultCachedAudio
     * - InlineQueryResultCachedDocument
     * - InlineQueryResultCachedGif
     * - InlineQueryResultCachedMpeg4Gif
     * - InlineQueryResultCachedPhoto
     * - InlineQueryResultCachedSticker
     * - InlineQueryResultCachedVideo
     * - InlineQueryResultCachedVoice
     * - InlineQueryResultArticle
     * - InlineQueryResultAudio
     * - InlineQueryResultContact
     * - InlineQueryResultGame
     * - InlineQueryResultDocument
     * - InlineQueryResultGif
     * - InlineQueryResultLocation
     * - InlineQueryResultMpeg4Gif
     * - InlineQueryResultPhoto
     * - InlineQueryResultVenue
     * - InlineQueryResultVideo
     * - InlineQueryResultVoice
     * Note: All URLs passed in inline query results will be available to end users and therefore must be assumed to be public.
    */
    public indirect enum InlineQueryResult: Codable {
        case inlineQueryResultCachedAudio(InlineQueryResultCachedAudio)
        case inlineQueryResultCachedDocument(InlineQueryResultCachedDocument)
        case inlineQueryResultCachedGif(InlineQueryResultCachedGif)
        case inlineQueryResultCachedMpeg4Gif(InlineQueryResultCachedMpeg4Gif)
        case inlineQueryResultCachedPhoto(InlineQueryResultCachedPhoto)
        case inlineQueryResultCachedSticker(InlineQueryResultCachedSticker)
        case inlineQueryResultCachedVideo(InlineQueryResultCachedVideo)
        case inlineQueryResultCachedVoice(InlineQueryResultCachedVoice)
        case inlineQueryResultArticle(InlineQueryResultArticle)
        case inlineQueryResultAudio(InlineQueryResultAudio)
        case inlineQueryResultContact(InlineQueryResultContact)
        case inlineQueryResultGame(InlineQueryResultGame)
        case inlineQueryResultDocument(InlineQueryResultDocument)
        case inlineQueryResultGif(InlineQueryResultGif)
        case inlineQueryResultLocation(InlineQueryResultLocation)
        case inlineQueryResultMpeg4Gif(InlineQueryResultMpeg4Gif)
        case inlineQueryResultPhoto(InlineQueryResultPhoto)
        case inlineQueryResultVenue(InlineQueryResultVenue)
        case inlineQueryResultVideo(InlineQueryResultVideo)
        case inlineQueryResultVoice(InlineQueryResultVoice)

        public init(from decoder: Decoder) throws {
            let container = try decoder.singleValueContainer()
            if let value = try? container.decode(InlineQueryResultCachedAudio.self) {
                self = .inlineQueryResultCachedAudio(value)
            }
            else if let value = try? container.decode(InlineQueryResultCachedDocument.self) {
                self = .inlineQueryResultCachedDocument(value)
            }
            else if let value = try? container.decode(InlineQueryResultCachedGif.self) {
                self = .inlineQueryResultCachedGif(value)
            }
            else if let value = try? container.decode(InlineQueryResultCachedMpeg4Gif.self) {
                self = .inlineQueryResultCachedMpeg4Gif(value)
            }
            else if let value = try? container.decode(InlineQueryResultCachedPhoto.self) {
                self = .inlineQueryResultCachedPhoto(value)
            }
            else if let value = try? container.decode(InlineQueryResultCachedSticker.self) {
                self = .inlineQueryResultCachedSticker(value)
            }
            else if let value = try? container.decode(InlineQueryResultCachedVideo.self) {
                self = .inlineQueryResultCachedVideo(value)
            }
            else if let value = try? container.decode(InlineQueryResultCachedVoice.self) {
                self = .inlineQueryResultCachedVoice(value)
            }
            else if let value = try? container.decode(InlineQueryResultArticle.self) {
                self = .inlineQueryResultArticle(value)
            }
            else if let value = try? container.decode(InlineQueryResultAudio.self) {
                self = .inlineQueryResultAudio(value)
            }
            else if let value = try? container.decode(InlineQueryResultContact.self) {
                self = .inlineQueryResultContact(value)
            }
            else if let value = try? container.decode(InlineQueryResultGame.self) {
                self = .inlineQueryResultGame(value)
            }
            else if let value = try? container.decode(InlineQueryResultDocument.self) {
                self = .inlineQueryResultDocument(value)
            }
            else if let value = try? container.decode(InlineQueryResultGif.self) {
                self = .inlineQueryResultGif(value)
            }
            else if let value = try? container.decode(InlineQueryResultLocation.self) {
                self = .inlineQueryResultLocation(value)
            }
            else if let value = try? container.decode(InlineQueryResultMpeg4Gif.self) {
                self = .inlineQueryResultMpeg4Gif(value)
            }
            else if let value = try? container.decode(InlineQueryResultPhoto.self) {
                self = .inlineQueryResultPhoto(value)
            }
            else if let value = try? container.decode(InlineQueryResultVenue.self) {
                self = .inlineQueryResultVenue(value)
            }
            else if let value = try? container.decode(InlineQueryResultVideo.self) {
                self = .inlineQueryResultVideo(value)
            }
            else if let value = try? container.decode(InlineQueryResultVoice.self) {
                self = .inlineQueryResultVoice(value)
            }else {
                throw DecodingError.typeMismatch(InlineQueryResult.self, DecodingError.Context(codingPath: decoder.codingPath, debugDescription: "Wrong type for InlineQueryResult"))
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.singleValueContainer()
            switch self {
                case .inlineQueryResultCachedAudio(let value):
                    try container.encode(value)
                case .inlineQueryResultCachedDocument(let value):
                    try container.encode(value)
                case .inlineQueryResultCachedGif(let value):
                    try container.encode(value)
                case .inlineQueryResultCachedMpeg4Gif(let value):
                    try container.encode(value)
                case .inlineQueryResultCachedPhoto(let value):
                    try container.encode(value)
                case .inlineQueryResultCachedSticker(let value):
                    try container.encode(value)
                case .inlineQueryResultCachedVideo(let value):
                    try container.encode(value)
                case .inlineQueryResultCachedVoice(let value):
                    try container.encode(value)
                case .inlineQueryResultArticle(let value):
                    try container.encode(value)
                case .inlineQueryResultAudio(let value):
                    try container.encode(value)
                case .inlineQueryResultContact(let value):
                    try container.encode(value)
                case .inlineQueryResultGame(let value):
                    try container.encode(value)
                case .inlineQueryResultDocument(let value):
                    try container.encode(value)
                case .inlineQueryResultGif(let value):
                    try container.encode(value)
                case .inlineQueryResultLocation(let value):
                    try container.encode(value)
                case .inlineQueryResultMpeg4Gif(let value):
                    try container.encode(value)
                case .inlineQueryResultPhoto(let value):
                    try container.encode(value)
                case .inlineQueryResultVenue(let value):
                    try container.encode(value)
                case .inlineQueryResultVideo(let value):
                    try container.encode(value)
                case .inlineQueryResultVoice(let value):
                    try container.encode(value)
            }
        }
    }
}

extension TelegramAPI {
    /**
     * https://core.telegram.org/bots/api#inlinequeryresultarticle  
     * Represents a link to an article or web page.
    */
    public struct InlineQueryResultArticle: Codable {
        /** String | Type of the result, must be article */
        public let type: String
        /** String | Unique identifier for this result, 1-64 Bytes */
        public let id: String
        /** String | Title of the result */
        public let title: String
        /** InputMessageContent | Content of the message to be sent */
        public let input_message_content: InputMessageContent
        /** InlineKeyboardMarkup | Optional. Inline keyboard attached to the message */
        public let reply_markup: InlineKeyboardMarkup?
        /** String | Optional. URL of the result */
        public let url: String?
        /** String | Optional. Short description of the result */
        public let description: String?
        /** String | Optional. Url of the thumbnail for the result */
        public let thumbnail_url: String?
        /** Integer | Optional. Thumbnail width */
        public let thumbnail_width: Int?
        /** Integer | Optional. Thumbnail height */
        public let thumbnail_height: Int?
        public init(type: String ,id: String ,title: String ,input_message_content: InputMessageContent ,reply_markup: InlineKeyboardMarkup? = nil ,url: String? = nil ,description: String? = nil ,thumbnail_url: String? = nil ,thumbnail_width: Int? = nil ,thumbnail_height: Int? = nil) {
            self.type = type
            self.id = id
            self.title = title
            self.input_message_content = input_message_content
            self.reply_markup = reply_markup
            self.url = url
            self.description = description
            self.thumbnail_url = thumbnail_url
            self.thumbnail_width = thumbnail_width
            self.thumbnail_height = thumbnail_height
        }
    }
}

extension TelegramAPI {
    /**
     * https://core.telegram.org/bots/api#inlinequeryresultphoto  
     * Represents a link to a photo. By default, this photo will be sent by the user with optional caption. Alternatively, you can use input_message_content to send a message with the specified content instead of the photo.
    */
    public struct InlineQueryResultPhoto: Codable {
        /** String | Type of the result, must be photo */
        public let type: String
        /** String | Unique identifier for this result, 1-64 bytes */
        public let id: String
        /** String | A valid URL of the photo. Photo must be in JPEG format. Photo size must not exceed 5MB */
        public let photo_url: String
        /** String | URL of the thumbnail for the photo */
        public let thumbnail_url: String
        /** Integer | Optional. Width of the photo */
        public let photo_width: Int?
        /** Integer | Optional. Height of the photo */
        public let photo_height: Int?
        /** String | Optional. Title for the result */
        public let title: String?
        /** String | Optional. Short description of the result */
        public let description: String?
        /** String | Optional. Caption of the photo to be sent, 0-1024 characters after entities parsing */
        public let caption: String?
        /** String | Optional. Mode for parsing entities in the photo caption. See formatting options for more details. */
        public let parse_mode: String?
        /** Array of MessageEntity | Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode */
        public let caption_entities: Array<MessageEntity>?
        /** Boolean | Optional. Pass True, if the caption must be shown above the message media */
        public let show_caption_above_media: Bool?
        /** InlineKeyboardMarkup | Optional. Inline keyboard attached to the message */
        public let reply_markup: InlineKeyboardMarkup?
        /** InputMessageContent | Optional. Content of the message to be sent instead of the photo */
        public let input_message_content: InputMessageContent?
        public init(type: String ,id: String ,photo_url: String ,thumbnail_url: String ,photo_width: Int? = nil ,photo_height: Int? = nil ,title: String? = nil ,description: String? = nil ,caption: String? = nil ,parse_mode: String? = nil ,caption_entities: Array<MessageEntity>? = nil ,show_caption_above_media: Bool? = nil ,reply_markup: InlineKeyboardMarkup? = nil ,input_message_content: InputMessageContent? = nil) {
            self.type = type
            self.id = id
            self.photo_url = photo_url
            self.thumbnail_url = thumbnail_url
            self.photo_width = photo_width
            self.photo_height = photo_height
            self.title = title
            self.description = description
            self.caption = caption
            self.parse_mode = parse_mode
            self.caption_entities = caption_entities
            self.show_caption_above_media = show_caption_above_media
            self.reply_markup = reply_markup
            self.input_message_content = input_message_content
        }
    }
}

extension TelegramAPI {
    /**
     * https://core.telegram.org/bots/api#inlinequeryresultgif  
     * Represents a link to an animated GIF file. By default, this animated GIF file will be sent by the user with optional caption. Alternatively, you can use input_message_content to send a message with the specified content instead of the animation.
    */
    public struct InlineQueryResultGif: Codable {
        /** String | Type of the result, must be gif */
        public let type: String
        /** String | Unique identifier for this result, 1-64 bytes */
        public let id: String
        /** String | A valid URL for the GIF file */
        public let gif_url: String
        /** Integer | Optional. Width of the GIF */
        public let gif_width: Int?
        /** Integer | Optional. Height of the GIF */
        public let gif_height: Int?
        /** Integer | Optional. Duration of the GIF in seconds */
        public let gif_duration: Int?
        /** String | URL of the static (JPEG or GIF) or animated (MPEG4) thumbnail for the result */
        public let thumbnail_url: String
        /** String | Optional. MIME type of the thumbnail, must be one of "image/jpeg", "image/gif", or "video/mp4". Defaults to "image/jpeg" */
        public let thumbnail_mime_type: String?
        /** String | Optional. Title for the result */
        public let title: String?
        /** String | Optional. Caption of the GIF file to be sent, 0-1024 characters after entities parsing */
        public let caption: String?
        /** String | Optional. Mode for parsing entities in the caption. See formatting options for more details. */
        public let parse_mode: String?
        /** Array of MessageEntity | Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode */
        public let caption_entities: Array<MessageEntity>?
        /** Boolean | Optional. Pass True, if the caption must be shown above the message media */
        public let show_caption_above_media: Bool?
        /** InlineKeyboardMarkup | Optional. Inline keyboard attached to the message */
        public let reply_markup: InlineKeyboardMarkup?
        /** InputMessageContent | Optional. Content of the message to be sent instead of the GIF animation */
        public let input_message_content: InputMessageContent?
        public init(type: String ,id: String ,gif_url: String ,gif_width: Int? = nil ,gif_height: Int? = nil ,gif_duration: Int? = nil ,thumbnail_url: String ,thumbnail_mime_type: String? = nil ,title: String? = nil ,caption: String? = nil ,parse_mode: String? = nil ,caption_entities: Array<MessageEntity>? = nil ,show_caption_above_media: Bool? = nil ,reply_markup: InlineKeyboardMarkup? = nil ,input_message_content: InputMessageContent? = nil) {
            self.type = type
            self.id = id
            self.gif_url = gif_url
            self.gif_width = gif_width
            self.gif_height = gif_height
            self.gif_duration = gif_duration
            self.thumbnail_url = thumbnail_url
            self.thumbnail_mime_type = thumbnail_mime_type
            self.title = title
            self.caption = caption
            self.parse_mode = parse_mode
            self.caption_entities = caption_entities
            self.show_caption_above_media = show_caption_above_media
            self.reply_markup = reply_markup
            self.input_message_content = input_message_content
        }
    }
}

extension TelegramAPI {
    /**
     * https://core.telegram.org/bots/api#inlinequeryresultmpeg4gif  
     * Represents a link to a video animation (H.264/MPEG-4 AVC video without sound). By default, this animated MPEG-4 file will be sent by the user with optional caption. Alternatively, you can use input_message_content to send a message with the specified content instead of the animation.
    */
    public struct InlineQueryResultMpeg4Gif: Codable {
        /** String | Type of the result, must be mpeg4_gif */
        public let type: String
        /** String | Unique identifier for this result, 1-64 bytes */
        public let id: String
        /** String | A valid URL for the MPEG4 file */
        public let mpeg4_url: String
        /** Integer | Optional. Video width */
        public let mpeg4_width: Int?
        /** Integer | Optional. Video height */
        public let mpeg4_height: Int?
        /** Integer | Optional. Video duration in seconds */
        public let mpeg4_duration: Int?
        /** String | URL of the static (JPEG or GIF) or animated (MPEG4) thumbnail for the result */
        public let thumbnail_url: String
        /** String | Optional. MIME type of the thumbnail, must be one of "image/jpeg", "image/gif", or "video/mp4". Defaults to "image/jpeg" */
        public let thumbnail_mime_type: String?
        /** String | Optional. Title for the result */
        public let title: String?
        /** String | Optional. Caption of the MPEG-4 file to be sent, 0-1024 characters after entities parsing */
        public let caption: String?
        /** String | Optional. Mode for parsing entities in the caption. See formatting options for more details. */
        public let parse_mode: String?
        /** Array of MessageEntity | Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode */
        public let caption_entities: Array<MessageEntity>?
        /** Boolean | Optional. Pass True, if the caption must be shown above the message media */
        public let show_caption_above_media: Bool?
        /** InlineKeyboardMarkup | Optional. Inline keyboard attached to the message */
        public let reply_markup: InlineKeyboardMarkup?
        /** InputMessageContent | Optional. Content of the message to be sent instead of the video animation */
        public let input_message_content: InputMessageContent?
        public init(type: String ,id: String ,mpeg4_url: String ,mpeg4_width: Int? = nil ,mpeg4_height: Int? = nil ,mpeg4_duration: Int? = nil ,thumbnail_url: String ,thumbnail_mime_type: String? = nil ,title: String? = nil ,caption: String? = nil ,parse_mode: String? = nil ,caption_entities: Array<MessageEntity>? = nil ,show_caption_above_media: Bool? = nil ,reply_markup: InlineKeyboardMarkup? = nil ,input_message_content: InputMessageContent? = nil) {
            self.type = type
            self.id = id
            self.mpeg4_url = mpeg4_url
            self.mpeg4_width = mpeg4_width
            self.mpeg4_height = mpeg4_height
            self.mpeg4_duration = mpeg4_duration
            self.thumbnail_url = thumbnail_url
            self.thumbnail_mime_type = thumbnail_mime_type
            self.title = title
            self.caption = caption
            self.parse_mode = parse_mode
            self.caption_entities = caption_entities
            self.show_caption_above_media = show_caption_above_media
            self.reply_markup = reply_markup
            self.input_message_content = input_message_content
        }
    }
}

extension TelegramAPI {
    /**
     * https://core.telegram.org/bots/api#inlinequeryresultvideo  
     * Represents a link to a page containing an embedded video player or a video file. By default, this video file will be sent by the user with an optional caption. Alternatively, you can use input_message_content to send a message with the specified content instead of the video.
    */
    public struct InlineQueryResultVideo: Codable {
        /** String | Type of the result, must be video */
        public let type: String
        /** String | Unique identifier for this result, 1-64 bytes */
        public let id: String
        /** String | A valid URL for the embedded video player or video file */
        public let video_url: String
        /** String | MIME type of the content of the video URL, "text/html" or "video/mp4" */
        public let mime_type: String
        /** String | URL of the thumbnail (JPEG only) for the video */
        public let thumbnail_url: String
        /** String | Title for the result */
        public let title: String
        /** String | Optional. Caption of the video to be sent, 0-1024 characters after entities parsing */
        public let caption: String?
        /** String | Optional. Mode for parsing entities in the video caption. See formatting options for more details. */
        public let parse_mode: String?
        /** Array of MessageEntity | Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode */
        public let caption_entities: Array<MessageEntity>?
        /** Boolean | Optional. Pass True, if the caption must be shown above the message media */
        public let show_caption_above_media: Bool?
        /** Integer | Optional. Video width */
        public let video_width: Int?
        /** Integer | Optional. Video height */
        public let video_height: Int?
        /** Integer | Optional. Video duration in seconds */
        public let video_duration: Int?
        /** String | Optional. Short description of the result */
        public let description: String?
        /** InlineKeyboardMarkup | Optional. Inline keyboard attached to the message */
        public let reply_markup: InlineKeyboardMarkup?
        /** InputMessageContent | Optional. Content of the message to be sent instead of the video. This field is required if InlineQueryResultVideo is used to send an HTML-page as a result (e.g., a YouTube video). */
        public let input_message_content: InputMessageContent?
        public init(type: String ,id: String ,video_url: String ,mime_type: String ,thumbnail_url: String ,title: String ,caption: String? = nil ,parse_mode: String? = nil ,caption_entities: Array<MessageEntity>? = nil ,show_caption_above_media: Bool? = nil ,video_width: Int? = nil ,video_height: Int? = nil ,video_duration: Int? = nil ,description: String? = nil ,reply_markup: InlineKeyboardMarkup? = nil ,input_message_content: InputMessageContent? = nil) {
            self.type = type
            self.id = id
            self.video_url = video_url
            self.mime_type = mime_type
            self.thumbnail_url = thumbnail_url
            self.title = title
            self.caption = caption
            self.parse_mode = parse_mode
            self.caption_entities = caption_entities
            self.show_caption_above_media = show_caption_above_media
            self.video_width = video_width
            self.video_height = video_height
            self.video_duration = video_duration
            self.description = description
            self.reply_markup = reply_markup
            self.input_message_content = input_message_content
        }
    }
}

extension TelegramAPI {
    /**
     * https://core.telegram.org/bots/api#inlinequeryresultaudio  
     * Represents a link to an MP3 audio file. By default, this audio file will be sent by the user. Alternatively, you can use input_message_content to send a message with the specified content instead of the audio.
    */
    public struct InlineQueryResultAudio: Codable {
        /** String | Type of the result, must be audio */
        public let type: String
        /** String | Unique identifier for this result, 1-64 bytes */
        public let id: String
        /** String | A valid URL for the audio file */
        public let audio_url: String
        /** String | Title */
        public let title: String
        /** String | Optional. Caption, 0-1024 characters after entities parsing */
        public let caption: String?
        /** String | Optional. Mode for parsing entities in the audio caption. See formatting options for more details. */
        public let parse_mode: String?
        /** Array of MessageEntity | Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode */
        public let caption_entities: Array<MessageEntity>?
        /** String | Optional. Performer */
        public let performer: String?
        /** Integer | Optional. Audio duration in seconds */
        public let audio_duration: Int?
        /** InlineKeyboardMarkup | Optional. Inline keyboard attached to the message */
        public let reply_markup: InlineKeyboardMarkup?
        /** InputMessageContent | Optional. Content of the message to be sent instead of the audio */
        public let input_message_content: InputMessageContent?
        public init(type: String ,id: String ,audio_url: String ,title: String ,caption: String? = nil ,parse_mode: String? = nil ,caption_entities: Array<MessageEntity>? = nil ,performer: String? = nil ,audio_duration: Int? = nil ,reply_markup: InlineKeyboardMarkup? = nil ,input_message_content: InputMessageContent? = nil) {
            self.type = type
            self.id = id
            self.audio_url = audio_url
            self.title = title
            self.caption = caption
            self.parse_mode = parse_mode
            self.caption_entities = caption_entities
            self.performer = performer
            self.audio_duration = audio_duration
            self.reply_markup = reply_markup
            self.input_message_content = input_message_content
        }
    }
}

extension TelegramAPI {
    /**
     * https://core.telegram.org/bots/api#inlinequeryresultvoice  
     * Represents a link to a voice recording in an .OGG container encoded with OPUS. By default, this voice recording will be sent by the user. Alternatively, you can use input_message_content to send a message with the specified content instead of the the voice message.
    */
    public struct InlineQueryResultVoice: Codable {
        /** String | Type of the result, must be voice */
        public let type: String
        /** String | Unique identifier for this result, 1-64 bytes */
        public let id: String
        /** String | A valid URL for the voice recording */
        public let voice_url: String
        /** String | Recording title */
        public let title: String
        /** String | Optional. Caption, 0-1024 characters after entities parsing */
        public let caption: String?
        /** String | Optional. Mode for parsing entities in the voice message caption. See formatting options for more details. */
        public let parse_mode: String?
        /** Array of MessageEntity | Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode */
        public let caption_entities: Array<MessageEntity>?
        /** Integer | Optional. Recording duration in seconds */
        public let voice_duration: Int?
        /** InlineKeyboardMarkup | Optional. Inline keyboard attached to the message */
        public let reply_markup: InlineKeyboardMarkup?
        /** InputMessageContent | Optional. Content of the message to be sent instead of the voice recording */
        public let input_message_content: InputMessageContent?
        public init(type: String ,id: String ,voice_url: String ,title: String ,caption: String? = nil ,parse_mode: String? = nil ,caption_entities: Array<MessageEntity>? = nil ,voice_duration: Int? = nil ,reply_markup: InlineKeyboardMarkup? = nil ,input_message_content: InputMessageContent? = nil) {
            self.type = type
            self.id = id
            self.voice_url = voice_url
            self.title = title
            self.caption = caption
            self.parse_mode = parse_mode
            self.caption_entities = caption_entities
            self.voice_duration = voice_duration
            self.reply_markup = reply_markup
            self.input_message_content = input_message_content
        }
    }
}

extension TelegramAPI {
    /**
     * https://core.telegram.org/bots/api#inlinequeryresultdocument  
     * Represents a link to a file. By default, this file will be sent by the user with an optional caption. Alternatively, you can use input_message_content to send a message with the specified content instead of the file. Currently, only .PDF and .ZIP files can be sent using this method.
    */
    public struct InlineQueryResultDocument: Codable {
        /** String | Type of the result, must be document */
        public let type: String
        /** String | Unique identifier for this result, 1-64 bytes */
        public let id: String
        /** String | Title for the result */
        public let title: String
        /** String | Optional. Caption of the document to be sent, 0-1024 characters after entities parsing */
        public let caption: String?
        /** String | Optional. Mode for parsing entities in the document caption. See formatting options for more details. */
        public let parse_mode: String?
        /** Array of MessageEntity | Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode */
        public let caption_entities: Array<MessageEntity>?
        /** String | A valid URL for the file */
        public let document_url: String
        /** String | MIME type of the content of the file, either "application/pdf" or "application/zip" */
        public let mime_type: String
        /** String | Optional. Short description of the result */
        public let description: String?
        /** InlineKeyboardMarkup | Optional. Inline keyboard attached to the message */
        public let reply_markup: InlineKeyboardMarkup?
        /** InputMessageContent | Optional. Content of the message to be sent instead of the file */
        public let input_message_content: InputMessageContent?
        /** String | Optional. URL of the thumbnail (JPEG only) for the file */
        public let thumbnail_url: String?
        /** Integer | Optional. Thumbnail width */
        public let thumbnail_width: Int?
        /** Integer | Optional. Thumbnail height */
        public let thumbnail_height: Int?
        public init(type: String ,id: String ,title: String ,caption: String? = nil ,parse_mode: String? = nil ,caption_entities: Array<MessageEntity>? = nil ,document_url: String ,mime_type: String ,description: String? = nil ,reply_markup: InlineKeyboardMarkup? = nil ,input_message_content: InputMessageContent? = nil ,thumbnail_url: String? = nil ,thumbnail_width: Int? = nil ,thumbnail_height: Int? = nil) {
            self.type = type
            self.id = id
            self.title = title
            self.caption = caption
            self.parse_mode = parse_mode
            self.caption_entities = caption_entities
            self.document_url = document_url
            self.mime_type = mime_type
            self.description = description
            self.reply_markup = reply_markup
            self.input_message_content = input_message_content
            self.thumbnail_url = thumbnail_url
            self.thumbnail_width = thumbnail_width
            self.thumbnail_height = thumbnail_height
        }
    }
}

extension TelegramAPI {
    /**
     * https://core.telegram.org/bots/api#inlinequeryresultlocation  
     * Represents a location on a map. By default, the location will be sent by the user. Alternatively, you can use input_message_content to send a message with the specified content instead of the location.
    */
    public struct InlineQueryResultLocation: Codable {
        /** String | Type of the result, must be location */
        public let type: String
        /** String | Unique identifier for this result, 1-64 Bytes */
        public let id: String
        /** Float | Location latitude in degrees */
        public let latitude: Float
        /** Float | Location longitude in degrees */
        public let longitude: Float
        /** String | Location title */
        public let title: String
        /** Float | Optional. The radius of uncertainty for the location, measured in meters; 0-1500 */
        public let horizontal_accuracy: Float?
        /** Integer | Optional. Period in seconds during which the location can be updated, should be between 60 and 86400, or 0x7FFFFFFF for live locations that can be edited indefinitely. */
        public let live_period: Int?
        /** Integer | Optional. For live locations, a direction in which the user is moving, in degrees. Must be between 1 and 360 if specified. */
        public let heading: Int?
        /** Integer | Optional. For live locations, a maximum distance for proximity alerts about approaching another chat member, in meters. Must be between 1 and 100000 if specified. */
        public let proximity_alert_radius: Int?
        /** InlineKeyboardMarkup | Optional. Inline keyboard attached to the message */
        public let reply_markup: InlineKeyboardMarkup?
        /** InputMessageContent | Optional. Content of the message to be sent instead of the location */
        public let input_message_content: InputMessageContent?
        /** String | Optional. Url of the thumbnail for the result */
        public let thumbnail_url: String?
        /** Integer | Optional. Thumbnail width */
        public let thumbnail_width: Int?
        /** Integer | Optional. Thumbnail height */
        public let thumbnail_height: Int?
        public init(type: String ,id: String ,latitude: Float ,longitude: Float ,title: String ,horizontal_accuracy: Float? = nil ,live_period: Int? = nil ,heading: Int? = nil ,proximity_alert_radius: Int? = nil ,reply_markup: InlineKeyboardMarkup? = nil ,input_message_content: InputMessageContent? = nil ,thumbnail_url: String? = nil ,thumbnail_width: Int? = nil ,thumbnail_height: Int? = nil) {
            self.type = type
            self.id = id
            self.latitude = latitude
            self.longitude = longitude
            self.title = title
            self.horizontal_accuracy = horizontal_accuracy
            self.live_period = live_period
            self.heading = heading
            self.proximity_alert_radius = proximity_alert_radius
            self.reply_markup = reply_markup
            self.input_message_content = input_message_content
            self.thumbnail_url = thumbnail_url
            self.thumbnail_width = thumbnail_width
            self.thumbnail_height = thumbnail_height
        }
    }
}

extension TelegramAPI {
    /**
     * https://core.telegram.org/bots/api#inlinequeryresultvenue  
     * Represents a venue. By default, the venue will be sent by the user. Alternatively, you can use input_message_content to send a message with the specified content instead of the venue.
    */
    public struct InlineQueryResultVenue: Codable {
        /** String | Type of the result, must be venue */
        public let type: String
        /** String | Unique identifier for this result, 1-64 Bytes */
        public let id: String
        /** Float | Latitude of the venue location in degrees */
        public let latitude: Float
        /** Float | Longitude of the venue location in degrees */
        public let longitude: Float
        /** String | Title of the venue */
        public let title: String
        /** String | Address of the venue */
        public let address: String
        /** String | Optional. Foursquare identifier of the venue if known */
        public let foursquare_id: String?
        /** String | Optional. Foursquare type of the venue, if known. (For example, "arts_entertainment/default", "arts_entertainment/aquarium" or "food/icecream".) */
        public let foursquare_type: String?
        /** String | Optional. Google Places identifier of the venue */
        public let google_place_id: String?
        /** String | Optional. Google Places type of the venue. (See supported types.) */
        public let google_place_type: String?
        /** InlineKeyboardMarkup | Optional. Inline keyboard attached to the message */
        public let reply_markup: InlineKeyboardMarkup?
        /** InputMessageContent | Optional. Content of the message to be sent instead of the venue */
        public let input_message_content: InputMessageContent?
        /** String | Optional. Url of the thumbnail for the result */
        public let thumbnail_url: String?
        /** Integer | Optional. Thumbnail width */
        public let thumbnail_width: Int?
        /** Integer | Optional. Thumbnail height */
        public let thumbnail_height: Int?
        public init(type: String ,id: String ,latitude: Float ,longitude: Float ,title: String ,address: String ,foursquare_id: String? = nil ,foursquare_type: String? = nil ,google_place_id: String? = nil ,google_place_type: String? = nil ,reply_markup: InlineKeyboardMarkup? = nil ,input_message_content: InputMessageContent? = nil ,thumbnail_url: String? = nil ,thumbnail_width: Int? = nil ,thumbnail_height: Int? = nil) {
            self.type = type
            self.id = id
            self.latitude = latitude
            self.longitude = longitude
            self.title = title
            self.address = address
            self.foursquare_id = foursquare_id
            self.foursquare_type = foursquare_type
            self.google_place_id = google_place_id
            self.google_place_type = google_place_type
            self.reply_markup = reply_markup
            self.input_message_content = input_message_content
            self.thumbnail_url = thumbnail_url
            self.thumbnail_width = thumbnail_width
            self.thumbnail_height = thumbnail_height
        }
    }
}

extension TelegramAPI {
    /**
     * https://core.telegram.org/bots/api#inlinequeryresultcontact  
     * Represents a contact with a phone number. By default, this contact will be sent by the user. Alternatively, you can use input_message_content to send a message with the specified content instead of the contact.
    */
    public struct InlineQueryResultContact: Codable {
        /** String | Type of the result, must be contact */
        public let type: String
        /** String | Unique identifier for this result, 1-64 Bytes */
        public let id: String
        /** String | Contact's phone number */
        public let phone_number: String
        /** String | Contact's first name */
        public let first_name: String
        /** String | Optional. Contact's last name */
        public let last_name: String?
        /** String | Optional. Additional data about the contact in the form of a vCard, 0-2048 bytes */
        public let vcard: String?
        /** InlineKeyboardMarkup | Optional. Inline keyboard attached to the message */
        public let reply_markup: InlineKeyboardMarkup?
        /** InputMessageContent | Optional. Content of the message to be sent instead of the contact */
        public let input_message_content: InputMessageContent?
        /** String | Optional. Url of the thumbnail for the result */
        public let thumbnail_url: String?
        /** Integer | Optional. Thumbnail width */
        public let thumbnail_width: Int?
        /** Integer | Optional. Thumbnail height */
        public let thumbnail_height: Int?
        public init(type: String ,id: String ,phone_number: String ,first_name: String ,last_name: String? = nil ,vcard: String? = nil ,reply_markup: InlineKeyboardMarkup? = nil ,input_message_content: InputMessageContent? = nil ,thumbnail_url: String? = nil ,thumbnail_width: Int? = nil ,thumbnail_height: Int? = nil) {
            self.type = type
            self.id = id
            self.phone_number = phone_number
            self.first_name = first_name
            self.last_name = last_name
            self.vcard = vcard
            self.reply_markup = reply_markup
            self.input_message_content = input_message_content
            self.thumbnail_url = thumbnail_url
            self.thumbnail_width = thumbnail_width
            self.thumbnail_height = thumbnail_height
        }
    }
}

extension TelegramAPI {
    /**
     * https://core.telegram.org/bots/api#inlinequeryresultgame  
     * Represents a Game.
    */
    public struct InlineQueryResultGame: Codable {
        /** String | Type of the result, must be game */
        public let type: String
        /** String | Unique identifier for this result, 1-64 bytes */
        public let id: String
        /** String | Short name of the game */
        public let game_short_name: String
        /** InlineKeyboardMarkup | Optional. Inline keyboard attached to the message */
        public let reply_markup: InlineKeyboardMarkup?
        public init(type: String ,id: String ,game_short_name: String ,reply_markup: InlineKeyboardMarkup? = nil) {
            self.type = type
            self.id = id
            self.game_short_name = game_short_name
            self.reply_markup = reply_markup
        }
    }
}

extension TelegramAPI {
    /**
     * https://core.telegram.org/bots/api#inlinequeryresultcachedphoto  
     * Represents a link to a photo stored on the Telegram servers. By default, this photo will be sent by the user with an optional caption. Alternatively, you can use input_message_content to send a message with the specified content instead of the photo.
    */
    public struct InlineQueryResultCachedPhoto: Codable {
        /** String | Type of the result, must be photo */
        public let type: String
        /** String | Unique identifier for this result, 1-64 bytes */
        public let id: String
        /** String | A valid file identifier of the photo */
        public let photo_file_id: String
        /** String | Optional. Title for the result */
        public let title: String?
        /** String | Optional. Short description of the result */
        public let description: String?
        /** String | Optional. Caption of the photo to be sent, 0-1024 characters after entities parsing */
        public let caption: String?
        /** String | Optional. Mode for parsing entities in the photo caption. See formatting options for more details. */
        public let parse_mode: String?
        /** Array of MessageEntity | Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode */
        public let caption_entities: Array<MessageEntity>?
        /** Boolean | Optional. Pass True, if the caption must be shown above the message media */
        public let show_caption_above_media: Bool?
        /** InlineKeyboardMarkup | Optional. Inline keyboard attached to the message */
        public let reply_markup: InlineKeyboardMarkup?
        /** InputMessageContent | Optional. Content of the message to be sent instead of the photo */
        public let input_message_content: InputMessageContent?
        public init(type: String ,id: String ,photo_file_id: String ,title: String? = nil ,description: String? = nil ,caption: String? = nil ,parse_mode: String? = nil ,caption_entities: Array<MessageEntity>? = nil ,show_caption_above_media: Bool? = nil ,reply_markup: InlineKeyboardMarkup? = nil ,input_message_content: InputMessageContent? = nil) {
            self.type = type
            self.id = id
            self.photo_file_id = photo_file_id
            self.title = title
            self.description = description
            self.caption = caption
            self.parse_mode = parse_mode
            self.caption_entities = caption_entities
            self.show_caption_above_media = show_caption_above_media
            self.reply_markup = reply_markup
            self.input_message_content = input_message_content
        }
    }
}

extension TelegramAPI {
    /**
     * https://core.telegram.org/bots/api#inlinequeryresultcachedgif  
     * Represents a link to an animated GIF file stored on the Telegram servers. By default, this animated GIF file will be sent by the user with an optional caption. Alternatively, you can use input_message_content to send a message with specified content instead of the animation.
    */
    public struct InlineQueryResultCachedGif: Codable {
        /** String | Type of the result, must be gif */
        public let type: String
        /** String | Unique identifier for this result, 1-64 bytes */
        public let id: String
        /** String | A valid file identifier for the GIF file */
        public let gif_file_id: String
        /** String | Optional. Title for the result */
        public let title: String?
        /** String | Optional. Caption of the GIF file to be sent, 0-1024 characters after entities parsing */
        public let caption: String?
        /** String | Optional. Mode for parsing entities in the caption. See formatting options for more details. */
        public let parse_mode: String?
        /** Array of MessageEntity | Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode */
        public let caption_entities: Array<MessageEntity>?
        /** Boolean | Optional. Pass True, if the caption must be shown above the message media */
        public let show_caption_above_media: Bool?
        /** InlineKeyboardMarkup | Optional. Inline keyboard attached to the message */
        public let reply_markup: InlineKeyboardMarkup?
        /** InputMessageContent | Optional. Content of the message to be sent instead of the GIF animation */
        public let input_message_content: InputMessageContent?
        public init(type: String ,id: String ,gif_file_id: String ,title: String? = nil ,caption: String? = nil ,parse_mode: String? = nil ,caption_entities: Array<MessageEntity>? = nil ,show_caption_above_media: Bool? = nil ,reply_markup: InlineKeyboardMarkup? = nil ,input_message_content: InputMessageContent? = nil) {
            self.type = type
            self.id = id
            self.gif_file_id = gif_file_id
            self.title = title
            self.caption = caption
            self.parse_mode = parse_mode
            self.caption_entities = caption_entities
            self.show_caption_above_media = show_caption_above_media
            self.reply_markup = reply_markup
            self.input_message_content = input_message_content
        }
    }
}

extension TelegramAPI {
    /**
     * https://core.telegram.org/bots/api#inlinequeryresultcachedmpeg4gif  
     * Represents a link to a video animation (H.264/MPEG-4 AVC video without sound) stored on the Telegram servers. By default, this animated MPEG-4 file will be sent by the user with an optional caption. Alternatively, you can use input_message_content to send a message with the specified content instead of the animation.
    */
    public struct InlineQueryResultCachedMpeg4Gif: Codable {
        /** String | Type of the result, must be mpeg4_gif */
        public let type: String
        /** String | Unique identifier for this result, 1-64 bytes */
        public let id: String
        /** String | A valid file identifier for the MPEG4 file */
        public let mpeg4_file_id: String
        /** String | Optional. Title for the result */
        public let title: String?
        /** String | Optional. Caption of the MPEG-4 file to be sent, 0-1024 characters after entities parsing */
        public let caption: String?
        /** String | Optional. Mode for parsing entities in the caption. See formatting options for more details. */
        public let parse_mode: String?
        /** Array of MessageEntity | Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode */
        public let caption_entities: Array<MessageEntity>?
        /** Boolean | Optional. Pass True, if the caption must be shown above the message media */
        public let show_caption_above_media: Bool?
        /** InlineKeyboardMarkup | Optional. Inline keyboard attached to the message */
        public let reply_markup: InlineKeyboardMarkup?
        /** InputMessageContent | Optional. Content of the message to be sent instead of the video animation */
        public let input_message_content: InputMessageContent?
        public init(type: String ,id: String ,mpeg4_file_id: String ,title: String? = nil ,caption: String? = nil ,parse_mode: String? = nil ,caption_entities: Array<MessageEntity>? = nil ,show_caption_above_media: Bool? = nil ,reply_markup: InlineKeyboardMarkup? = nil ,input_message_content: InputMessageContent? = nil) {
            self.type = type
            self.id = id
            self.mpeg4_file_id = mpeg4_file_id
            self.title = title
            self.caption = caption
            self.parse_mode = parse_mode
            self.caption_entities = caption_entities
            self.show_caption_above_media = show_caption_above_media
            self.reply_markup = reply_markup
            self.input_message_content = input_message_content
        }
    }
}

extension TelegramAPI {
    /**
     * https://core.telegram.org/bots/api#inlinequeryresultcachedsticker  
     * Represents a link to a sticker stored on the Telegram servers. By default, this sticker will be sent by the user. Alternatively, you can use input_message_content to send a message with the specified content instead of the sticker.
    */
    public struct InlineQueryResultCachedSticker: Codable {
        /** String | Type of the result, must be sticker */
        public let type: String
        /** String | Unique identifier for this result, 1-64 bytes */
        public let id: String
        /** String | A valid file identifier of the sticker */
        public let sticker_file_id: String
        /** InlineKeyboardMarkup | Optional. Inline keyboard attached to the message */
        public let reply_markup: InlineKeyboardMarkup?
        /** InputMessageContent | Optional. Content of the message to be sent instead of the sticker */
        public let input_message_content: InputMessageContent?
        public init(type: String ,id: String ,sticker_file_id: String ,reply_markup: InlineKeyboardMarkup? = nil ,input_message_content: InputMessageContent? = nil) {
            self.type = type
            self.id = id
            self.sticker_file_id = sticker_file_id
            self.reply_markup = reply_markup
            self.input_message_content = input_message_content
        }
    }
}

extension TelegramAPI {
    /**
     * https://core.telegram.org/bots/api#inlinequeryresultcacheddocument  
     * Represents a link to a file stored on the Telegram servers. By default, this file will be sent by the user with an optional caption. Alternatively, you can use input_message_content to send a message with the specified content instead of the file.
    */
    public struct InlineQueryResultCachedDocument: Codable {
        /** String | Type of the result, must be document */
        public let type: String
        /** String | Unique identifier for this result, 1-64 bytes */
        public let id: String
        /** String | Title for the result */
        public let title: String
        /** String | A valid file identifier for the file */
        public let document_file_id: String
        /** String | Optional. Short description of the result */
        public let description: String?
        /** String | Optional. Caption of the document to be sent, 0-1024 characters after entities parsing */
        public let caption: String?
        /** String | Optional. Mode for parsing entities in the document caption. See formatting options for more details. */
        public let parse_mode: String?
        /** Array of MessageEntity | Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode */
        public let caption_entities: Array<MessageEntity>?
        /** InlineKeyboardMarkup | Optional. Inline keyboard attached to the message */
        public let reply_markup: InlineKeyboardMarkup?
        /** InputMessageContent | Optional. Content of the message to be sent instead of the file */
        public let input_message_content: InputMessageContent?
        public init(type: String ,id: String ,title: String ,document_file_id: String ,description: String? = nil ,caption: String? = nil ,parse_mode: String? = nil ,caption_entities: Array<MessageEntity>? = nil ,reply_markup: InlineKeyboardMarkup? = nil ,input_message_content: InputMessageContent? = nil) {
            self.type = type
            self.id = id
            self.title = title
            self.document_file_id = document_file_id
            self.description = description
            self.caption = caption
            self.parse_mode = parse_mode
            self.caption_entities = caption_entities
            self.reply_markup = reply_markup
            self.input_message_content = input_message_content
        }
    }
}

extension TelegramAPI {
    /**
     * https://core.telegram.org/bots/api#inlinequeryresultcachedvideo  
     * Represents a link to a video file stored on the Telegram servers. By default, this video file will be sent by the user with an optional caption. Alternatively, you can use input_message_content to send a message with the specified content instead of the video.
    */
    public struct InlineQueryResultCachedVideo: Codable {
        /** String | Type of the result, must be video */
        public let type: String
        /** String | Unique identifier for this result, 1-64 bytes */
        public let id: String
        /** String | A valid file identifier for the video file */
        public let video_file_id: String
        /** String | Title for the result */
        public let title: String
        /** String | Optional. Short description of the result */
        public let description: String?
        /** String | Optional. Caption of the video to be sent, 0-1024 characters after entities parsing */
        public let caption: String?
        /** String | Optional. Mode for parsing entities in the video caption. See formatting options for more details. */
        public let parse_mode: String?
        /** Array of MessageEntity | Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode */
        public let caption_entities: Array<MessageEntity>?
        /** Boolean | Optional. Pass True, if the caption must be shown above the message media */
        public let show_caption_above_media: Bool?
        /** InlineKeyboardMarkup | Optional. Inline keyboard attached to the message */
        public let reply_markup: InlineKeyboardMarkup?
        /** InputMessageContent | Optional. Content of the message to be sent instead of the video */
        public let input_message_content: InputMessageContent?
        public init(type: String ,id: String ,video_file_id: String ,title: String ,description: String? = nil ,caption: String? = nil ,parse_mode: String? = nil ,caption_entities: Array<MessageEntity>? = nil ,show_caption_above_media: Bool? = nil ,reply_markup: InlineKeyboardMarkup? = nil ,input_message_content: InputMessageContent? = nil) {
            self.type = type
            self.id = id
            self.video_file_id = video_file_id
            self.title = title
            self.description = description
            self.caption = caption
            self.parse_mode = parse_mode
            self.caption_entities = caption_entities
            self.show_caption_above_media = show_caption_above_media
            self.reply_markup = reply_markup
            self.input_message_content = input_message_content
        }
    }
}

extension TelegramAPI {
    /**
     * https://core.telegram.org/bots/api#inlinequeryresultcachedvoice  
     * Represents a link to a voice message stored on the Telegram servers. By default, this voice message will be sent by the user. Alternatively, you can use input_message_content to send a message with the specified content instead of the voice message.
    */
    public struct InlineQueryResultCachedVoice: Codable {
        /** String | Type of the result, must be voice */
        public let type: String
        /** String | Unique identifier for this result, 1-64 bytes */
        public let id: String
        /** String | A valid file identifier for the voice message */
        public let voice_file_id: String
        /** String | Voice message title */
        public let title: String
        /** String | Optional. Caption, 0-1024 characters after entities parsing */
        public let caption: String?
        /** String | Optional. Mode for parsing entities in the voice message caption. See formatting options for more details. */
        public let parse_mode: String?
        /** Array of MessageEntity | Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode */
        public let caption_entities: Array<MessageEntity>?
        /** InlineKeyboardMarkup | Optional. Inline keyboard attached to the message */
        public let reply_markup: InlineKeyboardMarkup?
        /** InputMessageContent | Optional. Content of the message to be sent instead of the voice message */
        public let input_message_content: InputMessageContent?
        public init(type: String ,id: String ,voice_file_id: String ,title: String ,caption: String? = nil ,parse_mode: String? = nil ,caption_entities: Array<MessageEntity>? = nil ,reply_markup: InlineKeyboardMarkup? = nil ,input_message_content: InputMessageContent? = nil) {
            self.type = type
            self.id = id
            self.voice_file_id = voice_file_id
            self.title = title
            self.caption = caption
            self.parse_mode = parse_mode
            self.caption_entities = caption_entities
            self.reply_markup = reply_markup
            self.input_message_content = input_message_content
        }
    }
}

extension TelegramAPI {
    /**
     * https://core.telegram.org/bots/api#inlinequeryresultcachedaudio  
     * Represents a link to an MP3 audio file stored on the Telegram servers. By default, this audio file will be sent by the user. Alternatively, you can use input_message_content to send a message with the specified content instead of the audio.
    */
    public struct InlineQueryResultCachedAudio: Codable {
        /** String | Type of the result, must be audio */
        public let type: String
        /** String | Unique identifier for this result, 1-64 bytes */
        public let id: String
        /** String | A valid file identifier for the audio file */
        public let audio_file_id: String
        /** String | Optional. Caption, 0-1024 characters after entities parsing */
        public let caption: String?
        /** String | Optional. Mode for parsing entities in the audio caption. See formatting options for more details. */
        public let parse_mode: String?
        /** Array of MessageEntity | Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode */
        public let caption_entities: Array<MessageEntity>?
        /** InlineKeyboardMarkup | Optional. Inline keyboard attached to the message */
        public let reply_markup: InlineKeyboardMarkup?
        /** InputMessageContent | Optional. Content of the message to be sent instead of the audio */
        public let input_message_content: InputMessageContent?
        public init(type: String ,id: String ,audio_file_id: String ,caption: String? = nil ,parse_mode: String? = nil ,caption_entities: Array<MessageEntity>? = nil ,reply_markup: InlineKeyboardMarkup? = nil ,input_message_content: InputMessageContent? = nil) {
            self.type = type
            self.id = id
            self.audio_file_id = audio_file_id
            self.caption = caption
            self.parse_mode = parse_mode
            self.caption_entities = caption_entities
            self.reply_markup = reply_markup
            self.input_message_content = input_message_content
        }
    }
}

extension TelegramAPI {
    /**
     * https://core.telegram.org/bots/api#inputmessagecontent  
     * This object represents the content of a message to be sent as a result of an inline query. Telegram clients currently support the following 5 types:
     * - InputTextMessageContent
     * - InputLocationMessageContent
     * - InputVenueMessageContent
     * - InputContactMessageContent
     * - InputInvoiceMessageContent
    */
    public indirect enum InputMessageContent: Codable {
        case inputTextMessageContent(InputTextMessageContent)
        case inputLocationMessageContent(InputLocationMessageContent)
        case inputVenueMessageContent(InputVenueMessageContent)
        case inputContactMessageContent(InputContactMessageContent)
        case inputInvoiceMessageContent(InputInvoiceMessageContent)

        public init(from decoder: Decoder) throws {
            let container = try decoder.singleValueContainer()
            if let value = try? container.decode(InputTextMessageContent.self) {
                self = .inputTextMessageContent(value)
            }
            else if let value = try? container.decode(InputLocationMessageContent.self) {
                self = .inputLocationMessageContent(value)
            }
            else if let value = try? container.decode(InputVenueMessageContent.self) {
                self = .inputVenueMessageContent(value)
            }
            else if let value = try? container.decode(InputContactMessageContent.self) {
                self = .inputContactMessageContent(value)
            }
            else if let value = try? container.decode(InputInvoiceMessageContent.self) {
                self = .inputInvoiceMessageContent(value)
            }else {
                throw DecodingError.typeMismatch(InputMessageContent.self, DecodingError.Context(codingPath: decoder.codingPath, debugDescription: "Wrong type for InputMessageContent"))
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.singleValueContainer()
            switch self {
                case .inputTextMessageContent(let value):
                    try container.encode(value)
                case .inputLocationMessageContent(let value):
                    try container.encode(value)
                case .inputVenueMessageContent(let value):
                    try container.encode(value)
                case .inputContactMessageContent(let value):
                    try container.encode(value)
                case .inputInvoiceMessageContent(let value):
                    try container.encode(value)
            }
        }
    }
}

extension TelegramAPI {
    /**
     * https://core.telegram.org/bots/api#inputtextmessagecontent  
     * Represents the content of a text message to be sent as the result of an inline query.
    */
    public struct InputTextMessageContent: Codable {
        /** String | Text of the message to be sent, 1-4096 characters */
        public let message_text: String
        /** String | Optional. Mode for parsing entities in the message text. See formatting options for more details. */
        public let parse_mode: String?
        /** Array of MessageEntity | Optional. List of special entities that appear in message text, which can be specified instead of parse_mode */
        public let entities: Array<MessageEntity>?
        /** LinkPreviewOptions | Optional. Link preview generation options for the message */
        public let link_preview_options: LinkPreviewOptions?
        public init(message_text: String ,parse_mode: String? = nil ,entities: Array<MessageEntity>? = nil ,link_preview_options: LinkPreviewOptions? = nil) {
            self.message_text = message_text
            self.parse_mode = parse_mode
            self.entities = entities
            self.link_preview_options = link_preview_options
        }
    }
}

extension TelegramAPI {
    /**
     * https://core.telegram.org/bots/api#inputlocationmessagecontent  
     * Represents the content of a location message to be sent as the result of an inline query.
    */
    public struct InputLocationMessageContent: Codable {
        /** Float | Latitude of the location in degrees */
        public let latitude: Float
        /** Float | Longitude of the location in degrees */
        public let longitude: Float
        /** Float | Optional. The radius of uncertainty for the location, measured in meters; 0-1500 */
        public let horizontal_accuracy: Float?
        /** Integer | Optional. Period in seconds during which the location can be updated, should be between 60 and 86400, or 0x7FFFFFFF for live locations that can be edited indefinitely. */
        public let live_period: Int?
        /** Integer | Optional. For live locations, a direction in which the user is moving, in degrees. Must be between 1 and 360 if specified. */
        public let heading: Int?
        /** Integer | Optional. For live locations, a maximum distance for proximity alerts about approaching another chat member, in meters. Must be between 1 and 100000 if specified. */
        public let proximity_alert_radius: Int?
        public init(latitude: Float ,longitude: Float ,horizontal_accuracy: Float? = nil ,live_period: Int? = nil ,heading: Int? = nil ,proximity_alert_radius: Int? = nil) {
            self.latitude = latitude
            self.longitude = longitude
            self.horizontal_accuracy = horizontal_accuracy
            self.live_period = live_period
            self.heading = heading
            self.proximity_alert_radius = proximity_alert_radius
        }
    }
}

extension TelegramAPI {
    /**
     * https://core.telegram.org/bots/api#inputvenuemessagecontent  
     * Represents the content of a venue message to be sent as the result of an inline query.
    */
    public struct InputVenueMessageContent: Codable {
        /** Float | Latitude of the venue in degrees */
        public let latitude: Float
        /** Float | Longitude of the venue in degrees */
        public let longitude: Float
        /** String | Name of the venue */
        public let title: String
        /** String | Address of the venue */
        public let address: String
        /** String | Optional. Foursquare identifier of the venue, if known */
        public let foursquare_id: String?
        /** String | Optional. Foursquare type of the venue, if known. (For example, "arts_entertainment/default", "arts_entertainment/aquarium" or "food/icecream".) */
        public let foursquare_type: String?
        /** String | Optional. Google Places identifier of the venue */
        public let google_place_id: String?
        /** String | Optional. Google Places type of the venue. (See supported types.) */
        public let google_place_type: String?
        public init(latitude: Float ,longitude: Float ,title: String ,address: String ,foursquare_id: String? = nil ,foursquare_type: String? = nil ,google_place_id: String? = nil ,google_place_type: String? = nil) {
            self.latitude = latitude
            self.longitude = longitude
            self.title = title
            self.address = address
            self.foursquare_id = foursquare_id
            self.foursquare_type = foursquare_type
            self.google_place_id = google_place_id
            self.google_place_type = google_place_type
        }
    }
}

extension TelegramAPI {
    /**
     * https://core.telegram.org/bots/api#inputcontactmessagecontent  
     * Represents the content of a contact message to be sent as the result of an inline query.
    */
    public struct InputContactMessageContent: Codable {
        /** String | Contact's phone number */
        public let phone_number: String
        /** String | Contact's first name */
        public let first_name: String
        /** String | Optional. Contact's last name */
        public let last_name: String?
        /** String | Optional. Additional data about the contact in the form of a vCard, 0-2048 bytes */
        public let vcard: String?
        public init(phone_number: String ,first_name: String ,last_name: String? = nil ,vcard: String? = nil) {
            self.phone_number = phone_number
            self.first_name = first_name
            self.last_name = last_name
            self.vcard = vcard
        }
    }
}

extension TelegramAPI {
    /**
     * https://core.telegram.org/bots/api#inputinvoicemessagecontent  
     * Represents the content of an invoice message to be sent as the result of an inline query.
    */
    public struct InputInvoiceMessageContent: Codable {
        /** String | Product name, 1-32 characters */
        public let title: String
        /** String | Product description, 1-255 characters */
        public let description: String
        /** String | Bot-defined invoice payload, 1-128 bytes. This will not be displayed to the user, use it for your internal processes. */
        public let payload: String
        /** String | Optional. Payment provider token, obtained via @BotFather. Pass an empty string for payments in Telegram Stars. */
        public let provider_token: String?
        /** String | Three-letter ISO 4217 currency code, see more on currencies. Pass "XTR" for payments in Telegram Stars. */
        public let currency: String
        /** Array of LabeledPrice | Price breakdown, a JSON-serialized list of components (e.g. product price, tax, discount, delivery cost, delivery tax, bonus, etc.). Must contain exactly one item for payments in Telegram Stars. */
        public let prices: Array<LabeledPrice>
        /** Integer | Optional. The maximum accepted amount for tips in the smallest units of the currency (integer, not float/double). For example, for a maximum tip of US$ 1.45 pass max_tip_amount = 145. See the exp parameter in currencies.json, it shows the number of digits past the decimal point for each currency (2 for the majority of currencies). Defaults to 0. Not supported for payments in Telegram Stars. */
        public let max_tip_amount: Int?
        /** Array of Integer | Optional. A JSON-serialized array of suggested amounts of tip in the smallest units of the currency (integer, not float/double). At most 4 suggested tip amounts can be specified. The suggested tip amounts must be positive, passed in a strictly increased order and must not exceed max_tip_amount. */
        public let suggested_tip_amounts: Array<Int>?
        /** String | Optional. A JSON-serialized object for data about the invoice, which will be shared with the payment provider. A detailed description of the required fields should be provided by the payment provider. */
        public let provider_data: String?
        /** String | Optional. URL of the product photo for the invoice. Can be a photo of the goods or a marketing image for a service. */
        public let photo_url: String?
        /** Integer | Optional. Photo size in bytes */
        public let photo_size: Int?
        /** Integer | Optional. Photo width */
        public let photo_width: Int?
        /** Integer | Optional. Photo height */
        public let photo_height: Int?
        /** Boolean | Optional. Pass True if you require the user's full name to complete the order. Ignored for payments in Telegram Stars. */
        public let need_name: Bool?
        /** Boolean | Optional. Pass True if you require the user's phone number to complete the order. Ignored for payments in Telegram Stars. */
        public let need_phone_number: Bool?
        /** Boolean | Optional. Pass True if you require the user's email address to complete the order. Ignored for payments in Telegram Stars. */
        public let need_email: Bool?
        /** Boolean | Optional. Pass True if you require the user's shipping address to complete the order. Ignored for payments in Telegram Stars. */
        public let need_shipping_address: Bool?
        /** Boolean | Optional. Pass True if the user's phone number should be sent to the provider. Ignored for payments in Telegram Stars. */
        public let send_phone_number_to_provider: Bool?
        /** Boolean | Optional. Pass True if the user's email address should be sent to the provider. Ignored for payments in Telegram Stars. */
        public let send_email_to_provider: Bool?
        /** Boolean | Optional. Pass True if the final price depends on the shipping method. Ignored for payments in Telegram Stars. */
        public let is_flexible: Bool?
        public init(title: String ,description: String ,payload: String ,provider_token: String? = nil ,currency: String ,prices: Array<LabeledPrice> ,max_tip_amount: Int? = nil ,suggested_tip_amounts: Array<Int>? = nil ,provider_data: String? = nil ,photo_url: String? = nil ,photo_size: Int? = nil ,photo_width: Int? = nil ,photo_height: Int? = nil ,need_name: Bool? = nil ,need_phone_number: Bool? = nil ,need_email: Bool? = nil ,need_shipping_address: Bool? = nil ,send_phone_number_to_provider: Bool? = nil ,send_email_to_provider: Bool? = nil ,is_flexible: Bool? = nil) {
            self.title = title
            self.description = description
            self.payload = payload
            self.provider_token = provider_token
            self.currency = currency
            self.prices = prices
            self.max_tip_amount = max_tip_amount
            self.suggested_tip_amounts = suggested_tip_amounts
            self.provider_data = provider_data
            self.photo_url = photo_url
            self.photo_size = photo_size
            self.photo_width = photo_width
            self.photo_height = photo_height
            self.need_name = need_name
            self.need_phone_number = need_phone_number
            self.need_email = need_email
            self.need_shipping_address = need_shipping_address
            self.send_phone_number_to_provider = send_phone_number_to_provider
            self.send_email_to_provider = send_email_to_provider
            self.is_flexible = is_flexible
        }
    }
}

extension TelegramAPI {
    /**
     * https://core.telegram.org/bots/api#choseninlineresult  
     * Represents a result of an inline query that was chosen by the user and sent to their chat partner.
     * Note: It is necessary to enable inline feedback via @BotFather in order to receive these objects in updates.
    */
    public struct ChosenInlineResult: Codable {
        /** String | The unique identifier for the result that was chosen */
        public let result_id: String
        /** User | The user that chose the result */
        public let from: User
        /** Location | Optional. Sender location, only for bots that require user location */
        public let location: Location?
        /** String | Optional. Identifier of the sent inline message. Available only if there is an inline keyboard attached to the message. Will be also received in callback queries and can be used to edit the message. */
        public let inline_message_id: String?
        /** String | The query that was used to obtain the result */
        public let query: String
        public init(result_id: String ,from: User ,location: Location? = nil ,inline_message_id: String? = nil ,query: String) {
            self.result_id = result_id
            self.from = from
            self.location = location
            self.inline_message_id = inline_message_id
            self.query = query
        }
    }
}

extension TelegramAPI {
    /**
     * https://core.telegram.org/bots/api#sentwebappmessage  
     * Describes an inline message sent by a Web App on behalf of a user.
    */
    public struct SentWebAppMessage: Codable {
        /** String | Optional. Identifier of the sent inline message. Available only if there is an inline keyboard attached to the message. */
        public let inline_message_id: String?
        public init(inline_message_id: String? = nil) {
            self.inline_message_id = inline_message_id
        }
    }
}

extension TelegramAPI {
    /**
     * https://core.telegram.org/bots/api#preparedinlinemessage  
     * Describes an inline message to be sent by a user of a Mini App.
    */
    public struct PreparedInlineMessage: Codable {
        /** String | Unique identifier of the prepared message */
        public let id: String
        /** Integer | Expiration date of the prepared message, in Unix time. Expired prepared messages can no longer be used */
        public let expiration_date: Int
        public init(id: String ,expiration_date: Int) {
            self.id = id
            self.expiration_date = expiration_date
        }
    }
}

extension TelegramAPI {
    /**
     * https://core.telegram.org/bots/api#labeledprice  
     * This object represents a portion of the price for goods or services.
    */
    public struct LabeledPrice: Codable {
        /** String | Portion label */
        public let label: String
        /** Integer | Price of the product in the smallest units of the currency (integer, not float/double). For example, for a price of US$ 1.45 pass amount = 145. See the exp parameter in currencies.json, it shows the number of digits past the decimal point for each currency (2 for the majority of currencies). */
        public let amount: Int
        public init(label: String ,amount: Int) {
            self.label = label
            self.amount = amount
        }
    }
}

extension TelegramAPI {
    /**
     * https://core.telegram.org/bots/api#invoice  
     * This object contains basic information about an invoice.
    */
    public struct Invoice: Codable {
        /** String | Product name */
        public let title: String
        /** String | Product description */
        public let description: String
        /** String | Unique bot deep-linking parameter that can be used to generate this invoice */
        public let start_parameter: String
        /** String | Three-letter ISO 4217 currency code, or "XTR" for payments in Telegram Stars */
        public let currency: String
        /** Integer | Total price in the smallest units of the currency (integer, not float/double). For example, for a price of US$ 1.45 pass amount = 145. See the exp parameter in currencies.json, it shows the number of digits past the decimal point for each currency (2 for the majority of currencies). */
        public let total_amount: Int
        public init(title: String ,description: String ,start_parameter: String ,currency: String ,total_amount: Int) {
            self.title = title
            self.description = description
            self.start_parameter = start_parameter
            self.currency = currency
            self.total_amount = total_amount
        }
    }
}

extension TelegramAPI {
    /**
     * https://core.telegram.org/bots/api#shippingaddress  
     * This object represents a shipping address.
    */
    public struct ShippingAddress: Codable {
        /** String | Two-letter ISO 3166-1 alpha-2 country code */
        public let country_code: String
        /** String | State, if applicable */
        public let state: String
        /** String | City */
        public let city: String
        /** String | First line for the address */
        public let street_line1: String
        /** String | Second line for the address */
        public let street_line2: String
        /** String | Address post code */
        public let post_code: String
        public init(country_code: String ,state: String ,city: String ,street_line1: String ,street_line2: String ,post_code: String) {
            self.country_code = country_code
            self.state = state
            self.city = city
            self.street_line1 = street_line1
            self.street_line2 = street_line2
            self.post_code = post_code
        }
    }
}

extension TelegramAPI {
    /**
     * https://core.telegram.org/bots/api#orderinfo  
     * This object represents information about an order.
    */
    public struct OrderInfo: Codable {
        /** String | Optional. User name */
        public let name: String?
        /** String | Optional. User's phone number */
        public let phone_number: String?
        /** String | Optional. User email */
        public let email: String?
        /** ShippingAddress | Optional. User shipping address */
        public let shipping_address: ShippingAddress?
        public init(name: String? = nil ,phone_number: String? = nil ,email: String? = nil ,shipping_address: ShippingAddress? = nil) {
            self.name = name
            self.phone_number = phone_number
            self.email = email
            self.shipping_address = shipping_address
        }
    }
}

extension TelegramAPI {
    /**
     * https://core.telegram.org/bots/api#shippingoption  
     * This object represents one shipping option.
    */
    public struct ShippingOption: Codable {
        /** String | Shipping option identifier */
        public let id: String
        /** String | Option title */
        public let title: String
        /** Array of LabeledPrice | List of price portions */
        public let prices: Array<LabeledPrice>
        public init(id: String ,title: String ,prices: Array<LabeledPrice>) {
            self.id = id
            self.title = title
            self.prices = prices
        }
    }
}

extension TelegramAPI {
    /**
     * https://core.telegram.org/bots/api#successfulpayment  
     * This object contains basic information about a successful payment.
    */
    public struct SuccessfulPayment: Codable {
        /** String | Three-letter ISO 4217 currency code, or "XTR" for payments in Telegram Stars */
        public let currency: String
        /** Integer | Total price in the smallest units of the currency (integer, not float/double). For example, for a price of US$ 1.45 pass amount = 145. See the exp parameter in currencies.json, it shows the number of digits past the decimal point for each currency (2 for the majority of currencies). */
        public let total_amount: Int
        /** String | Bot-specified invoice payload */
        public let invoice_payload: String
        /** Integer | Optional. Expiration date of the subscription, in Unix time; for recurring payments only */
        public let subscription_expiration_date: Int?
        /** Boolean | Optional. True, if the payment is a recurring payment for a subscription */
        public let is_recurring: Bool?
        /** Boolean | Optional. True, if the payment is the first payment for a subscription */
        public let is_first_recurring: Bool?
        /** String | Optional. Identifier of the shipping option chosen by the user */
        public let shipping_option_id: String?
        /** OrderInfo | Optional. Order information provided by the user */
        public let order_info: OrderInfo?
        /** String | Telegram payment identifier */
        public let telegram_payment_charge_id: String
        /** String | Provider payment identifier */
        public let provider_payment_charge_id: String
        public init(currency: String ,total_amount: Int ,invoice_payload: String ,subscription_expiration_date: Int? = nil ,is_recurring: Bool? = nil ,is_first_recurring: Bool? = nil ,shipping_option_id: String? = nil ,order_info: OrderInfo? = nil ,telegram_payment_charge_id: String ,provider_payment_charge_id: String) {
            self.currency = currency
            self.total_amount = total_amount
            self.invoice_payload = invoice_payload
            self.subscription_expiration_date = subscription_expiration_date
            self.is_recurring = is_recurring
            self.is_first_recurring = is_first_recurring
            self.shipping_option_id = shipping_option_id
            self.order_info = order_info
            self.telegram_payment_charge_id = telegram_payment_charge_id
            self.provider_payment_charge_id = provider_payment_charge_id
        }
    }
}

extension TelegramAPI {
    /**
     * https://core.telegram.org/bots/api#refundedpayment  
     * This object contains basic information about a refunded payment.
    */
    public struct RefundedPayment: Codable {
        /** String | Three-letter ISO 4217 currency code, or "XTR" for payments in Telegram Stars. Currently, always "XTR" */
        public let currency: String
        /** Integer | Total refunded price in the smallest units of the currency (integer, not float/double). For example, for a price of US$ 1.45, total_amount = 145. See the exp parameter in currencies.json, it shows the number of digits past the decimal point for each currency (2 for the majority of currencies). */
        public let total_amount: Int
        /** String | Bot-specified invoice payload */
        public let invoice_payload: String
        /** String | Telegram payment identifier */
        public let telegram_payment_charge_id: String
        /** String | Optional. Provider payment identifier */
        public let provider_payment_charge_id: String?
        public init(currency: String ,total_amount: Int ,invoice_payload: String ,telegram_payment_charge_id: String ,provider_payment_charge_id: String? = nil) {
            self.currency = currency
            self.total_amount = total_amount
            self.invoice_payload = invoice_payload
            self.telegram_payment_charge_id = telegram_payment_charge_id
            self.provider_payment_charge_id = provider_payment_charge_id
        }
    }
}

extension TelegramAPI {
    /**
     * https://core.telegram.org/bots/api#shippingquery  
     * This object contains information about an incoming shipping query.
    */
    public struct ShippingQuery: Codable {
        /** String | Unique query identifier */
        public let id: String
        /** User | User who sent the query */
        public let from: User
        /** String | Bot-specified invoice payload */
        public let invoice_payload: String
        /** ShippingAddress | User specified shipping address */
        public let shipping_address: ShippingAddress
        public init(id: String ,from: User ,invoice_payload: String ,shipping_address: ShippingAddress) {
            self.id = id
            self.from = from
            self.invoice_payload = invoice_payload
            self.shipping_address = shipping_address
        }
    }
}

extension TelegramAPI {
    /**
     * https://core.telegram.org/bots/api#precheckoutquery  
     * This object contains information about an incoming pre-checkout query.
    */
    public struct PreCheckoutQuery: Codable {
        /** String | Unique query identifier */
        public let id: String
        /** User | User who sent the query */
        public let from: User
        /** String | Three-letter ISO 4217 currency code, or "XTR" for payments in Telegram Stars */
        public let currency: String
        /** Integer | Total price in the smallest units of the currency (integer, not float/double). For example, for a price of US$ 1.45 pass amount = 145. See the exp parameter in currencies.json, it shows the number of digits past the decimal point for each currency (2 for the majority of currencies). */
        public let total_amount: Int
        /** String | Bot-specified invoice payload */
        public let invoice_payload: String
        /** String | Optional. Identifier of the shipping option chosen by the user */
        public let shipping_option_id: String?
        /** OrderInfo | Optional. Order information provided by the user */
        public let order_info: OrderInfo?
        public init(id: String ,from: User ,currency: String ,total_amount: Int ,invoice_payload: String ,shipping_option_id: String? = nil ,order_info: OrderInfo? = nil) {
            self.id = id
            self.from = from
            self.currency = currency
            self.total_amount = total_amount
            self.invoice_payload = invoice_payload
            self.shipping_option_id = shipping_option_id
            self.order_info = order_info
        }
    }
}

extension TelegramAPI {
    /**
     * https://core.telegram.org/bots/api#paidmediapurchased  
     * This object contains information about a paid media purchase.
    */
    public struct PaidMediaPurchased: Codable {
        /** User | User who purchased the media */
        public let from: User
        /** String | Bot-specified paid media payload */
        public let paid_media_payload: String
        public init(from: User ,paid_media_payload: String) {
            self.from = from
            self.paid_media_payload = paid_media_payload
        }
    }
}

extension TelegramAPI {
    /**
     * https://core.telegram.org/bots/api#revenuewithdrawalstate  
     * This object describes the state of a revenue withdrawal operation. Currently, it can be one of
     * - RevenueWithdrawalStatePending
     * - RevenueWithdrawalStateSucceeded
     * - RevenueWithdrawalStateFailed
    */
    public indirect enum RevenueWithdrawalState: Codable {
        case revenueWithdrawalStatePending(RevenueWithdrawalStatePending)
        case revenueWithdrawalStateSucceeded(RevenueWithdrawalStateSucceeded)
        case revenueWithdrawalStateFailed(RevenueWithdrawalStateFailed)

        public init(from decoder: Decoder) throws {
            let container = try decoder.singleValueContainer()
            if let value = try? container.decode(RevenueWithdrawalStatePending.self) {
                self = .revenueWithdrawalStatePending(value)
            }
            else if let value = try? container.decode(RevenueWithdrawalStateSucceeded.self) {
                self = .revenueWithdrawalStateSucceeded(value)
            }
            else if let value = try? container.decode(RevenueWithdrawalStateFailed.self) {
                self = .revenueWithdrawalStateFailed(value)
            }else {
                throw DecodingError.typeMismatch(RevenueWithdrawalState.self, DecodingError.Context(codingPath: decoder.codingPath, debugDescription: "Wrong type for RevenueWithdrawalState"))
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.singleValueContainer()
            switch self {
                case .revenueWithdrawalStatePending(let value):
                    try container.encode(value)
                case .revenueWithdrawalStateSucceeded(let value):
                    try container.encode(value)
                case .revenueWithdrawalStateFailed(let value):
                    try container.encode(value)
            }
        }
    }
}

extension TelegramAPI {
    /**
     * https://core.telegram.org/bots/api#revenuewithdrawalstatepending  
     * The withdrawal is in progress.
    */
    public struct RevenueWithdrawalStatePending: Codable {
        /** String | Type of the state, always "pending" */
        public let type: String
        public init(type: String) {
            self.type = type
        }
    }
}

extension TelegramAPI {
    /**
     * https://core.telegram.org/bots/api#revenuewithdrawalstatesucceeded  
     * The withdrawal succeeded.
    */
    public struct RevenueWithdrawalStateSucceeded: Codable {
        /** String | Type of the state, always "succeeded" */
        public let type: String
        /** Integer | Date the withdrawal was completed in Unix time */
        public let date: Int
        /** String | An HTTPS URL that can be used to see transaction details */
        public let url: String
        public init(type: String ,date: Int ,url: String) {
            self.type = type
            self.date = date
            self.url = url
        }
    }
}

extension TelegramAPI {
    /**
     * https://core.telegram.org/bots/api#revenuewithdrawalstatefailed  
     * The withdrawal failed and the transaction was refunded.
    */
    public struct RevenueWithdrawalStateFailed: Codable {
        /** String | Type of the state, always "failed" */
        public let type: String
        public init(type: String) {
            self.type = type
        }
    }
}

extension TelegramAPI {
    /**
     * https://core.telegram.org/bots/api#affiliateinfo  
     * Contains information about the affiliate that received a commission via this transaction.
    */
    public struct AffiliateInfo: Codable {
        /** User | Optional. The bot or the user that received an affiliate commission if it was received by a bot or a user */
        public let affiliate_user: User?
        /** Chat | Optional. The chat that received an affiliate commission if it was received by a chat */
        public let affiliate_chat: Chat?
        /** Integer | The number of Telegram Stars received by the affiliate for each 1000 Telegram Stars received by the bot from referred users */
        public let commission_per_mille: Int
        /** Integer | Integer amount of Telegram Stars received by the affiliate from the transaction, rounded to 0; can be negative for refunds */
        public let amount: Int
        /** Integer | Optional. The number of 1/1000000000 shares of Telegram Stars received by the affiliate; from -999999999 to 999999999; can be negative for refunds */
        public let nanostar_amount: Int?
        public init(affiliate_user: User? = nil ,affiliate_chat: Chat? = nil ,commission_per_mille: Int ,amount: Int ,nanostar_amount: Int? = nil) {
            self.affiliate_user = affiliate_user
            self.affiliate_chat = affiliate_chat
            self.commission_per_mille = commission_per_mille
            self.amount = amount
            self.nanostar_amount = nanostar_amount
        }
    }
}

extension TelegramAPI {
    /**
     * https://core.telegram.org/bots/api#transactionpartner  
     * This object describes the source of a transaction, or its recipient for outgoing transactions. Currently, it can be one of
     * - TransactionPartnerUser
     * - TransactionPartnerAffiliateProgram
     * - TransactionPartnerFragment
     * - TransactionPartnerTelegramAds
     * - TransactionPartnerTelegramApi
     * - TransactionPartnerOther
    */
    public indirect enum TransactionPartner: Codable {
        case transactionPartnerUser(TransactionPartnerUser)
        case transactionPartnerAffiliateProgram(TransactionPartnerAffiliateProgram)
        case transactionPartnerFragment(TransactionPartnerFragment)
        case transactionPartnerTelegramAds(TransactionPartnerTelegramAds)
        case transactionPartnerTelegramApi(TransactionPartnerTelegramApi)
        case transactionPartnerOther(TransactionPartnerOther)

        public init(from decoder: Decoder) throws {
            let container = try decoder.singleValueContainer()
            if let value = try? container.decode(TransactionPartnerUser.self) {
                self = .transactionPartnerUser(value)
            }
            else if let value = try? container.decode(TransactionPartnerAffiliateProgram.self) {
                self = .transactionPartnerAffiliateProgram(value)
            }
            else if let value = try? container.decode(TransactionPartnerFragment.self) {
                self = .transactionPartnerFragment(value)
            }
            else if let value = try? container.decode(TransactionPartnerTelegramAds.self) {
                self = .transactionPartnerTelegramAds(value)
            }
            else if let value = try? container.decode(TransactionPartnerTelegramApi.self) {
                self = .transactionPartnerTelegramApi(value)
            }
            else if let value = try? container.decode(TransactionPartnerOther.self) {
                self = .transactionPartnerOther(value)
            }else {
                throw DecodingError.typeMismatch(TransactionPartner.self, DecodingError.Context(codingPath: decoder.codingPath, debugDescription: "Wrong type for TransactionPartner"))
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.singleValueContainer()
            switch self {
                case .transactionPartnerUser(let value):
                    try container.encode(value)
                case .transactionPartnerAffiliateProgram(let value):
                    try container.encode(value)
                case .transactionPartnerFragment(let value):
                    try container.encode(value)
                case .transactionPartnerTelegramAds(let value):
                    try container.encode(value)
                case .transactionPartnerTelegramApi(let value):
                    try container.encode(value)
                case .transactionPartnerOther(let value):
                    try container.encode(value)
            }
        }
    }
}

extension TelegramAPI {
    /**
     * https://core.telegram.org/bots/api#transactionpartneruser  
     * Describes a transaction with a user.
    */
    public struct TransactionPartnerUser: Codable {
        /** String | Type of the transaction partner, always "user" */
        public let type: String
        /** User | Information about the user */
        public let user: User
        /** AffiliateInfo | Optional. Information about the affiliate that received a commission via this transaction */
        public let affiliate: AffiliateInfo?
        /** String | Optional. Bot-specified invoice payload */
        public let invoice_payload: String?
        /** Integer | Optional. The duration of the paid subscription */
        public let subscription_period: Int?
        /** Array of PaidMedia | Optional. Information about the paid media bought by the user */
        public let paid_media: Array<PaidMedia>?
        /** String | Optional. Bot-specified paid media payload */
        public let paid_media_payload: String?
        /** Gift | Optional. The gift sent to the user by the bot */
        public let gift: Gift?
        public init(type: String ,user: User ,affiliate: AffiliateInfo? = nil ,invoice_payload: String? = nil ,subscription_period: Int? = nil ,paid_media: Array<PaidMedia>? = nil ,paid_media_payload: String? = nil ,gift: Gift? = nil) {
            self.type = type
            self.user = user
            self.affiliate = affiliate
            self.invoice_payload = invoice_payload
            self.subscription_period = subscription_period
            self.paid_media = paid_media
            self.paid_media_payload = paid_media_payload
            self.gift = gift
        }
    }
}

extension TelegramAPI {
    /**
     * https://core.telegram.org/bots/api#transactionpartneraffiliateprogram  
     * Describes the affiliate program that issued the affiliate commission received via this transaction.
    */
    public struct TransactionPartnerAffiliateProgram: Codable {
        /** String | Type of the transaction partner, always "affiliate_program" */
        public let type: String
        /** User | Optional. Information about the bot that sponsored the affiliate program */
        public let sponsor_user: User?
        /** Integer | The number of Telegram Stars received by the bot for each 1000 Telegram Stars received by the affiliate program sponsor from referred users */
        public let commission_per_mille: Int
        public init(type: String ,sponsor_user: User? = nil ,commission_per_mille: Int) {
            self.type = type
            self.sponsor_user = sponsor_user
            self.commission_per_mille = commission_per_mille
        }
    }
}

extension TelegramAPI {
    /**
     * https://core.telegram.org/bots/api#transactionpartnerfragment  
     * Describes a withdrawal transaction with Fragment.
    */
    public struct TransactionPartnerFragment: Codable {
        /** String | Type of the transaction partner, always "fragment" */
        public let type: String
        /** RevenueWithdrawalState | Optional. State of the transaction if the transaction is outgoing */
        public let withdrawal_state: RevenueWithdrawalState?
        public init(type: String ,withdrawal_state: RevenueWithdrawalState? = nil) {
            self.type = type
            self.withdrawal_state = withdrawal_state
        }
    }
}

extension TelegramAPI {
    /**
     * https://core.telegram.org/bots/api#transactionpartnertelegramads  
     * Describes a withdrawal transaction to the Telegram Ads platform.
    */
    public struct TransactionPartnerTelegramAds: Codable {
        /** String | Type of the transaction partner, always "telegram_ads" */
        public let type: String
        public init(type: String) {
            self.type = type
        }
    }
}

extension TelegramAPI {
    /**
     * https://core.telegram.org/bots/api#transactionpartnertelegramapi  
     * Describes a transaction with payment for paid broadcasting.
    */
    public struct TransactionPartnerTelegramApi: Codable {
        /** String | Type of the transaction partner, always "telegram_api" */
        public let type: String
        /** Integer | The number of successful requests that exceeded regular limits and were therefore billed */
        public let request_count: Int
        public init(type: String ,request_count: Int) {
            self.type = type
            self.request_count = request_count
        }
    }
}

extension TelegramAPI {
    /**
     * https://core.telegram.org/bots/api#transactionpartnerother  
     * Describes a transaction with an unknown source or recipient.
    */
    public struct TransactionPartnerOther: Codable {
        /** String | Type of the transaction partner, always "other" */
        public let type: String
        public init(type: String) {
            self.type = type
        }
    }
}

extension TelegramAPI {
    /**
     * https://core.telegram.org/bots/api#startransaction  
     * Describes a Telegram Star transaction.
    */
    public struct StarTransaction: Codable {
        /** String | Unique identifier of the transaction. Coincides with the identifier of the original transaction for refund transactions. Coincides with SuccessfulPayment.telegram_payment_charge_id for successful incoming payments from users. */
        public let id: String
        /** Integer | Integer amount of Telegram Stars transferred by the transaction */
        public let amount: Int
        /** Integer | Optional. The number of 1/1000000000 shares of Telegram Stars transferred by the transaction; from 0 to 999999999 */
        public let nanostar_amount: Int?
        /** Integer | Date the transaction was created in Unix time */
        public let date: Int
        /** TransactionPartner | Optional. Source of an incoming transaction (e.g., a user purchasing goods or services, Fragment refunding a failed withdrawal). Only for incoming transactions */
        public let source: TransactionPartner?
        /** TransactionPartner | Optional. Receiver of an outgoing transaction (e.g., a user for a purchase refund, Fragment for a withdrawal). Only for outgoing transactions */
        public let receiver: TransactionPartner?
        public init(id: String ,amount: Int ,nanostar_amount: Int? = nil ,date: Int ,source: TransactionPartner? = nil ,receiver: TransactionPartner? = nil) {
            self.id = id
            self.amount = amount
            self.nanostar_amount = nanostar_amount
            self.date = date
            self.source = source
            self.receiver = receiver
        }
    }
}

extension TelegramAPI {
    /**
     * https://core.telegram.org/bots/api#startransactions  
     * Contains a list of Telegram Star transactions.
    */
    public struct StarTransactions: Codable {
        /** Array of StarTransaction | The list of transactions */
        public let transactions: Array<StarTransaction>
        public init(transactions: Array<StarTransaction>) {
            self.transactions = transactions
        }
    }
}

extension TelegramAPI {
    /**
     * https://core.telegram.org/bots/api#passportdata  
     * Describes Telegram Passport data shared with the bot by the user.
    */
    public struct PassportData: Codable {
        /** Array of EncryptedPassportElement | Array with information about documents and other Telegram Passport elements that was shared with the bot */
        public let data: Array<EncryptedPassportElement>
        /** EncryptedCredentials | Encrypted credentials required to decrypt the data */
        public let credentials: EncryptedCredentials
        public init(data: Array<EncryptedPassportElement> ,credentials: EncryptedCredentials) {
            self.data = data
            self.credentials = credentials
        }
    }
}

extension TelegramAPI {
    /**
     * https://core.telegram.org/bots/api#passportfile  
     * This object represents a file uploaded to Telegram Passport. Currently all Telegram Passport files are in JPEG format when decrypted and don't exceed 10MB.
    */
    public struct PassportFile: Codable {
        /** String | Identifier for this file, which can be used to download or reuse the file */
        public let file_id: String
        /** String | Unique identifier for this file, which is supposed to be the same over time and for different bots. Can't be used to download or reuse the file. */
        public let file_unique_id: String
        /** Integer | File size in bytes */
        public let file_size: Int
        /** Integer | Unix time when the file was uploaded */
        public let file_date: Int
        public init(file_id: String ,file_unique_id: String ,file_size: Int ,file_date: Int) {
            self.file_id = file_id
            self.file_unique_id = file_unique_id
            self.file_size = file_size
            self.file_date = file_date
        }
    }
}

extension TelegramAPI {
    /**
     * https://core.telegram.org/bots/api#encryptedpassportelement  
     * Describes documents or other Telegram Passport elements shared with the bot by the user.
    */
    public struct EncryptedPassportElement: Codable {
        /** String | Element type. One of "personal_details", "passport", "driver_license", "identity_card", "internal_passport", "address", "utility_bill", "bank_statement", "rental_agreement", "passport_registration", "temporary_registration", "phone_number", "email". */
        public let type: String
        /** String | Optional. Base64-encoded encrypted Telegram Passport element data provided by the user; available only for "personal_details", "passport", "driver_license", "identity_card", "internal_passport" and "address" types. Can be decrypted and verified using the accompanying EncryptedCredentials. */
        public let data: String?
        /** String | Optional. User's verified phone number; available only for "phone_number" type */
        public let phone_number: String?
        /** String | Optional. User's verified email address; available only for "email" type */
        public let email: String?
        /** Array of PassportFile | Optional. Array of encrypted files with documents provided by the user; available only for "utility_bill", "bank_statement", "rental_agreement", "passport_registration" and "temporary_registration" types. Files can be decrypted and verified using the accompanying EncryptedCredentials. */
        public let files: Array<PassportFile>?
        /** PassportFile | Optional. Encrypted file with the front side of the document, provided by the user; available only for "passport", "driver_license", "identity_card" and "internal_passport". The file can be decrypted and verified using the accompanying EncryptedCredentials. */
        public let front_side: PassportFile?
        /** PassportFile | Optional. Encrypted file with the reverse side of the document, provided by the user; available only for "driver_license" and "identity_card". The file can be decrypted and verified using the accompanying EncryptedCredentials. */
        public let reverse_side: PassportFile?
        /** PassportFile | Optional. Encrypted file with the selfie of the user holding a document, provided by the user; available if requested for "passport", "driver_license", "identity_card" and "internal_passport". The file can be decrypted and verified using the accompanying EncryptedCredentials. */
        public let selfie: PassportFile?
        /** Array of PassportFile | Optional. Array of encrypted files with translated versions of documents provided by the user; available if requested for "passport", "driver_license", "identity_card", "internal_passport", "utility_bill", "bank_statement", "rental_agreement", "passport_registration" and "temporary_registration" types. Files can be decrypted and verified using the accompanying EncryptedCredentials. */
        public let translation: Array<PassportFile>?
        /** String | Base64-encoded element hash for using in PassportElementErrorUnspecified */
        public let hash: String
        public init(type: String ,data: String? = nil ,phone_number: String? = nil ,email: String? = nil ,files: Array<PassportFile>? = nil ,front_side: PassportFile? = nil ,reverse_side: PassportFile? = nil ,selfie: PassportFile? = nil ,translation: Array<PassportFile>? = nil ,hash: String) {
            self.type = type
            self.data = data
            self.phone_number = phone_number
            self.email = email
            self.files = files
            self.front_side = front_side
            self.reverse_side = reverse_side
            self.selfie = selfie
            self.translation = translation
            self.hash = hash
        }
    }
}

extension TelegramAPI {
    /**
     * https://core.telegram.org/bots/api#encryptedcredentials  
     * Describes data required for decrypting and authenticating EncryptedPassportElement. See the Telegram Passport Documentation for a complete description of the data decryption and authentication processes.
    */
    public struct EncryptedCredentials: Codable {
        /** String | Base64-encoded encrypted JSON-serialized data with unique user's payload, data hashes and secrets required for EncryptedPassportElement decryption and authentication */
        public let data: String
        /** String | Base64-encoded data hash for data authentication */
        public let hash: String
        /** String | Base64-encoded secret, encrypted with the bot's public RSA key, required for data decryption */
        public let secret: String
        public init(data: String ,hash: String ,secret: String) {
            self.data = data
            self.hash = hash
            self.secret = secret
        }
    }
}

extension TelegramAPI {
    /**
     * https://core.telegram.org/bots/api#passportelementerror  
     * This object represents an error in the Telegram Passport element which was submitted that should be resolved by the user. It should be one of:
     * - PassportElementErrorDataField
     * - PassportElementErrorFrontSide
     * - PassportElementErrorReverseSide
     * - PassportElementErrorSelfie
     * - PassportElementErrorFile
     * - PassportElementErrorFiles
     * - PassportElementErrorTranslationFile
     * - PassportElementErrorTranslationFiles
     * - PassportElementErrorUnspecified
    */
    public indirect enum PassportElementError: Codable {
        case passportElementErrorDataField(PassportElementErrorDataField)
        case passportElementErrorFrontSide(PassportElementErrorFrontSide)
        case passportElementErrorReverseSide(PassportElementErrorReverseSide)
        case passportElementErrorSelfie(PassportElementErrorSelfie)
        case passportElementErrorFile(PassportElementErrorFile)
        case passportElementErrorFiles(PassportElementErrorFiles)
        case passportElementErrorTranslationFile(PassportElementErrorTranslationFile)
        case passportElementErrorTranslationFiles(PassportElementErrorTranslationFiles)
        case passportElementErrorUnspecified(PassportElementErrorUnspecified)

        public init(from decoder: Decoder) throws {
            let container = try decoder.singleValueContainer()
            if let value = try? container.decode(PassportElementErrorDataField.self) {
                self = .passportElementErrorDataField(value)
            }
            else if let value = try? container.decode(PassportElementErrorFrontSide.self) {
                self = .passportElementErrorFrontSide(value)
            }
            else if let value = try? container.decode(PassportElementErrorReverseSide.self) {
                self = .passportElementErrorReverseSide(value)
            }
            else if let value = try? container.decode(PassportElementErrorSelfie.self) {
                self = .passportElementErrorSelfie(value)
            }
            else if let value = try? container.decode(PassportElementErrorFile.self) {
                self = .passportElementErrorFile(value)
            }
            else if let value = try? container.decode(PassportElementErrorFiles.self) {
                self = .passportElementErrorFiles(value)
            }
            else if let value = try? container.decode(PassportElementErrorTranslationFile.self) {
                self = .passportElementErrorTranslationFile(value)
            }
            else if let value = try? container.decode(PassportElementErrorTranslationFiles.self) {
                self = .passportElementErrorTranslationFiles(value)
            }
            else if let value = try? container.decode(PassportElementErrorUnspecified.self) {
                self = .passportElementErrorUnspecified(value)
            }else {
                throw DecodingError.typeMismatch(PassportElementError.self, DecodingError.Context(codingPath: decoder.codingPath, debugDescription: "Wrong type for PassportElementError"))
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.singleValueContainer()
            switch self {
                case .passportElementErrorDataField(let value):
                    try container.encode(value)
                case .passportElementErrorFrontSide(let value):
                    try container.encode(value)
                case .passportElementErrorReverseSide(let value):
                    try container.encode(value)
                case .passportElementErrorSelfie(let value):
                    try container.encode(value)
                case .passportElementErrorFile(let value):
                    try container.encode(value)
                case .passportElementErrorFiles(let value):
                    try container.encode(value)
                case .passportElementErrorTranslationFile(let value):
                    try container.encode(value)
                case .passportElementErrorTranslationFiles(let value):
                    try container.encode(value)
                case .passportElementErrorUnspecified(let value):
                    try container.encode(value)
            }
        }
    }
}

extension TelegramAPI {
    /**
     * https://core.telegram.org/bots/api#passportelementerrordatafield  
     * Represents an issue in one of the data fields that was provided by the user. The error is considered resolved when the field's value changes.
    */
    public struct PassportElementErrorDataField: Codable {
        /** String | Error source, must be data */
        public let source: String
        /** String | The section of the user's Telegram Passport which has the error, one of "personal_details", "passport", "driver_license", "identity_card", "internal_passport", "address" */
        public let type: String
        /** String | Name of the data field which has the error */
        public let field_name: String
        /** String | Base64-encoded data hash */
        public let data_hash: String
        /** String | Error message */
        public let message: String
        public init(source: String ,type: String ,field_name: String ,data_hash: String ,message: String) {
            self.source = source
            self.type = type
            self.field_name = field_name
            self.data_hash = data_hash
            self.message = message
        }
    }
}

extension TelegramAPI {
    /**
     * https://core.telegram.org/bots/api#passportelementerrorfrontside  
     * Represents an issue with the front side of a document. The error is considered resolved when the file with the front side of the document changes.
    */
    public struct PassportElementErrorFrontSide: Codable {
        /** String | Error source, must be front_side */
        public let source: String
        /** String | The section of the user's Telegram Passport which has the issue, one of "passport", "driver_license", "identity_card", "internal_passport" */
        public let type: String
        /** String | Base64-encoded hash of the file with the front side of the document */
        public let file_hash: String
        /** String | Error message */
        public let message: String
        public init(source: String ,type: String ,file_hash: String ,message: String) {
            self.source = source
            self.type = type
            self.file_hash = file_hash
            self.message = message
        }
    }
}

extension TelegramAPI {
    /**
     * https://core.telegram.org/bots/api#passportelementerrorreverseside  
     * Represents an issue with the reverse side of a document. The error is considered resolved when the file with reverse side of the document changes.
    */
    public struct PassportElementErrorReverseSide: Codable {
        /** String | Error source, must be reverse_side */
        public let source: String
        /** String | The section of the user's Telegram Passport which has the issue, one of "driver_license", "identity_card" */
        public let type: String
        /** String | Base64-encoded hash of the file with the reverse side of the document */
        public let file_hash: String
        /** String | Error message */
        public let message: String
        public init(source: String ,type: String ,file_hash: String ,message: String) {
            self.source = source
            self.type = type
            self.file_hash = file_hash
            self.message = message
        }
    }
}

extension TelegramAPI {
    /**
     * https://core.telegram.org/bots/api#passportelementerrorselfie  
     * Represents an issue with the selfie with a document. The error is considered resolved when the file with the selfie changes.
    */
    public struct PassportElementErrorSelfie: Codable {
        /** String | Error source, must be selfie */
        public let source: String
        /** String | The section of the user's Telegram Passport which has the issue, one of "passport", "driver_license", "identity_card", "internal_passport" */
        public let type: String
        /** String | Base64-encoded hash of the file with the selfie */
        public let file_hash: String
        /** String | Error message */
        public let message: String
        public init(source: String ,type: String ,file_hash: String ,message: String) {
            self.source = source
            self.type = type
            self.file_hash = file_hash
            self.message = message
        }
    }
}

extension TelegramAPI {
    /**
     * https://core.telegram.org/bots/api#passportelementerrorfile  
     * Represents an issue with a document scan. The error is considered resolved when the file with the document scan changes.
    */
    public struct PassportElementErrorFile: Codable {
        /** String | Error source, must be file */
        public let source: String
        /** String | The section of the user's Telegram Passport which has the issue, one of "utility_bill", "bank_statement", "rental_agreement", "passport_registration", "temporary_registration" */
        public let type: String
        /** String | Base64-encoded file hash */
        public let file_hash: String
        /** String | Error message */
        public let message: String
        public init(source: String ,type: String ,file_hash: String ,message: String) {
            self.source = source
            self.type = type
            self.file_hash = file_hash
            self.message = message
        }
    }
}

extension TelegramAPI {
    /**
     * https://core.telegram.org/bots/api#passportelementerrorfiles  
     * Represents an issue with a list of scans. The error is considered resolved when the list of files containing the scans changes.
    */
    public struct PassportElementErrorFiles: Codable {
        /** String | Error source, must be files */
        public let source: String
        /** String | The section of the user's Telegram Passport which has the issue, one of "utility_bill", "bank_statement", "rental_agreement", "passport_registration", "temporary_registration" */
        public let type: String
        /** Array of String | List of base64-encoded file hashes */
        public let file_hashes: Array<String>
        /** String | Error message */
        public let message: String
        public init(source: String ,type: String ,file_hashes: Array<String> ,message: String) {
            self.source = source
            self.type = type
            self.file_hashes = file_hashes
            self.message = message
        }
    }
}

extension TelegramAPI {
    /**
     * https://core.telegram.org/bots/api#passportelementerrortranslationfile  
     * Represents an issue with one of the files that constitute the translation of a document. The error is considered resolved when the file changes.
    */
    public struct PassportElementErrorTranslationFile: Codable {
        /** String | Error source, must be translation_file */
        public let source: String
        /** String | Type of element of the user's Telegram Passport which has the issue, one of "passport", "driver_license", "identity_card", "internal_passport", "utility_bill", "bank_statement", "rental_agreement", "passport_registration", "temporary_registration" */
        public let type: String
        /** String | Base64-encoded file hash */
        public let file_hash: String
        /** String | Error message */
        public let message: String
        public init(source: String ,type: String ,file_hash: String ,message: String) {
            self.source = source
            self.type = type
            self.file_hash = file_hash
            self.message = message
        }
    }
}

extension TelegramAPI {
    /**
     * https://core.telegram.org/bots/api#passportelementerrortranslationfiles  
     * Represents an issue with the translated version of a document. The error is considered resolved when a file with the document translation change.
    */
    public struct PassportElementErrorTranslationFiles: Codable {
        /** String | Error source, must be translation_files */
        public let source: String
        /** String | Type of element of the user's Telegram Passport which has the issue, one of "passport", "driver_license", "identity_card", "internal_passport", "utility_bill", "bank_statement", "rental_agreement", "passport_registration", "temporary_registration" */
        public let type: String
        /** Array of String | List of base64-encoded file hashes */
        public let file_hashes: Array<String>
        /** String | Error message */
        public let message: String
        public init(source: String ,type: String ,file_hashes: Array<String> ,message: String) {
            self.source = source
            self.type = type
            self.file_hashes = file_hashes
            self.message = message
        }
    }
}

extension TelegramAPI {
    /**
     * https://core.telegram.org/bots/api#passportelementerrorunspecified  
     * Represents an issue in an unspecified place. The error is considered resolved when new data is added.
    */
    public struct PassportElementErrorUnspecified: Codable {
        /** String | Error source, must be unspecified */
        public let source: String
        /** String | Type of element of the user's Telegram Passport which has the issue */
        public let type: String
        /** String | Base64-encoded element hash */
        public let element_hash: String
        /** String | Error message */
        public let message: String
        public init(source: String ,type: String ,element_hash: String ,message: String) {
            self.source = source
            self.type = type
            self.element_hash = element_hash
            self.message = message
        }
    }
}

extension TelegramAPI {
    /**
     * https://core.telegram.org/bots/api#game  
     * This object represents a game. Use BotFather to create and edit games, their short names will act as unique identifiers.
    */
    public struct Game: Codable {
        /** String | Title of the game */
        public let title: String
        /** String | Description of the game */
        public let description: String
        /** Array of PhotoSize | Photo that will be displayed in the game message in chats. */
        public let photo: Array<PhotoSize>
        /** String | Optional. Brief description of the game or high scores included in the game message. Can be automatically edited to include current high scores for the game when the bot calls setGameScore, or manually edited using editMessageText. 0-4096 characters. */
        public let text: String?
        /** Array of MessageEntity | Optional. Special entities that appear in text, such as usernames, URLs, bot commands, etc. */
        public let text_entities: Array<MessageEntity>?
        /** Animation | Optional. Animation that will be displayed in the game message in chats. Upload via BotFather */
        public let animation: Animation?
        public init(title: String ,description: String ,photo: Array<PhotoSize> ,text: String? = nil ,text_entities: Array<MessageEntity>? = nil ,animation: Animation? = nil) {
            self.title = title
            self.description = description
            self.photo = photo
            self.text = text
            self.text_entities = text_entities
            self.animation = animation
        }
    }
}

extension TelegramAPI {
    /**
     * https://core.telegram.org/bots/api#callbackgame  
     * A placeholder, currently holds no information. Use BotFather to set up your game.
    */
    public struct CallbackGame: Codable {
        public init() {
        }
    }
}

extension TelegramAPI {
    /**
     * https://core.telegram.org/bots/api#gamehighscore  
     * This object represents one row of the high scores table for a game.
    */
    public struct GameHighScore: Codable {
        /** Integer | Position in high score table for the game */
        public let position: Int
        /** User | User */
        public let user: User
        /** Integer | Score */
        public let score: Int
        public init(position: Int ,user: User ,score: Int) {
            self.position = position
            self.user = user
            self.score = score
        }
    }
}
extension TelegramAPI {
    public struct ResponseSuccess<T: Codable>: Codable {
        public let ok: Bool
        public let result: T
    }

    public struct ResponseError: Codable {
        public let ok: Bool
        public let error_code: Int
        public let description: String
    }

    public typealias SuccessWithOutData = Bool
    public typealias ResponseWithOutData = ResponseSuccess<SuccessWithOutData>
    public typealias ResponseWithMessage = ResponseSuccess<Message>
}

extension TelegramAPI {
    /** https://core.telegram.org/bots/api#getupdates */
    public struct GetUpdatesParams: Codable {
        /** Integer | Identifier of the first update to be returned. Must be greater by one than the highest among the identifiers of previously received updates. By default, updates starting with the earliest unconfirmed update are returned. An update is considered confirmed as soon as getUpdates is called with an offset higher than its update_id. The negative offset can be specified to retrieve updates starting from -offset update from the end of the updates queue. All previous updates will be forgotten. */
        public let offset: Int?
        /** Integer | Limits the number of updates to be retrieved. Values between 1-100 are accepted. Defaults to 100. */
        public let limit: Int?
        /** Integer | Timeout in seconds for long polling. Defaults to 0, i.e. usual short polling. Should be positive, short polling should be used for testing purposes only. */
        public let timeout: Int?
        /** Array of String | A JSON-serialized list of the update types you want your bot to receive. For example, specify ["message", "edited_channel_post", "callback_query"] to only receive updates of these types. See Update for a complete list of available update types. Specify an empty list to receive all update types except chat_member, message_reaction, and message_reaction_count (default). If not specified, the previous setting will be used. Please note that this parameter doesn't affect updates created before the call to getUpdates, so unwanted updates may be received for a short period of time. */
        public let allowed_updates: Array<String>?
        public init(offset: Int? = nil ,limit: Int? = nil ,timeout: Int? = nil ,allowed_updates: Array<String>? = nil) {
            self.offset = offset
            self.limit = limit
            self.timeout = timeout
            self.allowed_updates = allowed_updates
        }
    }
}

extension TelegramAPI {

    public typealias GetUpdatesResponse = ResponseSuccess<Array<Update>>

    /**
     * https://core.telegram.org/bots/api#getupdates
     * Use this method to receive incoming updates using long polling (wiki). Returns an Array of Update objects.
     */
    public func getUpdates(params: GetUpdatesParams) throws -> GetUpdatesResponse {
        let data = try request("getUpdates", params)
        return try JSONDecoder().decode(GetUpdatesResponse.self, from: data)
    }
}

extension TelegramAPI {
    /** https://core.telegram.org/bots/api#setwebhook */
    public struct SetWebhookParams: Codable {
        /** String | HTTPS URL to send updates to. Use an empty string to remove webhook integration */
        public let url: String
        /** InputFile | Upload your public key certificate so that the root certificate in use can be checked. See our self-signed guide for details. */
        public let certificate: InputFile?
        /** String | The fixed IP address which will be used to send webhook requests instead of the IP address resolved through DNS */
        public let ip_address: String?
        /** Integer | The maximum allowed number of simultaneous HTTPS connections to the webhook for update delivery, 1-100. Defaults to 40. Use lower values to limit the load on your bot's server, and higher values to increase your bot's throughput. */
        public let max_connections: Int?
        /** Array of String | A JSON-serialized list of the update types you want your bot to receive. For example, specify ["message", "edited_channel_post", "callback_query"] to only receive updates of these types. See Update for a complete list of available update types. Specify an empty list to receive all update types except chat_member, message_reaction, and message_reaction_count (default). If not specified, the previous setting will be used. Please note that this parameter doesn't affect updates created before the call to the setWebhook, so unwanted updates may be received for a short period of time. */
        public let allowed_updates: Array<String>?
        /** Boolean | Pass True to drop all pending updates */
        public let drop_pending_updates: Bool?
        /** String | A secret token to be sent in a header "X-Telegram-Bot-Api-Secret-Token" in every webhook request, 1-256 characters. Only characters A-Z, a-z, 0-9, _ and - are allowed. The header is useful to ensure that the request comes from a webhook set by you. */
        public let secret_token: String?
        public init(url: String ,certificate: InputFile? = nil ,ip_address: String? = nil ,max_connections: Int? = nil ,allowed_updates: Array<String>? = nil ,drop_pending_updates: Bool? = nil ,secret_token: String? = nil) {
            self.url = url
            self.certificate = certificate
            self.ip_address = ip_address
            self.max_connections = max_connections
            self.allowed_updates = allowed_updates
            self.drop_pending_updates = drop_pending_updates
            self.secret_token = secret_token
        }
    }
}

extension TelegramAPI {

    public typealias SetWebhookResponse = ResponseSuccess<Bool>

    /**
     * https://core.telegram.org/bots/api#setwebhook
     * Use this method to specify a URL and receive incoming updates via an outgoing webhook. Whenever there is an update for the bot, we will send an HTTPS POST request to the specified URL, containing a JSON-serialized Update. In case of an unsuccessful request (a request with response HTTP status code different from 2XY), we will repeat the request and give up after a reasonable amount of attempts. Returns True on success.
     * If you'd like to make sure that the webhook was set by you, you can specify secret data in the parameter secret_token. If specified, the request will contain a header "X-Telegram-Bot-Api-Secret-Token" with the secret token as content.
     */
    public func setWebhook(params: SetWebhookParams) throws -> SetWebhookResponse {
        let data = try request("setWebhook", params)
        return try JSONDecoder().decode(SetWebhookResponse.self, from: data)
    }
}

extension TelegramAPI {
    /** https://core.telegram.org/bots/api#deletewebhook */
    public struct DeleteWebhookParams: Codable {
        /** Boolean | Pass True to drop all pending updates */
        public let drop_pending_updates: Bool?
        public init(drop_pending_updates: Bool? = nil) {
            self.drop_pending_updates = drop_pending_updates
        }
    }
}

extension TelegramAPI {

    public typealias DeleteWebhookResponse = ResponseSuccess<Bool>

    /**
     * https://core.telegram.org/bots/api#deletewebhook
     * Use this method to remove webhook integration if you decide to switch back to getUpdates. Returns True on success.
     */
    public func deleteWebhook(params: DeleteWebhookParams) throws -> DeleteWebhookResponse {
        let data = try request("deleteWebhook", params)
        return try JSONDecoder().decode(DeleteWebhookResponse.self, from: data)
    }
}

extension TelegramAPI {

    public typealias GetWebhookInfoResponse = ResponseSuccess<WebhookInfo>

    /**
     * https://core.telegram.org/bots/api#getwebhookinfo
     * Use this method to get current webhook status. Requires no parameters. On success, returns a WebhookInfo object. If the bot is using getUpdates, will return an object with the url field empty.
     */
    public func getWebhookInfo() throws -> GetWebhookInfoResponse {
        let data = try request("getWebhookInfo", [String: String]())
        return try JSONDecoder().decode(GetWebhookInfoResponse.self, from: data)
    }
}

extension TelegramAPI {

    public typealias GetMeResponse = ResponseSuccess<User>

    /**
     * https://core.telegram.org/bots/api#getme
     * A simple method for testing your bot's authentication token. Requires no parameters. Returns basic information about the bot in form of a User object.
     */
    public func getMe() throws -> GetMeResponse {
        let data = try request("getMe", [String: String]())
        return try JSONDecoder().decode(GetMeResponse.self, from: data)
    }
}

extension TelegramAPI {

    public typealias LogOutResponse = ResponseSuccess<Bool>

    /**
     * https://core.telegram.org/bots/api#logout
     * Use this method to log out from the cloud Bot API server before launching the bot locally. You must log out the bot before running it locally, otherwise there is no guarantee that the bot will receive updates. After a successful call, you can immediately log in on a local server, but will not be able to log in back to the cloud Bot API server for 10 minutes. Returns True on success. Requires no parameters.
     */
    public func logOut() throws -> LogOutResponse {
        let data = try request("logOut", [String: String]())
        return try JSONDecoder().decode(LogOutResponse.self, from: data)
    }
}

extension TelegramAPI {

    public typealias CloseResponse = ResponseSuccess<Bool>

    /**
     * https://core.telegram.org/bots/api#close
     * Use this method to close the bot instance before moving it from one local server to another. You need to delete the webhook before calling this method to ensure that the bot isn't launched again after server restart. The method will return error 429 in the first 10 minutes after the bot is launched. Returns True on success. Requires no parameters.
     */
    public func close() throws -> CloseResponse {
        let data = try request("close", [String: String]())
        return try JSONDecoder().decode(CloseResponse.self, from: data)
    }
}

extension TelegramAPI {
    /** https://core.telegram.org/bots/api#sendmessage */
    public struct SendMessageParams: Codable {
        /** String | Unique identifier of the business connection on behalf of which the message will be sent */
        public let business_connection_id: String?
        /** Integer or String | Unique identifier for the target chat or username of the target channel (in the format @channelusername) */
        public let chat_id: Either2<Int, String>
        /** Integer | Unique identifier for the target message thread (topic) of the forum; for forum supergroups only */
        public let message_thread_id: Int?
        /** String | Text of the message to be sent, 1-4096 characters after entities parsing */
        public let text: String
        /** ParseMode | Mode for parsing entities in the message text. See formatting options for more details. */
        public let parse_mode: ParseMode?
        /** Array of MessageEntity | A JSON-serialized list of special entities that appear in message text, which can be specified instead of parse_mode */
        public let entities: Array<MessageEntity>?
        /** LinkPreviewOptions | Link preview generation options for the message */
        public let link_preview_options: LinkPreviewOptions?
        /** Boolean | Sends the message silently. Users will receive a notification with no sound. */
        public let disable_notification: Bool?
        /** Boolean | Protects the contents of the sent message from forwarding and saving */
        public let protect_content: Bool?
        /** Boolean | Pass True to allow up to 1000 messages per second, ignoring broadcasting limits for a fee of 0.1 Telegram Stars per message. The relevant Stars will be withdrawn from the bot's balance */
        public let allow_paid_broadcast: Bool?
        /** String | Unique identifier of the message effect to be added to the message; for private chats only */
        public let message_effect_id: String?
        /** ReplyParameters | Description of the message to reply to */
        public let reply_parameters: ReplyParameters?
        /** InlineKeyboardMarkup or ReplyKeyboardMarkup or ReplyKeyboardRemove or ForceReply | Additional interface options. A JSON-serialized object for an inline keyboard, custom reply keyboard, instructions to remove a reply keyboard or to force a reply from the user */
        public let reply_markup: Either4<InlineKeyboardMarkup, ReplyKeyboardMarkup, ReplyKeyboardRemove, ForceReply>?
        public init(business_connection_id: String? = nil ,chat_id: Either2<Int, String> ,message_thread_id: Int? = nil ,text: String ,parse_mode: ParseMode? = nil ,entities: Array<MessageEntity>? = nil ,link_preview_options: LinkPreviewOptions? = nil ,disable_notification: Bool? = nil ,protect_content: Bool? = nil ,allow_paid_broadcast: Bool? = nil ,message_effect_id: String? = nil ,reply_parameters: ReplyParameters? = nil ,reply_markup: Either4<InlineKeyboardMarkup, ReplyKeyboardMarkup, ReplyKeyboardRemove, ForceReply>? = nil) {
            self.business_connection_id = business_connection_id
            self.chat_id = chat_id
            self.message_thread_id = message_thread_id
            self.text = text
            self.parse_mode = parse_mode
            self.entities = entities
            self.link_preview_options = link_preview_options
            self.disable_notification = disable_notification
            self.protect_content = protect_content
            self.allow_paid_broadcast = allow_paid_broadcast
            self.message_effect_id = message_effect_id
            self.reply_parameters = reply_parameters
            self.reply_markup = reply_markup
        }
    }
}

extension TelegramAPI {

    public typealias SendMessageResponse = ResponseSuccess<Message>

    /**
     * https://core.telegram.org/bots/api#sendmessage
     * Use this method to send text messages. On success, the sent Message is returned.
     */
    public func sendMessage(params: SendMessageParams) throws -> SendMessageResponse {
        let data = try request("sendMessage", params)
        return try JSONDecoder().decode(SendMessageResponse.self, from: data)
    }
}

extension TelegramAPI {
    /** https://core.telegram.org/bots/api#forwardmessage */
    public struct ForwardMessageParams: Codable {
        /** Integer or String | Unique identifier for the target chat or username of the target channel (in the format @channelusername) */
        public let chat_id: Either2<Int, String>
        /** Integer | Unique identifier for the target message thread (topic) of the forum; for forum supergroups only */
        public let message_thread_id: Int?
        /** Integer or String | Unique identifier for the chat where the original message was sent (or channel username in the format @channelusername) */
        public let from_chat_id: Either2<Int, String>
        /** Boolean | Sends the message silently. Users will receive a notification with no sound. */
        public let disable_notification: Bool?
        /** Boolean | Protects the contents of the forwarded message from forwarding and saving */
        public let protect_content: Bool?
        /** Integer | Message identifier in the chat specified in from_chat_id */
        public let message_id: Int
        public init(chat_id: Either2<Int, String> ,message_thread_id: Int? = nil ,from_chat_id: Either2<Int, String> ,disable_notification: Bool? = nil ,protect_content: Bool? = nil ,message_id: Int) {
            self.chat_id = chat_id
            self.message_thread_id = message_thread_id
            self.from_chat_id = from_chat_id
            self.disable_notification = disable_notification
            self.protect_content = protect_content
            self.message_id = message_id
        }
    }
}

extension TelegramAPI {

    public typealias ForwardMessageResponse = ResponseSuccess<Message>

    /**
     * https://core.telegram.org/bots/api#forwardmessage
     * Use this method to forward messages of any kind. Service messages and messages with protected content can't be forwarded. On success, the sent Message is returned.
     */
    public func forwardMessage(params: ForwardMessageParams) throws -> ForwardMessageResponse {
        let data = try request("forwardMessage", params)
        return try JSONDecoder().decode(ForwardMessageResponse.self, from: data)
    }
}

extension TelegramAPI {
    /** https://core.telegram.org/bots/api#forwardmessages */
    public struct ForwardMessagesParams: Codable {
        /** Integer or String | Unique identifier for the target chat or username of the target channel (in the format @channelusername) */
        public let chat_id: Either2<Int, String>
        /** Integer | Unique identifier for the target message thread (topic) of the forum; for forum supergroups only */
        public let message_thread_id: Int?
        /** Integer or String | Unique identifier for the chat where the original messages were sent (or channel username in the format @channelusername) */
        public let from_chat_id: Either2<Int, String>
        /** Array of Integer | A JSON-serialized list of 1-100 identifiers of messages in the chat from_chat_id to forward. The identifiers must be specified in a strictly increasing order. */
        public let message_ids: Array<Int>
        /** Boolean | Sends the messages silently. Users will receive a notification with no sound. */
        public let disable_notification: Bool?
        /** Boolean | Protects the contents of the forwarded messages from forwarding and saving */
        public let protect_content: Bool?
        public init(chat_id: Either2<Int, String> ,message_thread_id: Int? = nil ,from_chat_id: Either2<Int, String> ,message_ids: Array<Int> ,disable_notification: Bool? = nil ,protect_content: Bool? = nil) {
            self.chat_id = chat_id
            self.message_thread_id = message_thread_id
            self.from_chat_id = from_chat_id
            self.message_ids = message_ids
            self.disable_notification = disable_notification
            self.protect_content = protect_content
        }
    }
}

extension TelegramAPI {

    public typealias ForwardMessagesResponse = ResponseSuccess<Array<MessageId>>

    /**
     * https://core.telegram.org/bots/api#forwardmessages
     * Use this method to forward multiple messages of any kind. If some of the specified messages can't be found or forwarded, they are skipped. Service messages and messages with protected content can't be forwarded. Album grouping is kept for forwarded messages. On success, an array of MessageId of the sent messages is returned.
     */
    public func forwardMessages(params: ForwardMessagesParams) throws -> ForwardMessagesResponse {
        let data = try request("forwardMessages", params)
        return try JSONDecoder().decode(ForwardMessagesResponse.self, from: data)
    }
}

extension TelegramAPI {
    /** https://core.telegram.org/bots/api#copymessage */
    public struct CopyMessageParams: Codable {
        /** Integer or String | Unique identifier for the target chat or username of the target channel (in the format @channelusername) */
        public let chat_id: Either2<Int, String>
        /** Integer | Unique identifier for the target message thread (topic) of the forum; for forum supergroups only */
        public let message_thread_id: Int?
        /** Integer or String | Unique identifier for the chat where the original message was sent (or channel username in the format @channelusername) */
        public let from_chat_id: Either2<Int, String>
        /** Integer | Message identifier in the chat specified in from_chat_id */
        public let message_id: Int
        /** String | New caption for media, 0-1024 characters after entities parsing. If not specified, the original caption is kept */
        public let caption: String?
        /** String | Mode for parsing entities in the new caption. See formatting options for more details. */
        public let parse_mode: String?
        /** Array of MessageEntity | A JSON-serialized list of special entities that appear in the new caption, which can be specified instead of parse_mode */
        public let caption_entities: Array<MessageEntity>?
        /** Boolean | Pass True, if the caption must be shown above the message media. Ignored if a new caption isn't specified. */
        public let show_caption_above_media: Bool?
        /** Boolean | Sends the message silently. Users will receive a notification with no sound. */
        public let disable_notification: Bool?
        /** Boolean | Protects the contents of the sent message from forwarding and saving */
        public let protect_content: Bool?
        /** Boolean | Pass True to allow up to 1000 messages per second, ignoring broadcasting limits for a fee of 0.1 Telegram Stars per message. The relevant Stars will be withdrawn from the bot's balance */
        public let allow_paid_broadcast: Bool?
        /** ReplyParameters | Description of the message to reply to */
        public let reply_parameters: ReplyParameters?
        /** InlineKeyboardMarkup or ReplyKeyboardMarkup or ReplyKeyboardRemove or ForceReply | Additional interface options. A JSON-serialized object for an inline keyboard, custom reply keyboard, instructions to remove a reply keyboard or to force a reply from the user */
        public let reply_markup: Either4<InlineKeyboardMarkup, ReplyKeyboardMarkup, ReplyKeyboardRemove, ForceReply>?
        public init(chat_id: Either2<Int, String> ,message_thread_id: Int? = nil ,from_chat_id: Either2<Int, String> ,message_id: Int ,caption: String? = nil ,parse_mode: String? = nil ,caption_entities: Array<MessageEntity>? = nil ,show_caption_above_media: Bool? = nil ,disable_notification: Bool? = nil ,protect_content: Bool? = nil ,allow_paid_broadcast: Bool? = nil ,reply_parameters: ReplyParameters? = nil ,reply_markup: Either4<InlineKeyboardMarkup, ReplyKeyboardMarkup, ReplyKeyboardRemove, ForceReply>? = nil) {
            self.chat_id = chat_id
            self.message_thread_id = message_thread_id
            self.from_chat_id = from_chat_id
            self.message_id = message_id
            self.caption = caption
            self.parse_mode = parse_mode
            self.caption_entities = caption_entities
            self.show_caption_above_media = show_caption_above_media
            self.disable_notification = disable_notification
            self.protect_content = protect_content
            self.allow_paid_broadcast = allow_paid_broadcast
            self.reply_parameters = reply_parameters
            self.reply_markup = reply_markup
        }
    }
}

extension TelegramAPI {

    public typealias CopyMessageResponse = ResponseSuccess<MessageId>

    /**
     * https://core.telegram.org/bots/api#copymessage
     * Use this method to copy messages of any kind. Service messages, paid media messages, giveaway messages, giveaway winners messages, and invoice messages can't be copied. A quiz poll can be copied only if the value of the field correct_option_id is known to the bot. The method is analogous to the method forwardMessage, but the copied message doesn't have a link to the original message. Returns the MessageId of the sent message on success.
     */
    public func copyMessage(params: CopyMessageParams) throws -> CopyMessageResponse {
        let data = try request("copyMessage", params)
        return try JSONDecoder().decode(CopyMessageResponse.self, from: data)
    }
}

extension TelegramAPI {
    /** https://core.telegram.org/bots/api#copymessages */
    public struct CopyMessagesParams: Codable {
        /** Integer or String | Unique identifier for the target chat or username of the target channel (in the format @channelusername) */
        public let chat_id: Either2<Int, String>
        /** Integer | Unique identifier for the target message thread (topic) of the forum; for forum supergroups only */
        public let message_thread_id: Int?
        /** Integer or String | Unique identifier for the chat where the original messages were sent (or channel username in the format @channelusername) */
        public let from_chat_id: Either2<Int, String>
        /** Array of Integer | A JSON-serialized list of 1-100 identifiers of messages in the chat from_chat_id to copy. The identifiers must be specified in a strictly increasing order. */
        public let message_ids: Array<Int>
        /** Boolean | Sends the messages silently. Users will receive a notification with no sound. */
        public let disable_notification: Bool?
        /** Boolean | Protects the contents of the sent messages from forwarding and saving */
        public let protect_content: Bool?
        /** Boolean | Pass True to copy the messages without their captions */
        public let remove_caption: Bool?
        public init(chat_id: Either2<Int, String> ,message_thread_id: Int? = nil ,from_chat_id: Either2<Int, String> ,message_ids: Array<Int> ,disable_notification: Bool? = nil ,protect_content: Bool? = nil ,remove_caption: Bool? = nil) {
            self.chat_id = chat_id
            self.message_thread_id = message_thread_id
            self.from_chat_id = from_chat_id
            self.message_ids = message_ids
            self.disable_notification = disable_notification
            self.protect_content = protect_content
            self.remove_caption = remove_caption
        }
    }
}

extension TelegramAPI {

    public typealias CopyMessagesResponse = ResponseSuccess<Array<MessageId>>

    /**
     * https://core.telegram.org/bots/api#copymessages
     * Use this method to copy messages of any kind. If some of the specified messages can't be found or copied, they are skipped. Service messages, paid media messages, giveaway messages, giveaway winners messages, and invoice messages can't be copied. A quiz poll can be copied only if the value of the field correct_option_id is known to the bot. The method is analogous to the method forwardMessages, but the copied messages don't have a link to the original message. Album grouping is kept for copied messages. On success, an array of MessageId of the sent messages is returned.
     */
    public func copyMessages(params: CopyMessagesParams) throws -> CopyMessagesResponse {
        let data = try request("copyMessages", params)
        return try JSONDecoder().decode(CopyMessagesResponse.self, from: data)
    }
}

extension TelegramAPI {
    /** https://core.telegram.org/bots/api#sendphoto */
    public struct SendPhotoParams: Codable {
        /** String | Unique identifier of the business connection on behalf of which the message will be sent */
        public let business_connection_id: String?
        /** Integer or String | Unique identifier for the target chat or username of the target channel (in the format @channelusername) */
        public let chat_id: Either2<Int, String>
        /** Integer | Unique identifier for the target message thread (topic) of the forum; for forum supergroups only */
        public let message_thread_id: Int?
        /** InputFile or String | Photo to send. Pass a file_id as String to send a photo that exists on the Telegram servers (recommended), pass an HTTP URL as a String for Telegram to get a photo from the Internet, or upload a new photo using multipart/form-data. The photo must be at most 10 MB in size. The photo's width and height must not exceed 10000 in total. Width and height ratio must be at most 20. More information on Sending Files: https://core.telegram.org/bots/api#sending-files */
        public let photo: Either2<InputFile, String>
        /** String | Photo caption (may also be used when resending photos by file_id), 0-1024 characters after entities parsing */
        public let caption: String?
        /** String | Mode for parsing entities in the photo caption. See formatting options for more details. */
        public let parse_mode: String?
        /** Array of MessageEntity | A JSON-serialized list of special entities that appear in the caption, which can be specified instead of parse_mode */
        public let caption_entities: Array<MessageEntity>?
        /** Boolean | Pass True, if the caption must be shown above the message media */
        public let show_caption_above_media: Bool?
        /** Boolean | Pass True if the photo needs to be covered with a spoiler animation */
        public let has_spoiler: Bool?
        /** Boolean | Sends the message silently. Users will receive a notification with no sound. */
        public let disable_notification: Bool?
        /** Boolean | Protects the contents of the sent message from forwarding and saving */
        public let protect_content: Bool?
        /** Boolean | Pass True to allow up to 1000 messages per second, ignoring broadcasting limits for a fee of 0.1 Telegram Stars per message. The relevant Stars will be withdrawn from the bot's balance */
        public let allow_paid_broadcast: Bool?
        /** String | Unique identifier of the message effect to be added to the message; for private chats only */
        public let message_effect_id: String?
        /** ReplyParameters | Description of the message to reply to */
        public let reply_parameters: ReplyParameters?
        /** InlineKeyboardMarkup or ReplyKeyboardMarkup or ReplyKeyboardRemove or ForceReply | Additional interface options. A JSON-serialized object for an inline keyboard, custom reply keyboard, instructions to remove a reply keyboard or to force a reply from the user */
        public let reply_markup: Either4<InlineKeyboardMarkup, ReplyKeyboardMarkup, ReplyKeyboardRemove, ForceReply>?
        public init(business_connection_id: String? = nil ,chat_id: Either2<Int, String> ,message_thread_id: Int? = nil ,photo: Either2<InputFile, String> ,caption: String? = nil ,parse_mode: String? = nil ,caption_entities: Array<MessageEntity>? = nil ,show_caption_above_media: Bool? = nil ,has_spoiler: Bool? = nil ,disable_notification: Bool? = nil ,protect_content: Bool? = nil ,allow_paid_broadcast: Bool? = nil ,message_effect_id: String? = nil ,reply_parameters: ReplyParameters? = nil ,reply_markup: Either4<InlineKeyboardMarkup, ReplyKeyboardMarkup, ReplyKeyboardRemove, ForceReply>? = nil) {
            self.business_connection_id = business_connection_id
            self.chat_id = chat_id
            self.message_thread_id = message_thread_id
            self.photo = photo
            self.caption = caption
            self.parse_mode = parse_mode
            self.caption_entities = caption_entities
            self.show_caption_above_media = show_caption_above_media
            self.has_spoiler = has_spoiler
            self.disable_notification = disable_notification
            self.protect_content = protect_content
            self.allow_paid_broadcast = allow_paid_broadcast
            self.message_effect_id = message_effect_id
            self.reply_parameters = reply_parameters
            self.reply_markup = reply_markup
        }
    }
}

extension TelegramAPI {

    public typealias SendPhotoResponse = ResponseSuccess<Message>

    /**
     * https://core.telegram.org/bots/api#sendphoto
     * Use this method to send photos. On success, the sent Message is returned.
     */
    public func sendPhoto(params: SendPhotoParams) throws -> SendPhotoResponse {
        let data = try request("sendPhoto", params)
        return try JSONDecoder().decode(SendPhotoResponse.self, from: data)
    }
}

extension TelegramAPI {
    /** https://core.telegram.org/bots/api#sendaudio */
    public struct SendAudioParams: Codable {
        /** String | Unique identifier of the business connection on behalf of which the message will be sent */
        public let business_connection_id: String?
        /** Integer or String | Unique identifier for the target chat or username of the target channel (in the format @channelusername) */
        public let chat_id: Either2<Int, String>
        /** Integer | Unique identifier for the target message thread (topic) of the forum; for forum supergroups only */
        public let message_thread_id: Int?
        /** InputFile or String | Audio file to send. Pass a file_id as String to send an audio file that exists on the Telegram servers (recommended), pass an HTTP URL as a String for Telegram to get an audio file from the Internet, or upload a new one using multipart/form-data. More information on Sending Files: https://core.telegram.org/bots/api#sending-files */
        public let audio: Either2<InputFile, String>
        /** String | Audio caption, 0-1024 characters after entities parsing */
        public let caption: String?
        /** String | Mode for parsing entities in the audio caption. See formatting options for more details. */
        public let parse_mode: String?
        /** Array of MessageEntity | A JSON-serialized list of special entities that appear in the caption, which can be specified instead of parse_mode */
        public let caption_entities: Array<MessageEntity>?
        /** Integer | Duration of the audio in seconds */
        public let duration: Int?
        /** String | Performer */
        public let performer: String?
        /** String | Track name */
        public let title: String?
        /** InputFile or String | Thumbnail of the file sent; can be ignored if thumbnail generation for the file is supported server-side. The thumbnail should be in JPEG format and less than 200 kB in size. A thumbnail's width and height should not exceed 320. Ignored if the file is not uploaded using multipart/form-data. Thumbnails can't be reused and can be only uploaded as a new file, so you can pass "attach://<file_attach_name>" if the thumbnail was uploaded using multipart/form-data under <file_attach_name>. More information on Sending Files: https://core.telegram.org/bots/api#sending-files */
        public let thumbnail: Either2<InputFile, String>?
        /** Boolean | Sends the message silently. Users will receive a notification with no sound. */
        public let disable_notification: Bool?
        /** Boolean | Protects the contents of the sent message from forwarding and saving */
        public let protect_content: Bool?
        /** Boolean | Pass True to allow up to 1000 messages per second, ignoring broadcasting limits for a fee of 0.1 Telegram Stars per message. The relevant Stars will be withdrawn from the bot's balance */
        public let allow_paid_broadcast: Bool?
        /** String | Unique identifier of the message effect to be added to the message; for private chats only */
        public let message_effect_id: String?
        /** ReplyParameters | Description of the message to reply to */
        public let reply_parameters: ReplyParameters?
        /** InlineKeyboardMarkup or ReplyKeyboardMarkup or ReplyKeyboardRemove or ForceReply | Additional interface options. A JSON-serialized object for an inline keyboard, custom reply keyboard, instructions to remove a reply keyboard or to force a reply from the user */
        public let reply_markup: Either4<InlineKeyboardMarkup, ReplyKeyboardMarkup, ReplyKeyboardRemove, ForceReply>?
        public init(business_connection_id: String? = nil ,chat_id: Either2<Int, String> ,message_thread_id: Int? = nil ,audio: Either2<InputFile, String> ,caption: String? = nil ,parse_mode: String? = nil ,caption_entities: Array<MessageEntity>? = nil ,duration: Int? = nil ,performer: String? = nil ,title: String? = nil ,thumbnail: Either2<InputFile, String>? = nil ,disable_notification: Bool? = nil ,protect_content: Bool? = nil ,allow_paid_broadcast: Bool? = nil ,message_effect_id: String? = nil ,reply_parameters: ReplyParameters? = nil ,reply_markup: Either4<InlineKeyboardMarkup, ReplyKeyboardMarkup, ReplyKeyboardRemove, ForceReply>? = nil) {
            self.business_connection_id = business_connection_id
            self.chat_id = chat_id
            self.message_thread_id = message_thread_id
            self.audio = audio
            self.caption = caption
            self.parse_mode = parse_mode
            self.caption_entities = caption_entities
            self.duration = duration
            self.performer = performer
            self.title = title
            self.thumbnail = thumbnail
            self.disable_notification = disable_notification
            self.protect_content = protect_content
            self.allow_paid_broadcast = allow_paid_broadcast
            self.message_effect_id = message_effect_id
            self.reply_parameters = reply_parameters
            self.reply_markup = reply_markup
        }
    }
}

extension TelegramAPI {

    public typealias SendAudioResponse = ResponseSuccess<Message>

    /**
     * https://core.telegram.org/bots/api#sendaudio
     * Use this method to send audio files, if you want Telegram clients to display them in the music player. Your audio must be in the .MP3 or .M4A format. On success, the sent Message is returned. Bots can currently send audio files of up to 50 MB in size, this limit may be changed in the future.
     * For sending voice messages, use the sendVoice method instead.
     */
    public func sendAudio(params: SendAudioParams) throws -> SendAudioResponse {
        let data = try request("sendAudio", params)
        return try JSONDecoder().decode(SendAudioResponse.self, from: data)
    }
}

extension TelegramAPI {
    /** https://core.telegram.org/bots/api#senddocument */
    public struct SendDocumentParams: Codable {
        /** String | Unique identifier of the business connection on behalf of which the message will be sent */
        public let business_connection_id: String?
        /** Integer or String | Unique identifier for the target chat or username of the target channel (in the format @channelusername) */
        public let chat_id: Either2<Int, String>
        /** Integer | Unique identifier for the target message thread (topic) of the forum; for forum supergroups only */
        public let message_thread_id: Int?
        /** InputFile or String | File to send. Pass a file_id as String to send a file that exists on the Telegram servers (recommended), pass an HTTP URL as a String for Telegram to get a file from the Internet, or upload a new one using multipart/form-data. More information on Sending Files: https://core.telegram.org/bots/api#sending-files */
        public let document: Either2<InputFile, String>
        /** InputFile or String | Thumbnail of the file sent; can be ignored if thumbnail generation for the file is supported server-side. The thumbnail should be in JPEG format and less than 200 kB in size. A thumbnail's width and height should not exceed 320. Ignored if the file is not uploaded using multipart/form-data. Thumbnails can't be reused and can be only uploaded as a new file, so you can pass "attach://<file_attach_name>" if the thumbnail was uploaded using multipart/form-data under <file_attach_name>. More information on Sending Files: https://core.telegram.org/bots/api#sending-files */
        public let thumbnail: Either2<InputFile, String>?
        /** String | Document caption (may also be used when resending documents by file_id), 0-1024 characters after entities parsing */
        public let caption: String?
        /** String | Mode for parsing entities in the document caption. See formatting options for more details. */
        public let parse_mode: String?
        /** Array of MessageEntity | A JSON-serialized list of special entities that appear in the caption, which can be specified instead of parse_mode */
        public let caption_entities: Array<MessageEntity>?
        /** Boolean | Disables automatic server-side content type detection for files uploaded using multipart/form-data */
        public let disable_content_type_detection: Bool?
        /** Boolean | Sends the message silently. Users will receive a notification with no sound. */
        public let disable_notification: Bool?
        /** Boolean | Protects the contents of the sent message from forwarding and saving */
        public let protect_content: Bool?
        /** Boolean | Pass True to allow up to 1000 messages per second, ignoring broadcasting limits for a fee of 0.1 Telegram Stars per message. The relevant Stars will be withdrawn from the bot's balance */
        public let allow_paid_broadcast: Bool?
        /** String | Unique identifier of the message effect to be added to the message; for private chats only */
        public let message_effect_id: String?
        /** ReplyParameters | Description of the message to reply to */
        public let reply_parameters: ReplyParameters?
        /** InlineKeyboardMarkup or ReplyKeyboardMarkup or ReplyKeyboardRemove or ForceReply | Additional interface options. A JSON-serialized object for an inline keyboard, custom reply keyboard, instructions to remove a reply keyboard or to force a reply from the user */
        public let reply_markup: Either4<InlineKeyboardMarkup, ReplyKeyboardMarkup, ReplyKeyboardRemove, ForceReply>?
        public init(business_connection_id: String? = nil ,chat_id: Either2<Int, String> ,message_thread_id: Int? = nil ,document: Either2<InputFile, String> ,thumbnail: Either2<InputFile, String>? = nil ,caption: String? = nil ,parse_mode: String? = nil ,caption_entities: Array<MessageEntity>? = nil ,disable_content_type_detection: Bool? = nil ,disable_notification: Bool? = nil ,protect_content: Bool? = nil ,allow_paid_broadcast: Bool? = nil ,message_effect_id: String? = nil ,reply_parameters: ReplyParameters? = nil ,reply_markup: Either4<InlineKeyboardMarkup, ReplyKeyboardMarkup, ReplyKeyboardRemove, ForceReply>? = nil) {
            self.business_connection_id = business_connection_id
            self.chat_id = chat_id
            self.message_thread_id = message_thread_id
            self.document = document
            self.thumbnail = thumbnail
            self.caption = caption
            self.parse_mode = parse_mode
            self.caption_entities = caption_entities
            self.disable_content_type_detection = disable_content_type_detection
            self.disable_notification = disable_notification
            self.protect_content = protect_content
            self.allow_paid_broadcast = allow_paid_broadcast
            self.message_effect_id = message_effect_id
            self.reply_parameters = reply_parameters
            self.reply_markup = reply_markup
        }
    }
}

extension TelegramAPI {

    public typealias SendDocumentResponse = ResponseSuccess<Message>

    /**
     * https://core.telegram.org/bots/api#senddocument
     * Use this method to send general files. On success, the sent Message is returned. Bots can currently send files of any type of up to 50 MB in size, this limit may be changed in the future.
     */
    public func sendDocument(params: SendDocumentParams) throws -> SendDocumentResponse {
        let data = try request("sendDocument", params)
        return try JSONDecoder().decode(SendDocumentResponse.self, from: data)
    }
}

extension TelegramAPI {
    /** https://core.telegram.org/bots/api#sendvideo */
    public struct SendVideoParams: Codable {
        /** String | Unique identifier of the business connection on behalf of which the message will be sent */
        public let business_connection_id: String?
        /** Integer or String | Unique identifier for the target chat or username of the target channel (in the format @channelusername) */
        public let chat_id: Either2<Int, String>
        /** Integer | Unique identifier for the target message thread (topic) of the forum; for forum supergroups only */
        public let message_thread_id: Int?
        /** InputFile or String | Video to send. Pass a file_id as String to send a video that exists on the Telegram servers (recommended), pass an HTTP URL as a String for Telegram to get a video from the Internet, or upload a new video using multipart/form-data. More information on Sending Files: https://core.telegram.org/bots/api#sending-files */
        public let video: Either2<InputFile, String>
        /** Integer | Duration of sent video in seconds */
        public let duration: Int?
        /** Integer | Video width */
        public let width: Int?
        /** Integer | Video height */
        public let height: Int?
        /** InputFile or String | Thumbnail of the file sent; can be ignored if thumbnail generation for the file is supported server-side. The thumbnail should be in JPEG format and less than 200 kB in size. A thumbnail's width and height should not exceed 320. Ignored if the file is not uploaded using multipart/form-data. Thumbnails can't be reused and can be only uploaded as a new file, so you can pass "attach://<file_attach_name>" if the thumbnail was uploaded using multipart/form-data under <file_attach_name>. More information on Sending Files: https://core.telegram.org/bots/api#sending-files */
        public let thumbnail: Either2<InputFile, String>?
        /** String | Video caption (may also be used when resending videos by file_id), 0-1024 characters after entities parsing */
        public let caption: String?
        /** String | Mode for parsing entities in the video caption. See formatting options for more details. */
        public let parse_mode: String?
        /** Array of MessageEntity | A JSON-serialized list of special entities that appear in the caption, which can be specified instead of parse_mode */
        public let caption_entities: Array<MessageEntity>?
        /** Boolean | Pass True, if the caption must be shown above the message media */
        public let show_caption_above_media: Bool?
        /** Boolean | Pass True if the video needs to be covered with a spoiler animation */
        public let has_spoiler: Bool?
        /** Boolean | Pass True if the uploaded video is suitable for streaming */
        public let supports_streaming: Bool?
        /** Boolean | Sends the message silently. Users will receive a notification with no sound. */
        public let disable_notification: Bool?
        /** Boolean | Protects the contents of the sent message from forwarding and saving */
        public let protect_content: Bool?
        /** Boolean | Pass True to allow up to 1000 messages per second, ignoring broadcasting limits for a fee of 0.1 Telegram Stars per message. The relevant Stars will be withdrawn from the bot's balance */
        public let allow_paid_broadcast: Bool?
        /** String | Unique identifier of the message effect to be added to the message; for private chats only */
        public let message_effect_id: String?
        /** ReplyParameters | Description of the message to reply to */
        public let reply_parameters: ReplyParameters?
        /** InlineKeyboardMarkup or ReplyKeyboardMarkup or ReplyKeyboardRemove or ForceReply | Additional interface options. A JSON-serialized object for an inline keyboard, custom reply keyboard, instructions to remove a reply keyboard or to force a reply from the user */
        public let reply_markup: Either4<InlineKeyboardMarkup, ReplyKeyboardMarkup, ReplyKeyboardRemove, ForceReply>?
        public init(business_connection_id: String? = nil ,chat_id: Either2<Int, String> ,message_thread_id: Int? = nil ,video: Either2<InputFile, String> ,duration: Int? = nil ,width: Int? = nil ,height: Int? = nil ,thumbnail: Either2<InputFile, String>? = nil ,caption: String? = nil ,parse_mode: String? = nil ,caption_entities: Array<MessageEntity>? = nil ,show_caption_above_media: Bool? = nil ,has_spoiler: Bool? = nil ,supports_streaming: Bool? = nil ,disable_notification: Bool? = nil ,protect_content: Bool? = nil ,allow_paid_broadcast: Bool? = nil ,message_effect_id: String? = nil ,reply_parameters: ReplyParameters? = nil ,reply_markup: Either4<InlineKeyboardMarkup, ReplyKeyboardMarkup, ReplyKeyboardRemove, ForceReply>? = nil) {
            self.business_connection_id = business_connection_id
            self.chat_id = chat_id
            self.message_thread_id = message_thread_id
            self.video = video
            self.duration = duration
            self.width = width
            self.height = height
            self.thumbnail = thumbnail
            self.caption = caption
            self.parse_mode = parse_mode
            self.caption_entities = caption_entities
            self.show_caption_above_media = show_caption_above_media
            self.has_spoiler = has_spoiler
            self.supports_streaming = supports_streaming
            self.disable_notification = disable_notification
            self.protect_content = protect_content
            self.allow_paid_broadcast = allow_paid_broadcast
            self.message_effect_id = message_effect_id
            self.reply_parameters = reply_parameters
            self.reply_markup = reply_markup
        }
    }
}

extension TelegramAPI {

    public typealias SendVideoResponse = ResponseSuccess<Message>

    /**
     * https://core.telegram.org/bots/api#sendvideo
     * Use this method to send video files, Telegram clients support MPEG4 videos (other formats may be sent as Document). On success, the sent Message is returned. Bots can currently send video files of up to 50 MB in size, this limit may be changed in the future.
     */
    public func sendVideo(params: SendVideoParams) throws -> SendVideoResponse {
        let data = try request("sendVideo", params)
        return try JSONDecoder().decode(SendVideoResponse.self, from: data)
    }
}

extension TelegramAPI {
    /** https://core.telegram.org/bots/api#sendanimation */
    public struct SendAnimationParams: Codable {
        /** String | Unique identifier of the business connection on behalf of which the message will be sent */
        public let business_connection_id: String?
        /** Integer or String | Unique identifier for the target chat or username of the target channel (in the format @channelusername) */
        public let chat_id: Either2<Int, String>
        /** Integer | Unique identifier for the target message thread (topic) of the forum; for forum supergroups only */
        public let message_thread_id: Int?
        /** InputFile or String | Animation to send. Pass a file_id as String to send an animation that exists on the Telegram servers (recommended), pass an HTTP URL as a String for Telegram to get an animation from the Internet, or upload a new animation using multipart/form-data. More information on Sending Files: https://core.telegram.org/bots/api#sending-files */
        public let animation: Either2<InputFile, String>
        /** Integer | Duration of sent animation in seconds */
        public let duration: Int?
        /** Integer | Animation width */
        public let width: Int?
        /** Integer | Animation height */
        public let height: Int?
        /** InputFile or String | Thumbnail of the file sent; can be ignored if thumbnail generation for the file is supported server-side. The thumbnail should be in JPEG format and less than 200 kB in size. A thumbnail's width and height should not exceed 320. Ignored if the file is not uploaded using multipart/form-data. Thumbnails can't be reused and can be only uploaded as a new file, so you can pass "attach://<file_attach_name>" if the thumbnail was uploaded using multipart/form-data under <file_attach_name>. More information on Sending Files: https://core.telegram.org/bots/api#sending-files */
        public let thumbnail: Either2<InputFile, String>?
        /** String | Animation caption (may also be used when resending animation by file_id), 0-1024 characters after entities parsing */
        public let caption: String?
        /** String | Mode for parsing entities in the animation caption. See formatting options for more details. */
        public let parse_mode: String?
        /** Array of MessageEntity | A JSON-serialized list of special entities that appear in the caption, which can be specified instead of parse_mode */
        public let caption_entities: Array<MessageEntity>?
        /** Boolean | Pass True, if the caption must be shown above the message media */
        public let show_caption_above_media: Bool?
        /** Boolean | Pass True if the animation needs to be covered with a spoiler animation */
        public let has_spoiler: Bool?
        /** Boolean | Sends the message silently. Users will receive a notification with no sound. */
        public let disable_notification: Bool?
        /** Boolean | Protects the contents of the sent message from forwarding and saving */
        public let protect_content: Bool?
        /** Boolean | Pass True to allow up to 1000 messages per second, ignoring broadcasting limits for a fee of 0.1 Telegram Stars per message. The relevant Stars will be withdrawn from the bot's balance */
        public let allow_paid_broadcast: Bool?
        /** String | Unique identifier of the message effect to be added to the message; for private chats only */
        public let message_effect_id: String?
        /** ReplyParameters | Description of the message to reply to */
        public let reply_parameters: ReplyParameters?
        /** InlineKeyboardMarkup or ReplyKeyboardMarkup or ReplyKeyboardRemove or ForceReply | Additional interface options. A JSON-serialized object for an inline keyboard, custom reply keyboard, instructions to remove a reply keyboard or to force a reply from the user */
        public let reply_markup: Either4<InlineKeyboardMarkup, ReplyKeyboardMarkup, ReplyKeyboardRemove, ForceReply>?
        public init(business_connection_id: String? = nil ,chat_id: Either2<Int, String> ,message_thread_id: Int? = nil ,animation: Either2<InputFile, String> ,duration: Int? = nil ,width: Int? = nil ,height: Int? = nil ,thumbnail: Either2<InputFile, String>? = nil ,caption: String? = nil ,parse_mode: String? = nil ,caption_entities: Array<MessageEntity>? = nil ,show_caption_above_media: Bool? = nil ,has_spoiler: Bool? = nil ,disable_notification: Bool? = nil ,protect_content: Bool? = nil ,allow_paid_broadcast: Bool? = nil ,message_effect_id: String? = nil ,reply_parameters: ReplyParameters? = nil ,reply_markup: Either4<InlineKeyboardMarkup, ReplyKeyboardMarkup, ReplyKeyboardRemove, ForceReply>? = nil) {
            self.business_connection_id = business_connection_id
            self.chat_id = chat_id
            self.message_thread_id = message_thread_id
            self.animation = animation
            self.duration = duration
            self.width = width
            self.height = height
            self.thumbnail = thumbnail
            self.caption = caption
            self.parse_mode = parse_mode
            self.caption_entities = caption_entities
            self.show_caption_above_media = show_caption_above_media
            self.has_spoiler = has_spoiler
            self.disable_notification = disable_notification
            self.protect_content = protect_content
            self.allow_paid_broadcast = allow_paid_broadcast
            self.message_effect_id = message_effect_id
            self.reply_parameters = reply_parameters
            self.reply_markup = reply_markup
        }
    }
}

extension TelegramAPI {

    public typealias SendAnimationResponse = ResponseSuccess<Message>

    /**
     * https://core.telegram.org/bots/api#sendanimation
     * Use this method to send animation files (GIF or H.264/MPEG-4 AVC video without sound). On success, the sent Message is returned. Bots can currently send animation files of up to 50 MB in size, this limit may be changed in the future.
     */
    public func sendAnimation(params: SendAnimationParams) throws -> SendAnimationResponse {
        let data = try request("sendAnimation", params)
        return try JSONDecoder().decode(SendAnimationResponse.self, from: data)
    }
}

extension TelegramAPI {
    /** https://core.telegram.org/bots/api#sendvoice */
    public struct SendVoiceParams: Codable {
        /** String | Unique identifier of the business connection on behalf of which the message will be sent */
        public let business_connection_id: String?
        /** Integer or String | Unique identifier for the target chat or username of the target channel (in the format @channelusername) */
        public let chat_id: Either2<Int, String>
        /** Integer | Unique identifier for the target message thread (topic) of the forum; for forum supergroups only */
        public let message_thread_id: Int?
        /** InputFile or String | Audio file to send. Pass a file_id as String to send a file that exists on the Telegram servers (recommended), pass an HTTP URL as a String for Telegram to get a file from the Internet, or upload a new one using multipart/form-data. More information on Sending Files: https://core.telegram.org/bots/api#sending-files */
        public let voice: Either2<InputFile, String>
        /** String | Voice message caption, 0-1024 characters after entities parsing */
        public let caption: String?
        /** String | Mode for parsing entities in the voice message caption. See formatting options for more details. */
        public let parse_mode: String?
        /** Array of MessageEntity | A JSON-serialized list of special entities that appear in the caption, which can be specified instead of parse_mode */
        public let caption_entities: Array<MessageEntity>?
        /** Integer | Duration of the voice message in seconds */
        public let duration: Int?
        /** Boolean | Sends the message silently. Users will receive a notification with no sound. */
        public let disable_notification: Bool?
        /** Boolean | Protects the contents of the sent message from forwarding and saving */
        public let protect_content: Bool?
        /** Boolean | Pass True to allow up to 1000 messages per second, ignoring broadcasting limits for a fee of 0.1 Telegram Stars per message. The relevant Stars will be withdrawn from the bot's balance */
        public let allow_paid_broadcast: Bool?
        /** String | Unique identifier of the message effect to be added to the message; for private chats only */
        public let message_effect_id: String?
        /** ReplyParameters | Description of the message to reply to */
        public let reply_parameters: ReplyParameters?
        /** InlineKeyboardMarkup or ReplyKeyboardMarkup or ReplyKeyboardRemove or ForceReply | Additional interface options. A JSON-serialized object for an inline keyboard, custom reply keyboard, instructions to remove a reply keyboard or to force a reply from the user */
        public let reply_markup: Either4<InlineKeyboardMarkup, ReplyKeyboardMarkup, ReplyKeyboardRemove, ForceReply>?
        public init(business_connection_id: String? = nil ,chat_id: Either2<Int, String> ,message_thread_id: Int? = nil ,voice: Either2<InputFile, String> ,caption: String? = nil ,parse_mode: String? = nil ,caption_entities: Array<MessageEntity>? = nil ,duration: Int? = nil ,disable_notification: Bool? = nil ,protect_content: Bool? = nil ,allow_paid_broadcast: Bool? = nil ,message_effect_id: String? = nil ,reply_parameters: ReplyParameters? = nil ,reply_markup: Either4<InlineKeyboardMarkup, ReplyKeyboardMarkup, ReplyKeyboardRemove, ForceReply>? = nil) {
            self.business_connection_id = business_connection_id
            self.chat_id = chat_id
            self.message_thread_id = message_thread_id
            self.voice = voice
            self.caption = caption
            self.parse_mode = parse_mode
            self.caption_entities = caption_entities
            self.duration = duration
            self.disable_notification = disable_notification
            self.protect_content = protect_content
            self.allow_paid_broadcast = allow_paid_broadcast
            self.message_effect_id = message_effect_id
            self.reply_parameters = reply_parameters
            self.reply_markup = reply_markup
        }
    }
}

extension TelegramAPI {

    public typealias SendVoiceResponse = ResponseSuccess<Message>

    /**
     * https://core.telegram.org/bots/api#sendvoice
     * Use this method to send audio files, if you want Telegram clients to display the file as a playable voice message. For this to work, your audio must be in an .OGG file encoded with OPUS, or in .MP3 format, or in .M4A format (other formats may be sent as Audio or Document). On success, the sent Message is returned. Bots can currently send voice messages of up to 50 MB in size, this limit may be changed in the future.
     */
    public func sendVoice(params: SendVoiceParams) throws -> SendVoiceResponse {
        let data = try request("sendVoice", params)
        return try JSONDecoder().decode(SendVoiceResponse.self, from: data)
    }
}

extension TelegramAPI {
    /** https://core.telegram.org/bots/api#sendvideonote */
    public struct SendVideoNoteParams: Codable {
        /** String | Unique identifier of the business connection on behalf of which the message will be sent */
        public let business_connection_id: String?
        /** Integer or String | Unique identifier for the target chat or username of the target channel (in the format @channelusername) */
        public let chat_id: Either2<Int, String>
        /** Integer | Unique identifier for the target message thread (topic) of the forum; for forum supergroups only */
        public let message_thread_id: Int?
        /** InputFile or String | Video note to send. Pass a file_id as String to send a video note that exists on the Telegram servers (recommended) or upload a new video using multipart/form-data. More information on Sending Files: https://core.telegram.org/bots/api#sending-files. Sending video notes by a URL is currently unsupported */
        public let video_note: Either2<InputFile, String>
        /** Integer | Duration of sent video in seconds */
        public let duration: Int?
        /** Integer | Video width and height, i.e. diameter of the video message */
        public let length: Int?
        /** InputFile or String | Thumbnail of the file sent; can be ignored if thumbnail generation for the file is supported server-side. The thumbnail should be in JPEG format and less than 200 kB in size. A thumbnail's width and height should not exceed 320. Ignored if the file is not uploaded using multipart/form-data. Thumbnails can't be reused and can be only uploaded as a new file, so you can pass "attach://<file_attach_name>" if the thumbnail was uploaded using multipart/form-data under <file_attach_name>. More information on Sending Files: https://core.telegram.org/bots/api#sending-files */
        public let thumbnail: Either2<InputFile, String>?
        /** Boolean | Sends the message silently. Users will receive a notification with no sound. */
        public let disable_notification: Bool?
        /** Boolean | Protects the contents of the sent message from forwarding and saving */
        public let protect_content: Bool?
        /** Boolean | Pass True to allow up to 1000 messages per second, ignoring broadcasting limits for a fee of 0.1 Telegram Stars per message. The relevant Stars will be withdrawn from the bot's balance */
        public let allow_paid_broadcast: Bool?
        /** String | Unique identifier of the message effect to be added to the message; for private chats only */
        public let message_effect_id: String?
        /** ReplyParameters | Description of the message to reply to */
        public let reply_parameters: ReplyParameters?
        /** InlineKeyboardMarkup or ReplyKeyboardMarkup or ReplyKeyboardRemove or ForceReply | Additional interface options. A JSON-serialized object for an inline keyboard, custom reply keyboard, instructions to remove a reply keyboard or to force a reply from the user */
        public let reply_markup: Either4<InlineKeyboardMarkup, ReplyKeyboardMarkup, ReplyKeyboardRemove, ForceReply>?
        public init(business_connection_id: String? = nil ,chat_id: Either2<Int, String> ,message_thread_id: Int? = nil ,video_note: Either2<InputFile, String> ,duration: Int? = nil ,length: Int? = nil ,thumbnail: Either2<InputFile, String>? = nil ,disable_notification: Bool? = nil ,protect_content: Bool? = nil ,allow_paid_broadcast: Bool? = nil ,message_effect_id: String? = nil ,reply_parameters: ReplyParameters? = nil ,reply_markup: Either4<InlineKeyboardMarkup, ReplyKeyboardMarkup, ReplyKeyboardRemove, ForceReply>? = nil) {
            self.business_connection_id = business_connection_id
            self.chat_id = chat_id
            self.message_thread_id = message_thread_id
            self.video_note = video_note
            self.duration = duration
            self.length = length
            self.thumbnail = thumbnail
            self.disable_notification = disable_notification
            self.protect_content = protect_content
            self.allow_paid_broadcast = allow_paid_broadcast
            self.message_effect_id = message_effect_id
            self.reply_parameters = reply_parameters
            self.reply_markup = reply_markup
        }
    }
}

extension TelegramAPI {

    public typealias SendVideoNoteResponse = ResponseSuccess<Message>

    /**
     * https://core.telegram.org/bots/api#sendvideonote
     * As of v.4.0, Telegram clients support rounded square MPEG4 videos of up to 1 minute long. Use this method to send video messages. On success, the sent Message is returned.
     */
    public func sendVideoNote(params: SendVideoNoteParams) throws -> SendVideoNoteResponse {
        let data = try request("sendVideoNote", params)
        return try JSONDecoder().decode(SendVideoNoteResponse.self, from: data)
    }
}

extension TelegramAPI {
    /** https://core.telegram.org/bots/api#sendpaidmedia */
    public struct SendPaidMediaParams: Codable {
        /** String | Unique identifier of the business connection on behalf of which the message will be sent */
        public let business_connection_id: String?
        /** Integer or String | Unique identifier for the target chat or username of the target channel (in the format @channelusername). If the chat is a channel, all Telegram Star proceeds from this media will be credited to the chat's balance. Otherwise, they will be credited to the bot's balance. */
        public let chat_id: Either2<Int, String>
        /** Integer | The number of Telegram Stars that must be paid to buy access to the media; 1-2500 */
        public let star_count: Int
        /** Array of InputPaidMedia | A JSON-serialized array describing the media to be sent; up to 10 items */
        public let media: Array<InputPaidMedia>
        /** String | Bot-defined paid media payload, 0-128 bytes. This will not be displayed to the user, use it for your internal processes. */
        public let payload: String?
        /** String | Media caption, 0-1024 characters after entities parsing */
        public let caption: String?
        /** String | Mode for parsing entities in the media caption. See formatting options for more details. */
        public let parse_mode: String?
        /** Array of MessageEntity | A JSON-serialized list of special entities that appear in the caption, which can be specified instead of parse_mode */
        public let caption_entities: Array<MessageEntity>?
        /** Boolean | Pass True, if the caption must be shown above the message media */
        public let show_caption_above_media: Bool?
        /** Boolean | Sends the message silently. Users will receive a notification with no sound. */
        public let disable_notification: Bool?
        /** Boolean | Protects the contents of the sent message from forwarding and saving */
        public let protect_content: Bool?
        /** Boolean | Pass True to allow up to 1000 messages per second, ignoring broadcasting limits for a fee of 0.1 Telegram Stars per message. The relevant Stars will be withdrawn from the bot's balance */
        public let allow_paid_broadcast: Bool?
        /** ReplyParameters | Description of the message to reply to */
        public let reply_parameters: ReplyParameters?
        /** InlineKeyboardMarkup or ReplyKeyboardMarkup or ReplyKeyboardRemove or ForceReply | Additional interface options. A JSON-serialized object for an inline keyboard, custom reply keyboard, instructions to remove a reply keyboard or to force a reply from the user */
        public let reply_markup: Either4<InlineKeyboardMarkup, ReplyKeyboardMarkup, ReplyKeyboardRemove, ForceReply>?
        public init(business_connection_id: String? = nil ,chat_id: Either2<Int, String> ,star_count: Int ,media: Array<InputPaidMedia> ,payload: String? = nil ,caption: String? = nil ,parse_mode: String? = nil ,caption_entities: Array<MessageEntity>? = nil ,show_caption_above_media: Bool? = nil ,disable_notification: Bool? = nil ,protect_content: Bool? = nil ,allow_paid_broadcast: Bool? = nil ,reply_parameters: ReplyParameters? = nil ,reply_markup: Either4<InlineKeyboardMarkup, ReplyKeyboardMarkup, ReplyKeyboardRemove, ForceReply>? = nil) {
            self.business_connection_id = business_connection_id
            self.chat_id = chat_id
            self.star_count = star_count
            self.media = media
            self.payload = payload
            self.caption = caption
            self.parse_mode = parse_mode
            self.caption_entities = caption_entities
            self.show_caption_above_media = show_caption_above_media
            self.disable_notification = disable_notification
            self.protect_content = protect_content
            self.allow_paid_broadcast = allow_paid_broadcast
            self.reply_parameters = reply_parameters
            self.reply_markup = reply_markup
        }
    }
}

extension TelegramAPI {

    public typealias SendPaidMediaResponse = ResponseSuccess<Message>

    /**
     * https://core.telegram.org/bots/api#sendpaidmedia
     * Use this method to send paid media. On success, the sent Message is returned.
     */
    public func sendPaidMedia(params: SendPaidMediaParams) throws -> SendPaidMediaResponse {
        let data = try request("sendPaidMedia", params)
        return try JSONDecoder().decode(SendPaidMediaResponse.self, from: data)
    }
}

extension TelegramAPI {
    /** https://core.telegram.org/bots/api#sendmediagroup */
    public struct SendMediaGroupParams: Codable {
        /** String | Unique identifier of the business connection on behalf of which the message will be sent */
        public let business_connection_id: String?
        /** Integer or String | Unique identifier for the target chat or username of the target channel (in the format @channelusername) */
        public let chat_id: Either2<Int, String>
        /** Integer | Unique identifier for the target message thread (topic) of the forum; for forum supergroups only */
        public let message_thread_id: Int?
        /** Array of InputMediaAudio or Array of InputMediaDocument or Array of InputMediaPhoto or Array of InputMediaVideo | A JSON-serialized array describing messages to be sent, must include 2-10 items */
        public let media: Either4<Array<InputMediaAudio>, Array<InputMediaDocument>, Array<InputMediaPhoto>, Array<InputMediaVideo>>
        /** Boolean | Sends messages silently. Users will receive a notification with no sound. */
        public let disable_notification: Bool?
        /** Boolean | Protects the contents of the sent messages from forwarding and saving */
        public let protect_content: Bool?
        /** Boolean | Pass True to allow up to 1000 messages per second, ignoring broadcasting limits for a fee of 0.1 Telegram Stars per message. The relevant Stars will be withdrawn from the bot's balance */
        public let allow_paid_broadcast: Bool?
        /** String | Unique identifier of the message effect to be added to the message; for private chats only */
        public let message_effect_id: String?
        /** ReplyParameters | Description of the message to reply to */
        public let reply_parameters: ReplyParameters?
        public init(business_connection_id: String? = nil ,chat_id: Either2<Int, String> ,message_thread_id: Int? = nil ,media: Either4<Array<InputMediaAudio>, Array<InputMediaDocument>, Array<InputMediaPhoto>, Array<InputMediaVideo>> ,disable_notification: Bool? = nil ,protect_content: Bool? = nil ,allow_paid_broadcast: Bool? = nil ,message_effect_id: String? = nil ,reply_parameters: ReplyParameters? = nil) {
            self.business_connection_id = business_connection_id
            self.chat_id = chat_id
            self.message_thread_id = message_thread_id
            self.media = media
            self.disable_notification = disable_notification
            self.protect_content = protect_content
            self.allow_paid_broadcast = allow_paid_broadcast
            self.message_effect_id = message_effect_id
            self.reply_parameters = reply_parameters
        }
    }
}

extension TelegramAPI {

    public typealias SendMediaGroupResponse = ResponseSuccess<Array<Message>>

    /**
     * https://core.telegram.org/bots/api#sendmediagroup
     * Use this method to send a group of photos, videos, documents or audios as an album. Documents and audio files can be only grouped in an album with messages of the same type. On success, an array of Messages that were sent is returned.
     */
    public func sendMediaGroup(params: SendMediaGroupParams) throws -> SendMediaGroupResponse {
        let data = try request("sendMediaGroup", params)
        return try JSONDecoder().decode(SendMediaGroupResponse.self, from: data)
    }
}

extension TelegramAPI {
    /** https://core.telegram.org/bots/api#sendlocation */
    public struct SendLocationParams: Codable {
        /** String | Unique identifier of the business connection on behalf of which the message will be sent */
        public let business_connection_id: String?
        /** Integer or String | Unique identifier for the target chat or username of the target channel (in the format @channelusername) */
        public let chat_id: Either2<Int, String>
        /** Integer | Unique identifier for the target message thread (topic) of the forum; for forum supergroups only */
        public let message_thread_id: Int?
        /** Float | Latitude of the location */
        public let latitude: Float
        /** Float | Longitude of the location */
        public let longitude: Float
        /** Float | The radius of uncertainty for the location, measured in meters; 0-1500 */
        public let horizontal_accuracy: Float?
        /** Integer | Period in seconds during which the location will be updated (see Live Locations, should be between 60 and 86400, or 0x7FFFFFFF for live locations that can be edited indefinitely. */
        public let live_period: Int?
        /** Integer | For live locations, a direction in which the user is moving, in degrees. Must be between 1 and 360 if specified. */
        public let heading: Int?
        /** Integer | For live locations, a maximum distance for proximity alerts about approaching another chat member, in meters. Must be between 1 and 100000 if specified. */
        public let proximity_alert_radius: Int?
        /** Boolean | Sends the message silently. Users will receive a notification with no sound. */
        public let disable_notification: Bool?
        /** Boolean | Protects the contents of the sent message from forwarding and saving */
        public let protect_content: Bool?
        /** Boolean | Pass True to allow up to 1000 messages per second, ignoring broadcasting limits for a fee of 0.1 Telegram Stars per message. The relevant Stars will be withdrawn from the bot's balance */
        public let allow_paid_broadcast: Bool?
        /** String | Unique identifier of the message effect to be added to the message; for private chats only */
        public let message_effect_id: String?
        /** ReplyParameters | Description of the message to reply to */
        public let reply_parameters: ReplyParameters?
        /** InlineKeyboardMarkup or ReplyKeyboardMarkup or ReplyKeyboardRemove or ForceReply | Additional interface options. A JSON-serialized object for an inline keyboard, custom reply keyboard, instructions to remove a reply keyboard or to force a reply from the user */
        public let reply_markup: Either4<InlineKeyboardMarkup, ReplyKeyboardMarkup, ReplyKeyboardRemove, ForceReply>?
        public init(business_connection_id: String? = nil ,chat_id: Either2<Int, String> ,message_thread_id: Int? = nil ,latitude: Float ,longitude: Float ,horizontal_accuracy: Float? = nil ,live_period: Int? = nil ,heading: Int? = nil ,proximity_alert_radius: Int? = nil ,disable_notification: Bool? = nil ,protect_content: Bool? = nil ,allow_paid_broadcast: Bool? = nil ,message_effect_id: String? = nil ,reply_parameters: ReplyParameters? = nil ,reply_markup: Either4<InlineKeyboardMarkup, ReplyKeyboardMarkup, ReplyKeyboardRemove, ForceReply>? = nil) {
            self.business_connection_id = business_connection_id
            self.chat_id = chat_id
            self.message_thread_id = message_thread_id
            self.latitude = latitude
            self.longitude = longitude
            self.horizontal_accuracy = horizontal_accuracy
            self.live_period = live_period
            self.heading = heading
            self.proximity_alert_radius = proximity_alert_radius
            self.disable_notification = disable_notification
            self.protect_content = protect_content
            self.allow_paid_broadcast = allow_paid_broadcast
            self.message_effect_id = message_effect_id
            self.reply_parameters = reply_parameters
            self.reply_markup = reply_markup
        }
    }
}

extension TelegramAPI {

    public typealias SendLocationResponse = ResponseSuccess<Message>

    /**
     * https://core.telegram.org/bots/api#sendlocation
     * Use this method to send point on the map. On success, the sent Message is returned.
     */
    public func sendLocation(params: SendLocationParams) throws -> SendLocationResponse {
        let data = try request("sendLocation", params)
        return try JSONDecoder().decode(SendLocationResponse.self, from: data)
    }
}

extension TelegramAPI {
    /** https://core.telegram.org/bots/api#sendvenue */
    public struct SendVenueParams: Codable {
        /** String | Unique identifier of the business connection on behalf of which the message will be sent */
        public let business_connection_id: String?
        /** Integer or String | Unique identifier for the target chat or username of the target channel (in the format @channelusername) */
        public let chat_id: Either2<Int, String>
        /** Integer | Unique identifier for the target message thread (topic) of the forum; for forum supergroups only */
        public let message_thread_id: Int?
        /** Float | Latitude of the venue */
        public let latitude: Float
        /** Float | Longitude of the venue */
        public let longitude: Float
        /** String | Name of the venue */
        public let title: String
        /** String | Address of the venue */
        public let address: String
        /** String | Foursquare identifier of the venue */
        public let foursquare_id: String?
        /** String | Foursquare type of the venue, if known. (For example, "arts_entertainment/default", "arts_entertainment/aquarium" or "food/icecream".) */
        public let foursquare_type: String?
        /** String | Google Places identifier of the venue */
        public let google_place_id: String?
        /** String | Google Places type of the venue. (See supported types.) */
        public let google_place_type: String?
        /** Boolean | Sends the message silently. Users will receive a notification with no sound. */
        public let disable_notification: Bool?
        /** Boolean | Protects the contents of the sent message from forwarding and saving */
        public let protect_content: Bool?
        /** Boolean | Pass True to allow up to 1000 messages per second, ignoring broadcasting limits for a fee of 0.1 Telegram Stars per message. The relevant Stars will be withdrawn from the bot's balance */
        public let allow_paid_broadcast: Bool?
        /** String | Unique identifier of the message effect to be added to the message; for private chats only */
        public let message_effect_id: String?
        /** ReplyParameters | Description of the message to reply to */
        public let reply_parameters: ReplyParameters?
        /** InlineKeyboardMarkup or ReplyKeyboardMarkup or ReplyKeyboardRemove or ForceReply | Additional interface options. A JSON-serialized object for an inline keyboard, custom reply keyboard, instructions to remove a reply keyboard or to force a reply from the user */
        public let reply_markup: Either4<InlineKeyboardMarkup, ReplyKeyboardMarkup, ReplyKeyboardRemove, ForceReply>?
        public init(business_connection_id: String? = nil ,chat_id: Either2<Int, String> ,message_thread_id: Int? = nil ,latitude: Float ,longitude: Float ,title: String ,address: String ,foursquare_id: String? = nil ,foursquare_type: String? = nil ,google_place_id: String? = nil ,google_place_type: String? = nil ,disable_notification: Bool? = nil ,protect_content: Bool? = nil ,allow_paid_broadcast: Bool? = nil ,message_effect_id: String? = nil ,reply_parameters: ReplyParameters? = nil ,reply_markup: Either4<InlineKeyboardMarkup, ReplyKeyboardMarkup, ReplyKeyboardRemove, ForceReply>? = nil) {
            self.business_connection_id = business_connection_id
            self.chat_id = chat_id
            self.message_thread_id = message_thread_id
            self.latitude = latitude
            self.longitude = longitude
            self.title = title
            self.address = address
            self.foursquare_id = foursquare_id
            self.foursquare_type = foursquare_type
            self.google_place_id = google_place_id
            self.google_place_type = google_place_type
            self.disable_notification = disable_notification
            self.protect_content = protect_content
            self.allow_paid_broadcast = allow_paid_broadcast
            self.message_effect_id = message_effect_id
            self.reply_parameters = reply_parameters
            self.reply_markup = reply_markup
        }
    }
}

extension TelegramAPI {

    public typealias SendVenueResponse = ResponseSuccess<Message>

    /**
     * https://core.telegram.org/bots/api#sendvenue
     * Use this method to send information about a venue. On success, the sent Message is returned.
     */
    public func sendVenue(params: SendVenueParams) throws -> SendVenueResponse {
        let data = try request("sendVenue", params)
        return try JSONDecoder().decode(SendVenueResponse.self, from: data)
    }
}

extension TelegramAPI {
    /** https://core.telegram.org/bots/api#sendcontact */
    public struct SendContactParams: Codable {
        /** String | Unique identifier of the business connection on behalf of which the message will be sent */
        public let business_connection_id: String?
        /** Integer or String | Unique identifier for the target chat or username of the target channel (in the format @channelusername) */
        public let chat_id: Either2<Int, String>
        /** Integer | Unique identifier for the target message thread (topic) of the forum; for forum supergroups only */
        public let message_thread_id: Int?
        /** String | Contact's phone number */
        public let phone_number: String
        /** String | Contact's first name */
        public let first_name: String
        /** String | Contact's last name */
        public let last_name: String?
        /** String | Additional data about the contact in the form of a vCard, 0-2048 bytes */
        public let vcard: String?
        /** Boolean | Sends the message silently. Users will receive a notification with no sound. */
        public let disable_notification: Bool?
        /** Boolean | Protects the contents of the sent message from forwarding and saving */
        public let protect_content: Bool?
        /** Boolean | Pass True to allow up to 1000 messages per second, ignoring broadcasting limits for a fee of 0.1 Telegram Stars per message. The relevant Stars will be withdrawn from the bot's balance */
        public let allow_paid_broadcast: Bool?
        /** String | Unique identifier of the message effect to be added to the message; for private chats only */
        public let message_effect_id: String?
        /** ReplyParameters | Description of the message to reply to */
        public let reply_parameters: ReplyParameters?
        /** InlineKeyboardMarkup or ReplyKeyboardMarkup or ReplyKeyboardRemove or ForceReply | Additional interface options. A JSON-serialized object for an inline keyboard, custom reply keyboard, instructions to remove a reply keyboard or to force a reply from the user */
        public let reply_markup: Either4<InlineKeyboardMarkup, ReplyKeyboardMarkup, ReplyKeyboardRemove, ForceReply>?
        public init(business_connection_id: String? = nil ,chat_id: Either2<Int, String> ,message_thread_id: Int? = nil ,phone_number: String ,first_name: String ,last_name: String? = nil ,vcard: String? = nil ,disable_notification: Bool? = nil ,protect_content: Bool? = nil ,allow_paid_broadcast: Bool? = nil ,message_effect_id: String? = nil ,reply_parameters: ReplyParameters? = nil ,reply_markup: Either4<InlineKeyboardMarkup, ReplyKeyboardMarkup, ReplyKeyboardRemove, ForceReply>? = nil) {
            self.business_connection_id = business_connection_id
            self.chat_id = chat_id
            self.message_thread_id = message_thread_id
            self.phone_number = phone_number
            self.first_name = first_name
            self.last_name = last_name
            self.vcard = vcard
            self.disable_notification = disable_notification
            self.protect_content = protect_content
            self.allow_paid_broadcast = allow_paid_broadcast
            self.message_effect_id = message_effect_id
            self.reply_parameters = reply_parameters
            self.reply_markup = reply_markup
        }
    }
}

extension TelegramAPI {

    public typealias SendContactResponse = ResponseSuccess<Message>

    /**
     * https://core.telegram.org/bots/api#sendcontact
     * Use this method to send phone contacts. On success, the sent Message is returned.
     */
    public func sendContact(params: SendContactParams) throws -> SendContactResponse {
        let data = try request("sendContact", params)
        return try JSONDecoder().decode(SendContactResponse.self, from: data)
    }
}

extension TelegramAPI {
    /** https://core.telegram.org/bots/api#sendpoll */
    public struct SendPollParams: Codable {
        /** String | Unique identifier of the business connection on behalf of which the message will be sent */
        public let business_connection_id: String?
        /** Integer or String | Unique identifier for the target chat or username of the target channel (in the format @channelusername) */
        public let chat_id: Either2<Int, String>
        /** Integer | Unique identifier for the target message thread (topic) of the forum; for forum supergroups only */
        public let message_thread_id: Int?
        /** String | Poll question, 1-300 characters */
        public let question: String
        /** String | Mode for parsing entities in the question. See formatting options for more details. Currently, only custom emoji entities are allowed */
        public let question_parse_mode: String?
        /** Array of MessageEntity | A JSON-serialized list of special entities that appear in the poll question. It can be specified instead of question_parse_mode */
        public let question_entities: Array<MessageEntity>?
        /** Array of InputPollOption | A JSON-serialized list of 2-10 answer options */
        public let options: Array<InputPollOption>
        /** Boolean | True, if the poll needs to be anonymous, defaults to True */
        public let is_anonymous: Bool?
        /** String | Poll type, "quiz" or "regular", defaults to "regular" */
        public let type: String?
        /** Boolean | True, if the poll allows multiple answers, ignored for polls in quiz mode, defaults to False */
        public let allows_multiple_answers: Bool?
        /** Integer | 0-based identifier of the correct answer option, required for polls in quiz mode */
        public let correct_option_id: Int?
        /** String | Text that is shown when a user chooses an incorrect answer or taps on the lamp icon in a quiz-style poll, 0-200 characters with at most 2 line feeds after entities parsing */
        public let explanation: String?
        /** String | Mode for parsing entities in the explanation. See formatting options for more details. */
        public let explanation_parse_mode: String?
        /** Array of MessageEntity | A JSON-serialized list of special entities that appear in the poll explanation. It can be specified instead of explanation_parse_mode */
        public let explanation_entities: Array<MessageEntity>?
        /** Integer | Amount of time in seconds the poll will be active after creation, 5-600. Can't be used together with close_date. */
        public let open_period: Int?
        /** Integer | Point in time (Unix timestamp) when the poll will be automatically closed. Must be at least 5 and no more than 600 seconds in the future. Can't be used together with open_period. */
        public let close_date: Int?
        /** Boolean | Pass True if the poll needs to be immediately closed. This can be useful for poll preview. */
        public let is_closed: Bool?
        /** Boolean | Sends the message silently. Users will receive a notification with no sound. */
        public let disable_notification: Bool?
        /** Boolean | Protects the contents of the sent message from forwarding and saving */
        public let protect_content: Bool?
        /** Boolean | Pass True to allow up to 1000 messages per second, ignoring broadcasting limits for a fee of 0.1 Telegram Stars per message. The relevant Stars will be withdrawn from the bot's balance */
        public let allow_paid_broadcast: Bool?
        /** String | Unique identifier of the message effect to be added to the message; for private chats only */
        public let message_effect_id: String?
        /** ReplyParameters | Description of the message to reply to */
        public let reply_parameters: ReplyParameters?
        /** InlineKeyboardMarkup or ReplyKeyboardMarkup or ReplyKeyboardRemove or ForceReply | Additional interface options. A JSON-serialized object for an inline keyboard, custom reply keyboard, instructions to remove a reply keyboard or to force a reply from the user */
        public let reply_markup: Either4<InlineKeyboardMarkup, ReplyKeyboardMarkup, ReplyKeyboardRemove, ForceReply>?
        public init(business_connection_id: String? = nil ,chat_id: Either2<Int, String> ,message_thread_id: Int? = nil ,question: String ,question_parse_mode: String? = nil ,question_entities: Array<MessageEntity>? = nil ,options: Array<InputPollOption> ,is_anonymous: Bool? = nil ,type: String? = nil ,allows_multiple_answers: Bool? = nil ,correct_option_id: Int? = nil ,explanation: String? = nil ,explanation_parse_mode: String? = nil ,explanation_entities: Array<MessageEntity>? = nil ,open_period: Int? = nil ,close_date: Int? = nil ,is_closed: Bool? = nil ,disable_notification: Bool? = nil ,protect_content: Bool? = nil ,allow_paid_broadcast: Bool? = nil ,message_effect_id: String? = nil ,reply_parameters: ReplyParameters? = nil ,reply_markup: Either4<InlineKeyboardMarkup, ReplyKeyboardMarkup, ReplyKeyboardRemove, ForceReply>? = nil) {
            self.business_connection_id = business_connection_id
            self.chat_id = chat_id
            self.message_thread_id = message_thread_id
            self.question = question
            self.question_parse_mode = question_parse_mode
            self.question_entities = question_entities
            self.options = options
            self.is_anonymous = is_anonymous
            self.type = type
            self.allows_multiple_answers = allows_multiple_answers
            self.correct_option_id = correct_option_id
            self.explanation = explanation
            self.explanation_parse_mode = explanation_parse_mode
            self.explanation_entities = explanation_entities
            self.open_period = open_period
            self.close_date = close_date
            self.is_closed = is_closed
            self.disable_notification = disable_notification
            self.protect_content = protect_content
            self.allow_paid_broadcast = allow_paid_broadcast
            self.message_effect_id = message_effect_id
            self.reply_parameters = reply_parameters
            self.reply_markup = reply_markup
        }
    }
}

extension TelegramAPI {

    public typealias SendPollResponse = ResponseSuccess<Message>

    /**
     * https://core.telegram.org/bots/api#sendpoll
     * Use this method to send a native poll. On success, the sent Message is returned.
     */
    public func sendPoll(params: SendPollParams) throws -> SendPollResponse {
        let data = try request("sendPoll", params)
        return try JSONDecoder().decode(SendPollResponse.self, from: data)
    }
}

extension TelegramAPI {
    /** https://core.telegram.org/bots/api#senddice */
    public struct SendDiceParams: Codable {
        /** String | Unique identifier of the business connection on behalf of which the message will be sent */
        public let business_connection_id: String?
        /** Integer or String | Unique identifier for the target chat or username of the target channel (in the format @channelusername) */
        public let chat_id: Either2<Int, String>
        /** Integer | Unique identifier for the target message thread (topic) of the forum; for forum supergroups only */
        public let message_thread_id: Int?
        /** String | Emoji on which the dice throw animation is based. Currently, must be one of "", "", "", "", "", or "". Dice can have values 1-6 for "", "" and "", values 1-5 for "" and "", and values 1-64 for "". Defaults to "" */
        public let emoji: String?
        /** Boolean | Sends the message silently. Users will receive a notification with no sound. */
        public let disable_notification: Bool?
        /** Boolean | Protects the contents of the sent message from forwarding */
        public let protect_content: Bool?
        /** Boolean | Pass True to allow up to 1000 messages per second, ignoring broadcasting limits for a fee of 0.1 Telegram Stars per message. The relevant Stars will be withdrawn from the bot's balance */
        public let allow_paid_broadcast: Bool?
        /** String | Unique identifier of the message effect to be added to the message; for private chats only */
        public let message_effect_id: String?
        /** ReplyParameters | Description of the message to reply to */
        public let reply_parameters: ReplyParameters?
        /** InlineKeyboardMarkup or ReplyKeyboardMarkup or ReplyKeyboardRemove or ForceReply | Additional interface options. A JSON-serialized object for an inline keyboard, custom reply keyboard, instructions to remove a reply keyboard or to force a reply from the user */
        public let reply_markup: Either4<InlineKeyboardMarkup, ReplyKeyboardMarkup, ReplyKeyboardRemove, ForceReply>?
        public init(business_connection_id: String? = nil ,chat_id: Either2<Int, String> ,message_thread_id: Int? = nil ,emoji: String? = nil ,disable_notification: Bool? = nil ,protect_content: Bool? = nil ,allow_paid_broadcast: Bool? = nil ,message_effect_id: String? = nil ,reply_parameters: ReplyParameters? = nil ,reply_markup: Either4<InlineKeyboardMarkup, ReplyKeyboardMarkup, ReplyKeyboardRemove, ForceReply>? = nil) {
            self.business_connection_id = business_connection_id
            self.chat_id = chat_id
            self.message_thread_id = message_thread_id
            self.emoji = emoji
            self.disable_notification = disable_notification
            self.protect_content = protect_content
            self.allow_paid_broadcast = allow_paid_broadcast
            self.message_effect_id = message_effect_id
            self.reply_parameters = reply_parameters
            self.reply_markup = reply_markup
        }
    }
}

extension TelegramAPI {

    public typealias SendDiceResponse = ResponseSuccess<Message>

    /**
     * https://core.telegram.org/bots/api#senddice
     * Use this method to send an animated emoji that will display a random value. On success, the sent Message is returned.
     */
    public func sendDice(params: SendDiceParams) throws -> SendDiceResponse {
        let data = try request("sendDice", params)
        return try JSONDecoder().decode(SendDiceResponse.self, from: data)
    }
}

extension TelegramAPI {
    /** https://core.telegram.org/bots/api#sendchataction */
    public struct SendChatActionParams: Codable {
        /** String | Unique identifier of the business connection on behalf of which the action will be sent */
        public let business_connection_id: String?
        /** Integer or String | Unique identifier for the target chat or username of the target channel (in the format @channelusername) */
        public let chat_id: Either2<Int, String>
        /** Integer | Unique identifier for the target message thread; for supergroups only */
        public let message_thread_id: Int?
        /** ChatAction | Type of action to broadcast. Choose one, depending on what the user is about to receive: typing for text messages, upload_photo for photos, record_video or upload_video for videos, record_voice or upload_voice for voice notes, upload_document for general files, choose_sticker for stickers, find_location for location data, record_video_note or upload_video_note for video notes. */
        public let action: ChatAction
        public init(business_connection_id: String? = nil ,chat_id: Either2<Int, String> ,message_thread_id: Int? = nil ,action: ChatAction) {
            self.business_connection_id = business_connection_id
            self.chat_id = chat_id
            self.message_thread_id = message_thread_id
            self.action = action
        }
    }
}

extension TelegramAPI {

    public typealias SendChatActionResponse = ResponseSuccess<Bool>

    /**
     * https://core.telegram.org/bots/api#sendchataction
     * Use this method when you need to tell the user that something is happening on the bot's side. The status is set for 5 seconds or less (when a message arrives from your bot, Telegram clients clear its typing status). Returns True on success.
     * We only recommend using this method when a response from the bot will take a noticeable amount of time to arrive.
     */
    public func sendChatAction(params: SendChatActionParams) throws -> SendChatActionResponse {
        let data = try request("sendChatAction", params)
        return try JSONDecoder().decode(SendChatActionResponse.self, from: data)
    }
}

extension TelegramAPI {
    /** https://core.telegram.org/bots/api#setmessagereaction */
    public struct SetMessageReactionParams: Codable {
        /** Integer or String | Unique identifier for the target chat or username of the target channel (in the format @channelusername) */
        public let chat_id: Either2<Int, String>
        /** Integer | Identifier of the target message. If the message belongs to a media group, the reaction is set to the first non-deleted message in the group instead. */
        public let message_id: Int
        /** Array of ReactionType | A JSON-serialized list of reaction types to set on the message. Currently, as non-premium users, bots can set up to one reaction per message. A custom emoji reaction can be used if it is either already present on the message or explicitly allowed by chat administrators. Paid reactions can't be used by bots. */
        public let reaction: Array<ReactionType>?
        /** Boolean | Pass True to set the reaction with a big animation */
        public let is_big: Bool?
        public init(chat_id: Either2<Int, String> ,message_id: Int ,reaction: Array<ReactionType>? = nil ,is_big: Bool? = nil) {
            self.chat_id = chat_id
            self.message_id = message_id
            self.reaction = reaction
            self.is_big = is_big
        }
    }
}

extension TelegramAPI {

    public typealias SetMessageReactionResponse = ResponseSuccess<Bool>

    /**
     * https://core.telegram.org/bots/api#setmessagereaction
     * Use this method to change the chosen reactions on a message. Service messages can't be reacted to. Automatically forwarded messages from a channel to its discussion group have the same available reactions as messages in the channel. Bots can't use paid reactions. Returns True on success.
     */
    public func setMessageReaction(params: SetMessageReactionParams) throws -> SetMessageReactionResponse {
        let data = try request("setMessageReaction", params)
        return try JSONDecoder().decode(SetMessageReactionResponse.self, from: data)
    }
}

extension TelegramAPI {
    /** https://core.telegram.org/bots/api#getuserprofilephotos */
    public struct GetUserProfilePhotosParams: Codable {
        /** Integer | Unique identifier of the target user */
        public let user_id: Int
        /** Integer | Sequential number of the first photo to be returned. By default, all photos are returned. */
        public let offset: Int?
        /** Integer | Limits the number of photos to be retrieved. Values between 1-100 are accepted. Defaults to 100. */
        public let limit: Int?
        public init(user_id: Int ,offset: Int? = nil ,limit: Int? = nil) {
            self.user_id = user_id
            self.offset = offset
            self.limit = limit
        }
    }
}

extension TelegramAPI {

    public typealias GetUserProfilePhotosResponse = ResponseSuccess<UserProfilePhotos>

    /**
     * https://core.telegram.org/bots/api#getuserprofilephotos
     * Use this method to get a list of profile pictures for a user. Returns a UserProfilePhotos object.
     */
    public func getUserProfilePhotos(params: GetUserProfilePhotosParams) throws -> GetUserProfilePhotosResponse {
        let data = try request("getUserProfilePhotos", params)
        return try JSONDecoder().decode(GetUserProfilePhotosResponse.self, from: data)
    }
}

extension TelegramAPI {
    /** https://core.telegram.org/bots/api#setuseremojistatus */
    public struct SetUserEmojiStatusParams: Codable {
        /** Integer | Unique identifier of the target user */
        public let user_id: Int
        /** String | Custom emoji identifier of the emoji status to set. Pass an empty string to remove the status. */
        public let emoji_status_custom_emoji_id: String?
        /** Integer | Expiration date of the emoji status, if any */
        public let emoji_status_expiration_date: Int?
        public init(user_id: Int ,emoji_status_custom_emoji_id: String? = nil ,emoji_status_expiration_date: Int? = nil) {
            self.user_id = user_id
            self.emoji_status_custom_emoji_id = emoji_status_custom_emoji_id
            self.emoji_status_expiration_date = emoji_status_expiration_date
        }
    }
}

extension TelegramAPI {

    public typealias SetUserEmojiStatusResponse = ResponseSuccess<Bool>

    /**
     * https://core.telegram.org/bots/api#setuseremojistatus
     * Changes the emoji status for a given user that previously allowed the bot to manage their emoji status via the Mini App method requestEmojiStatusAccess. Returns True on success.
     */
    public func setUserEmojiStatus(params: SetUserEmojiStatusParams) throws -> SetUserEmojiStatusResponse {
        let data = try request("setUserEmojiStatus", params)
        return try JSONDecoder().decode(SetUserEmojiStatusResponse.self, from: data)
    }
}

extension TelegramAPI {
    /** https://core.telegram.org/bots/api#getfile */
    public struct GetFileParams: Codable {
        /** String | File identifier to get information about */
        public let file_id: String
        public init(file_id: String) {
            self.file_id = file_id
        }
    }
}

extension TelegramAPI {

    public typealias GetFileResponse = ResponseSuccess<File>

    /**
     * https://core.telegram.org/bots/api#getfile
     * Use this method to get basic information about a file and prepare it for downloading. For the moment, bots can download files of up to 20MB in size. On success, a File object is returned. The file can then be downloaded via the link https://api.telegram.org/file/bot<token>/<file_path>, where <file_path> is taken from the response. It is guaranteed that the link will be valid for at least 1 hour. When the link expires, a new one can be requested by calling getFile again.
     * Note: This function may not preserve the original file name and MIME type. You should save the file's MIME type and name (if available) when the File object is received.
     */
    public func getFile(params: GetFileParams) throws -> GetFileResponse {
        let data = try request("getFile", params)
        return try JSONDecoder().decode(GetFileResponse.self, from: data)
    }
}

extension TelegramAPI {
    /** https://core.telegram.org/bots/api#banchatmember */
    public struct BanChatMemberParams: Codable {
        /** Integer or String | Unique identifier for the target group or username of the target supergroup or channel (in the format @channelusername) */
        public let chat_id: Either2<Int, String>
        /** Integer | Unique identifier of the target user */
        public let user_id: Int
        /** Integer | Date when the user will be unbanned; Unix time. If user is banned for more than 366 days or less than 30 seconds from the current time they are considered to be banned forever. Applied for supergroups and channels only. */
        public let until_date: Int?
        /** Boolean | Pass True to delete all messages from the chat for the user that is being removed. If False, the user will be able to see messages in the group that were sent before the user was removed. Always True for supergroups and channels. */
        public let revoke_messages: Bool?
        public init(chat_id: Either2<Int, String> ,user_id: Int ,until_date: Int? = nil ,revoke_messages: Bool? = nil) {
            self.chat_id = chat_id
            self.user_id = user_id
            self.until_date = until_date
            self.revoke_messages = revoke_messages
        }
    }
}

extension TelegramAPI {

    public typealias BanChatMemberResponse = ResponseSuccess<Bool>

    /**
     * https://core.telegram.org/bots/api#banchatmember
     * Use this method to ban a user in a group, a supergroup or a channel. In the case of supergroups and channels, the user will not be able to return to the chat on their own using invite links, etc., unless unbanned first. The bot must be an administrator in the chat for this to work and must have the appropriate administrator rights. Returns True on success.
     */
    public func banChatMember(params: BanChatMemberParams) throws -> BanChatMemberResponse {
        let data = try request("banChatMember", params)
        return try JSONDecoder().decode(BanChatMemberResponse.self, from: data)
    }
}

extension TelegramAPI {
    /** https://core.telegram.org/bots/api#unbanchatmember */
    public struct UnbanChatMemberParams: Codable {
        /** Integer or String | Unique identifier for the target group or username of the target supergroup or channel (in the format @channelusername) */
        public let chat_id: Either2<Int, String>
        /** Integer | Unique identifier of the target user */
        public let user_id: Int
        /** Boolean | Do nothing if the user is not banned */
        public let only_if_banned: Bool?
        public init(chat_id: Either2<Int, String> ,user_id: Int ,only_if_banned: Bool? = nil) {
            self.chat_id = chat_id
            self.user_id = user_id
            self.only_if_banned = only_if_banned
        }
    }
}

extension TelegramAPI {

    public typealias UnbanChatMemberResponse = ResponseSuccess<Bool>

    /**
     * https://core.telegram.org/bots/api#unbanchatmember
     * Use this method to unban a previously banned user in a supergroup or channel. The user will not return to the group or channel automatically, but will be able to join via link, etc. The bot must be an administrator for this to work. By default, this method guarantees that after the call the user is not a member of the chat, but will be able to join it. So if the user is a member of the chat they will also be removed from the chat. If you don't want this, use the parameter only_if_banned. Returns True on success.
     */
    public func unbanChatMember(params: UnbanChatMemberParams) throws -> UnbanChatMemberResponse {
        let data = try request("unbanChatMember", params)
        return try JSONDecoder().decode(UnbanChatMemberResponse.self, from: data)
    }
}

extension TelegramAPI {
    /** https://core.telegram.org/bots/api#restrictchatmember */
    public struct RestrictChatMemberParams: Codable {
        /** Integer or String | Unique identifier for the target chat or username of the target supergroup (in the format @supergroupusername) */
        public let chat_id: Either2<Int, String>
        /** Integer | Unique identifier of the target user */
        public let user_id: Int
        /** ChatPermissions | A JSON-serialized object for new user permissions */
        public let permissions: ChatPermissions
        /** Boolean | Pass True if chat permissions are set independently. Otherwise, the can_send_other_messages and can_add_web_page_previews permissions will imply the can_send_messages, can_send_audios, can_send_documents, can_send_photos, can_send_videos, can_send_video_notes, and can_send_voice_notes permissions; the can_send_polls permission will imply the can_send_messages permission. */
        public let use_independent_chat_permissions: Bool?
        /** Integer | Date when restrictions will be lifted for the user; Unix time. If user is restricted for more than 366 days or less than 30 seconds from the current time, they are considered to be restricted forever */
        public let until_date: Int?
        public init(chat_id: Either2<Int, String> ,user_id: Int ,permissions: ChatPermissions ,use_independent_chat_permissions: Bool? = nil ,until_date: Int? = nil) {
            self.chat_id = chat_id
            self.user_id = user_id
            self.permissions = permissions
            self.use_independent_chat_permissions = use_independent_chat_permissions
            self.until_date = until_date
        }
    }
}

extension TelegramAPI {

    public typealias RestrictChatMemberResponse = ResponseSuccess<Bool>

    /**
     * https://core.telegram.org/bots/api#restrictchatmember
     * Use this method to restrict a user in a supergroup. The bot must be an administrator in the supergroup for this to work and must have the appropriate administrator rights. Pass True for all permissions to lift restrictions from a user. Returns True on success.
     */
    public func restrictChatMember(params: RestrictChatMemberParams) throws -> RestrictChatMemberResponse {
        let data = try request("restrictChatMember", params)
        return try JSONDecoder().decode(RestrictChatMemberResponse.self, from: data)
    }
}

extension TelegramAPI {
    /** https://core.telegram.org/bots/api#promotechatmember */
    public struct PromoteChatMemberParams: Codable {
        /** Integer or String | Unique identifier for the target chat or username of the target channel (in the format @channelusername) */
        public let chat_id: Either2<Int, String>
        /** Integer | Unique identifier of the target user */
        public let user_id: Int
        /** Boolean | Pass True if the administrator's presence in the chat is hidden */
        public let is_anonymous: Bool?
        /** Boolean | Pass True if the administrator can access the chat event log, get boost list, see hidden supergroup and channel members, report spam messages and ignore slow mode. Implied by any other administrator privilege. */
        public let can_manage_chat: Bool?
        /** Boolean | Pass True if the administrator can delete messages of other users */
        public let can_delete_messages: Bool?
        /** Boolean | Pass True if the administrator can manage video chats */
        public let can_manage_video_chats: Bool?
        /** Boolean | Pass True if the administrator can restrict, ban or unban chat members, or access supergroup statistics */
        public let can_restrict_members: Bool?
        /** Boolean | Pass True if the administrator can add new administrators with a subset of their own privileges or demote administrators that they have promoted, directly or indirectly (promoted by administrators that were appointed by him) */
        public let can_promote_members: Bool?
        /** Boolean | Pass True if the administrator can change chat title, photo and other settings */
        public let can_change_info: Bool?
        /** Boolean | Pass True if the administrator can invite new users to the chat */
        public let can_invite_users: Bool?
        /** Boolean | Pass True if the administrator can post stories to the chat */
        public let can_post_stories: Bool?
        /** Boolean | Pass True if the administrator can edit stories posted by other users, post stories to the chat page, pin chat stories, and access the chat's story archive */
        public let can_edit_stories: Bool?
        /** Boolean | Pass True if the administrator can delete stories posted by other users */
        public let can_delete_stories: Bool?
        /** Boolean | Pass True if the administrator can post messages in the channel, or access channel statistics; for channels only */
        public let can_post_messages: Bool?
        /** Boolean | Pass True if the administrator can edit messages of other users and can pin messages; for channels only */
        public let can_edit_messages: Bool?
        /** Boolean | Pass True if the administrator can pin messages; for supergroups only */
        public let can_pin_messages: Bool?
        /** Boolean | Pass True if the user is allowed to create, rename, close, and reopen forum topics; for supergroups only */
        public let can_manage_topics: Bool?
        public init(chat_id: Either2<Int, String> ,user_id: Int ,is_anonymous: Bool? = nil ,can_manage_chat: Bool? = nil ,can_delete_messages: Bool? = nil ,can_manage_video_chats: Bool? = nil ,can_restrict_members: Bool? = nil ,can_promote_members: Bool? = nil ,can_change_info: Bool? = nil ,can_invite_users: Bool? = nil ,can_post_stories: Bool? = nil ,can_edit_stories: Bool? = nil ,can_delete_stories: Bool? = nil ,can_post_messages: Bool? = nil ,can_edit_messages: Bool? = nil ,can_pin_messages: Bool? = nil ,can_manage_topics: Bool? = nil) {
            self.chat_id = chat_id
            self.user_id = user_id
            self.is_anonymous = is_anonymous
            self.can_manage_chat = can_manage_chat
            self.can_delete_messages = can_delete_messages
            self.can_manage_video_chats = can_manage_video_chats
            self.can_restrict_members = can_restrict_members
            self.can_promote_members = can_promote_members
            self.can_change_info = can_change_info
            self.can_invite_users = can_invite_users
            self.can_post_stories = can_post_stories
            self.can_edit_stories = can_edit_stories
            self.can_delete_stories = can_delete_stories
            self.can_post_messages = can_post_messages
            self.can_edit_messages = can_edit_messages
            self.can_pin_messages = can_pin_messages
            self.can_manage_topics = can_manage_topics
        }
    }
}

extension TelegramAPI {

    public typealias PromoteChatMemberResponse = ResponseSuccess<Bool>

    /**
     * https://core.telegram.org/bots/api#promotechatmember
     * Use this method to promote or demote a user in a supergroup or a channel. The bot must be an administrator in the chat for this to work and must have the appropriate administrator rights. Pass False for all boolean parameters to demote a user. Returns True on success.
     */
    public func promoteChatMember(params: PromoteChatMemberParams) throws -> PromoteChatMemberResponse {
        let data = try request("promoteChatMember", params)
        return try JSONDecoder().decode(PromoteChatMemberResponse.self, from: data)
    }
}

extension TelegramAPI {
    /** https://core.telegram.org/bots/api#setchatadministratorcustomtitle */
    public struct SetChatAdministratorCustomTitleParams: Codable {
        /** Integer or String | Unique identifier for the target chat or username of the target supergroup (in the format @supergroupusername) */
        public let chat_id: Either2<Int, String>
        /** Integer | Unique identifier of the target user */
        public let user_id: Int
        /** String | New custom title for the administrator; 0-16 characters, emoji are not allowed */
        public let custom_title: String
        public init(chat_id: Either2<Int, String> ,user_id: Int ,custom_title: String) {
            self.chat_id = chat_id
            self.user_id = user_id
            self.custom_title = custom_title
        }
    }
}

extension TelegramAPI {

    public typealias SetChatAdministratorCustomTitleResponse = ResponseSuccess<Bool>

    /**
     * https://core.telegram.org/bots/api#setchatadministratorcustomtitle
     * Use this method to set a custom title for an administrator in a supergroup promoted by the bot. Returns True on success.
     */
    public func setChatAdministratorCustomTitle(params: SetChatAdministratorCustomTitleParams) throws -> SetChatAdministratorCustomTitleResponse {
        let data = try request("setChatAdministratorCustomTitle", params)
        return try JSONDecoder().decode(SetChatAdministratorCustomTitleResponse.self, from: data)
    }
}

extension TelegramAPI {
    /** https://core.telegram.org/bots/api#banchatsenderchat */
    public struct BanChatSenderChatParams: Codable {
        /** Integer or String | Unique identifier for the target chat or username of the target channel (in the format @channelusername) */
        public let chat_id: Either2<Int, String>
        /** Integer | Unique identifier of the target sender chat */
        public let sender_chat_id: Int
        public init(chat_id: Either2<Int, String> ,sender_chat_id: Int) {
            self.chat_id = chat_id
            self.sender_chat_id = sender_chat_id
        }
    }
}

extension TelegramAPI {

    public typealias BanChatSenderChatResponse = ResponseSuccess<Bool>

    /**
     * https://core.telegram.org/bots/api#banchatsenderchat
     * Use this method to ban a channel chat in a supergroup or a channel. Until the chat is unbanned, the owner of the banned chat won't be able to send messages on behalf of any of their channels. The bot must be an administrator in the supergroup or channel for this to work and must have the appropriate administrator rights. Returns True on success.
     */
    public func banChatSenderChat(params: BanChatSenderChatParams) throws -> BanChatSenderChatResponse {
        let data = try request("banChatSenderChat", params)
        return try JSONDecoder().decode(BanChatSenderChatResponse.self, from: data)
    }
}

extension TelegramAPI {
    /** https://core.telegram.org/bots/api#unbanchatsenderchat */
    public struct UnbanChatSenderChatParams: Codable {
        /** Integer or String | Unique identifier for the target chat or username of the target channel (in the format @channelusername) */
        public let chat_id: Either2<Int, String>
        /** Integer | Unique identifier of the target sender chat */
        public let sender_chat_id: Int
        public init(chat_id: Either2<Int, String> ,sender_chat_id: Int) {
            self.chat_id = chat_id
            self.sender_chat_id = sender_chat_id
        }
    }
}

extension TelegramAPI {

    public typealias UnbanChatSenderChatResponse = ResponseSuccess<Bool>

    /**
     * https://core.telegram.org/bots/api#unbanchatsenderchat
     * Use this method to unban a previously banned channel chat in a supergroup or channel. The bot must be an administrator for this to work and must have the appropriate administrator rights. Returns True on success.
     */
    public func unbanChatSenderChat(params: UnbanChatSenderChatParams) throws -> UnbanChatSenderChatResponse {
        let data = try request("unbanChatSenderChat", params)
        return try JSONDecoder().decode(UnbanChatSenderChatResponse.self, from: data)
    }
}

extension TelegramAPI {
    /** https://core.telegram.org/bots/api#setchatpermissions */
    public struct SetChatPermissionsParams: Codable {
        /** Integer or String | Unique identifier for the target chat or username of the target supergroup (in the format @supergroupusername) */
        public let chat_id: Either2<Int, String>
        /** ChatPermissions | A JSON-serialized object for new default chat permissions */
        public let permissions: ChatPermissions
        /** Boolean | Pass True if chat permissions are set independently. Otherwise, the can_send_other_messages and can_add_web_page_previews permissions will imply the can_send_messages, can_send_audios, can_send_documents, can_send_photos, can_send_videos, can_send_video_notes, and can_send_voice_notes permissions; the can_send_polls permission will imply the can_send_messages permission. */
        public let use_independent_chat_permissions: Bool?
        public init(chat_id: Either2<Int, String> ,permissions: ChatPermissions ,use_independent_chat_permissions: Bool? = nil) {
            self.chat_id = chat_id
            self.permissions = permissions
            self.use_independent_chat_permissions = use_independent_chat_permissions
        }
    }
}

extension TelegramAPI {

    public typealias SetChatPermissionsResponse = ResponseSuccess<Bool>

    /**
     * https://core.telegram.org/bots/api#setchatpermissions
     * Use this method to set default chat permissions for all members. The bot must be an administrator in the group or a supergroup for this to work and must have the can_restrict_members administrator rights. Returns True on success.
     */
    public func setChatPermissions(params: SetChatPermissionsParams) throws -> SetChatPermissionsResponse {
        let data = try request("setChatPermissions", params)
        return try JSONDecoder().decode(SetChatPermissionsResponse.self, from: data)
    }
}

extension TelegramAPI {
    /** https://core.telegram.org/bots/api#exportchatinvitelink */
    public struct ExportChatInviteLinkParams: Codable {
        /** Integer or String | Unique identifier for the target chat or username of the target channel (in the format @channelusername) */
        public let chat_id: Either2<Int, String>
        public init(chat_id: Either2<Int, String>) {
            self.chat_id = chat_id
        }
    }
}

extension TelegramAPI {

    public typealias ExportChatInviteLinkResponse = ResponseSuccess<String>

    /**
     * https://core.telegram.org/bots/api#exportchatinvitelink
     * Use this method to generate a new primary invite link for a chat; any previously generated primary link is revoked. The bot must be an administrator in the chat for this to work and must have the appropriate administrator rights. Returns the new invite link as String on success.
     */
    public func exportChatInviteLink(params: ExportChatInviteLinkParams) throws -> ExportChatInviteLinkResponse {
        let data = try request("exportChatInviteLink", params)
        return try JSONDecoder().decode(ExportChatInviteLinkResponse.self, from: data)
    }
}

extension TelegramAPI {
    /** https://core.telegram.org/bots/api#createchatinvitelink */
    public struct CreateChatInviteLinkParams: Codable {
        /** Integer or String | Unique identifier for the target chat or username of the target channel (in the format @channelusername) */
        public let chat_id: Either2<Int, String>
        /** String | Invite link name; 0-32 characters */
        public let name: String?
        /** Integer | Point in time (Unix timestamp) when the link will expire */
        public let expire_date: Int?
        /** Integer | The maximum number of users that can be members of the chat simultaneously after joining the chat via this invite link; 1-99999 */
        public let member_limit: Int?
        /** Boolean | True, if users joining the chat via the link need to be approved by chat administrators. If True, member_limit can't be specified */
        public let creates_join_request: Bool?
        public init(chat_id: Either2<Int, String> ,name: String? = nil ,expire_date: Int? = nil ,member_limit: Int? = nil ,creates_join_request: Bool? = nil) {
            self.chat_id = chat_id
            self.name = name
            self.expire_date = expire_date
            self.member_limit = member_limit
            self.creates_join_request = creates_join_request
        }
    }
}

extension TelegramAPI {

    public typealias CreateChatInviteLinkResponse = ResponseSuccess<ChatInviteLink>

    /**
     * https://core.telegram.org/bots/api#createchatinvitelink
     * Use this method to create an additional invite link for a chat. The bot must be an administrator in the chat for this to work and must have the appropriate administrator rights. The link can be revoked using the method revokeChatInviteLink. Returns the new invite link as ChatInviteLink object.
     */
    public func createChatInviteLink(params: CreateChatInviteLinkParams) throws -> CreateChatInviteLinkResponse {
        let data = try request("createChatInviteLink", params)
        return try JSONDecoder().decode(CreateChatInviteLinkResponse.self, from: data)
    }
}

extension TelegramAPI {
    /** https://core.telegram.org/bots/api#editchatinvitelink */
    public struct EditChatInviteLinkParams: Codable {
        /** Integer or String | Unique identifier for the target chat or username of the target channel (in the format @channelusername) */
        public let chat_id: Either2<Int, String>
        /** String | The invite link to edit */
        public let invite_link: String
        /** String | Invite link name; 0-32 characters */
        public let name: String?
        /** Integer | Point in time (Unix timestamp) when the link will expire */
        public let expire_date: Int?
        /** Integer | The maximum number of users that can be members of the chat simultaneously after joining the chat via this invite link; 1-99999 */
        public let member_limit: Int?
        /** Boolean | True, if users joining the chat via the link need to be approved by chat administrators. If True, member_limit can't be specified */
        public let creates_join_request: Bool?
        public init(chat_id: Either2<Int, String> ,invite_link: String ,name: String? = nil ,expire_date: Int? = nil ,member_limit: Int? = nil ,creates_join_request: Bool? = nil) {
            self.chat_id = chat_id
            self.invite_link = invite_link
            self.name = name
            self.expire_date = expire_date
            self.member_limit = member_limit
            self.creates_join_request = creates_join_request
        }
    }
}

extension TelegramAPI {

    public typealias EditChatInviteLinkResponse = ResponseSuccess<ChatInviteLink>

    /**
     * https://core.telegram.org/bots/api#editchatinvitelink
     * Use this method to edit a non-primary invite link created by the bot. The bot must be an administrator in the chat for this to work and must have the appropriate administrator rights. Returns the edited invite link as a ChatInviteLink object.
     */
    public func editChatInviteLink(params: EditChatInviteLinkParams) throws -> EditChatInviteLinkResponse {
        let data = try request("editChatInviteLink", params)
        return try JSONDecoder().decode(EditChatInviteLinkResponse.self, from: data)
    }
}

extension TelegramAPI {
    /** https://core.telegram.org/bots/api#createchatsubscriptioninvitelink */
    public struct CreateChatSubscriptionInviteLinkParams: Codable {
        /** Integer or String | Unique identifier for the target channel chat or username of the target channel (in the format @channelusername) */
        public let chat_id: Either2<Int, String>
        /** String | Invite link name; 0-32 characters */
        public let name: String?
        /** Integer | The number of seconds the subscription will be active for before the next payment. Currently, it must always be 2592000 (30 days). */
        public let subscription_period: Int
        /** Integer | The amount of Telegram Stars a user must pay initially and after each subsequent subscription period to be a member of the chat; 1-2500 */
        public let subscription_price: Int
        public init(chat_id: Either2<Int, String> ,name: String? = nil ,subscription_period: Int ,subscription_price: Int) {
            self.chat_id = chat_id
            self.name = name
            self.subscription_period = subscription_period
            self.subscription_price = subscription_price
        }
    }
}

extension TelegramAPI {

    public typealias CreateChatSubscriptionInviteLinkResponse = ResponseSuccess<ChatInviteLink>

    /**
     * https://core.telegram.org/bots/api#createchatsubscriptioninvitelink
     * Use this method to create a subscription invite link for a channel chat. The bot must have the can_invite_users administrator rights. The link can be edited using the method editChatSubscriptionInviteLink or revoked using the method revokeChatInviteLink. Returns the new invite link as a ChatInviteLink object.
     */
    public func createChatSubscriptionInviteLink(params: CreateChatSubscriptionInviteLinkParams) throws -> CreateChatSubscriptionInviteLinkResponse {
        let data = try request("createChatSubscriptionInviteLink", params)
        return try JSONDecoder().decode(CreateChatSubscriptionInviteLinkResponse.self, from: data)
    }
}

extension TelegramAPI {
    /** https://core.telegram.org/bots/api#editchatsubscriptioninvitelink */
    public struct EditChatSubscriptionInviteLinkParams: Codable {
        /** Integer or String | Unique identifier for the target chat or username of the target channel (in the format @channelusername) */
        public let chat_id: Either2<Int, String>
        /** String | The invite link to edit */
        public let invite_link: String
        /** String | Invite link name; 0-32 characters */
        public let name: String?
        public init(chat_id: Either2<Int, String> ,invite_link: String ,name: String? = nil) {
            self.chat_id = chat_id
            self.invite_link = invite_link
            self.name = name
        }
    }
}

extension TelegramAPI {

    public typealias EditChatSubscriptionInviteLinkResponse = ResponseSuccess<ChatInviteLink>

    /**
     * https://core.telegram.org/bots/api#editchatsubscriptioninvitelink
     * Use this method to edit a subscription invite link created by the bot. The bot must have the can_invite_users administrator rights. Returns the edited invite link as a ChatInviteLink object.
     */
    public func editChatSubscriptionInviteLink(params: EditChatSubscriptionInviteLinkParams) throws -> EditChatSubscriptionInviteLinkResponse {
        let data = try request("editChatSubscriptionInviteLink", params)
        return try JSONDecoder().decode(EditChatSubscriptionInviteLinkResponse.self, from: data)
    }
}

extension TelegramAPI {
    /** https://core.telegram.org/bots/api#revokechatinvitelink */
    public struct RevokeChatInviteLinkParams: Codable {
        /** Integer or String | Unique identifier of the target chat or username of the target channel (in the format @channelusername) */
        public let chat_id: Either2<Int, String>
        /** String | The invite link to revoke */
        public let invite_link: String
        public init(chat_id: Either2<Int, String> ,invite_link: String) {
            self.chat_id = chat_id
            self.invite_link = invite_link
        }
    }
}

extension TelegramAPI {

    public typealias RevokeChatInviteLinkResponse = ResponseSuccess<ChatInviteLink>

    /**
     * https://core.telegram.org/bots/api#revokechatinvitelink
     * Use this method to revoke an invite link created by the bot. If the primary link is revoked, a new link is automatically generated. The bot must be an administrator in the chat for this to work and must have the appropriate administrator rights. Returns the revoked invite link as ChatInviteLink object.
     */
    public func revokeChatInviteLink(params: RevokeChatInviteLinkParams) throws -> RevokeChatInviteLinkResponse {
        let data = try request("revokeChatInviteLink", params)
        return try JSONDecoder().decode(RevokeChatInviteLinkResponse.self, from: data)
    }
}

extension TelegramAPI {
    /** https://core.telegram.org/bots/api#approvechatjoinrequest */
    public struct ApproveChatJoinRequestParams: Codable {
        /** Integer or String | Unique identifier for the target chat or username of the target channel (in the format @channelusername) */
        public let chat_id: Either2<Int, String>
        /** Integer | Unique identifier of the target user */
        public let user_id: Int
        public init(chat_id: Either2<Int, String> ,user_id: Int) {
            self.chat_id = chat_id
            self.user_id = user_id
        }
    }
}

extension TelegramAPI {

    public typealias ApproveChatJoinRequestResponse = ResponseSuccess<Bool>

    /**
     * https://core.telegram.org/bots/api#approvechatjoinrequest
     * Use this method to approve a chat join request. The bot must be an administrator in the chat for this to work and must have the can_invite_users administrator right. Returns True on success.
     */
    public func approveChatJoinRequest(params: ApproveChatJoinRequestParams) throws -> ApproveChatJoinRequestResponse {
        let data = try request("approveChatJoinRequest", params)
        return try JSONDecoder().decode(ApproveChatJoinRequestResponse.self, from: data)
    }
}

extension TelegramAPI {
    /** https://core.telegram.org/bots/api#declinechatjoinrequest */
    public struct DeclineChatJoinRequestParams: Codable {
        /** Integer or String | Unique identifier for the target chat or username of the target channel (in the format @channelusername) */
        public let chat_id: Either2<Int, String>
        /** Integer | Unique identifier of the target user */
        public let user_id: Int
        public init(chat_id: Either2<Int, String> ,user_id: Int) {
            self.chat_id = chat_id
            self.user_id = user_id
        }
    }
}

extension TelegramAPI {

    public typealias DeclineChatJoinRequestResponse = ResponseSuccess<Bool>

    /**
     * https://core.telegram.org/bots/api#declinechatjoinrequest
     * Use this method to decline a chat join request. The bot must be an administrator in the chat for this to work and must have the can_invite_users administrator right. Returns True on success.
     */
    public func declineChatJoinRequest(params: DeclineChatJoinRequestParams) throws -> DeclineChatJoinRequestResponse {
        let data = try request("declineChatJoinRequest", params)
        return try JSONDecoder().decode(DeclineChatJoinRequestResponse.self, from: data)
    }
}

extension TelegramAPI {
    /** https://core.telegram.org/bots/api#setchatphoto */
    public struct SetChatPhotoParams: Codable {
        /** Integer or String | Unique identifier for the target chat or username of the target channel (in the format @channelusername) */
        public let chat_id: Either2<Int, String>
        /** InputFile | New chat photo, uploaded using multipart/form-data */
        public let photo: InputFile
        public init(chat_id: Either2<Int, String> ,photo: InputFile) {
            self.chat_id = chat_id
            self.photo = photo
        }
    }
}

extension TelegramAPI {

    public typealias SetChatPhotoResponse = ResponseSuccess<Bool>

    /**
     * https://core.telegram.org/bots/api#setchatphoto
     * Use this method to set a new profile photo for the chat. Photos can't be changed for private chats. The bot must be an administrator in the chat for this to work and must have the appropriate administrator rights. Returns True on success.
     */
    public func setChatPhoto(params: SetChatPhotoParams) throws -> SetChatPhotoResponse {
        let data = try request("setChatPhoto", params)
        return try JSONDecoder().decode(SetChatPhotoResponse.self, from: data)
    }
}

extension TelegramAPI {
    /** https://core.telegram.org/bots/api#deletechatphoto */
    public struct DeleteChatPhotoParams: Codable {
        /** Integer or String | Unique identifier for the target chat or username of the target channel (in the format @channelusername) */
        public let chat_id: Either2<Int, String>
        public init(chat_id: Either2<Int, String>) {
            self.chat_id = chat_id
        }
    }
}

extension TelegramAPI {

    public typealias DeleteChatPhotoResponse = ResponseSuccess<Bool>

    /**
     * https://core.telegram.org/bots/api#deletechatphoto
     * Use this method to delete a chat photo. Photos can't be changed for private chats. The bot must be an administrator in the chat for this to work and must have the appropriate administrator rights. Returns True on success.
     */
    public func deleteChatPhoto(params: DeleteChatPhotoParams) throws -> DeleteChatPhotoResponse {
        let data = try request("deleteChatPhoto", params)
        return try JSONDecoder().decode(DeleteChatPhotoResponse.self, from: data)
    }
}

extension TelegramAPI {
    /** https://core.telegram.org/bots/api#setchattitle */
    public struct SetChatTitleParams: Codable {
        /** Integer or String | Unique identifier for the target chat or username of the target channel (in the format @channelusername) */
        public let chat_id: Either2<Int, String>
        /** String | New chat title, 1-128 characters */
        public let title: String
        public init(chat_id: Either2<Int, String> ,title: String) {
            self.chat_id = chat_id
            self.title = title
        }
    }
}

extension TelegramAPI {

    public typealias SetChatTitleResponse = ResponseSuccess<Bool>

    /**
     * https://core.telegram.org/bots/api#setchattitle
     * Use this method to change the title of a chat. Titles can't be changed for private chats. The bot must be an administrator in the chat for this to work and must have the appropriate administrator rights. Returns True on success.
     */
    public func setChatTitle(params: SetChatTitleParams) throws -> SetChatTitleResponse {
        let data = try request("setChatTitle", params)
        return try JSONDecoder().decode(SetChatTitleResponse.self, from: data)
    }
}

extension TelegramAPI {
    /** https://core.telegram.org/bots/api#setchatdescription */
    public struct SetChatDescriptionParams: Codable {
        /** Integer or String | Unique identifier for the target chat or username of the target channel (in the format @channelusername) */
        public let chat_id: Either2<Int, String>
        /** String | New chat description, 0-255 characters */
        public let description: String?
        public init(chat_id: Either2<Int, String> ,description: String? = nil) {
            self.chat_id = chat_id
            self.description = description
        }
    }
}

extension TelegramAPI {

    public typealias SetChatDescriptionResponse = ResponseSuccess<Bool>

    /**
     * https://core.telegram.org/bots/api#setchatdescription
     * Use this method to change the description of a group, a supergroup or a channel. The bot must be an administrator in the chat for this to work and must have the appropriate administrator rights. Returns True on success.
     */
    public func setChatDescription(params: SetChatDescriptionParams) throws -> SetChatDescriptionResponse {
        let data = try request("setChatDescription", params)
        return try JSONDecoder().decode(SetChatDescriptionResponse.self, from: data)
    }
}

extension TelegramAPI {
    /** https://core.telegram.org/bots/api#pinchatmessage */
    public struct PinChatMessageParams: Codable {
        /** String | Unique identifier of the business connection on behalf of which the message will be pinned */
        public let business_connection_id: String?
        /** Integer or String | Unique identifier for the target chat or username of the target channel (in the format @channelusername) */
        public let chat_id: Either2<Int, String>
        /** Integer | Identifier of a message to pin */
        public let message_id: Int
        /** Boolean | Pass True if it is not necessary to send a notification to all chat members about the new pinned message. Notifications are always disabled in channels and private chats. */
        public let disable_notification: Bool?
        public init(business_connection_id: String? = nil ,chat_id: Either2<Int, String> ,message_id: Int ,disable_notification: Bool? = nil) {
            self.business_connection_id = business_connection_id
            self.chat_id = chat_id
            self.message_id = message_id
            self.disable_notification = disable_notification
        }
    }
}

extension TelegramAPI {

    public typealias PinChatMessageResponse = ResponseSuccess<Bool>

    /**
     * https://core.telegram.org/bots/api#pinchatmessage
     * Use this method to add a message to the list of pinned messages in a chat. If the chat is not a private chat, the bot must be an administrator in the chat for this to work and must have the 'can_pin_messages' administrator right in a supergroup or 'can_edit_messages' administrator right in a channel. Returns True on success.
     */
    public func pinChatMessage(params: PinChatMessageParams) throws -> PinChatMessageResponse {
        let data = try request("pinChatMessage", params)
        return try JSONDecoder().decode(PinChatMessageResponse.self, from: data)
    }
}

extension TelegramAPI {
    /** https://core.telegram.org/bots/api#unpinchatmessage */
    public struct UnpinChatMessageParams: Codable {
        /** String | Unique identifier of the business connection on behalf of which the message will be unpinned */
        public let business_connection_id: String?
        /** Integer or String | Unique identifier for the target chat or username of the target channel (in the format @channelusername) */
        public let chat_id: Either2<Int, String>
        /** Integer | Identifier of the message to unpin. Required if business_connection_id is specified. If not specified, the most recent pinned message (by sending date) will be unpinned. */
        public let message_id: Int?
        public init(business_connection_id: String? = nil ,chat_id: Either2<Int, String> ,message_id: Int? = nil) {
            self.business_connection_id = business_connection_id
            self.chat_id = chat_id
            self.message_id = message_id
        }
    }
}

extension TelegramAPI {

    public typealias UnpinChatMessageResponse = ResponseSuccess<Bool>

    /**
     * https://core.telegram.org/bots/api#unpinchatmessage
     * Use this method to remove a message from the list of pinned messages in a chat. If the chat is not a private chat, the bot must be an administrator in the chat for this to work and must have the 'can_pin_messages' administrator right in a supergroup or 'can_edit_messages' administrator right in a channel. Returns True on success.
     */
    public func unpinChatMessage(params: UnpinChatMessageParams) throws -> UnpinChatMessageResponse {
        let data = try request("unpinChatMessage", params)
        return try JSONDecoder().decode(UnpinChatMessageResponse.self, from: data)
    }
}

extension TelegramAPI {
    /** https://core.telegram.org/bots/api#unpinallchatmessages */
    public struct UnpinAllChatMessagesParams: Codable {
        /** Integer or String | Unique identifier for the target chat or username of the target channel (in the format @channelusername) */
        public let chat_id: Either2<Int, String>
        public init(chat_id: Either2<Int, String>) {
            self.chat_id = chat_id
        }
    }
}

extension TelegramAPI {

    public typealias UnpinAllChatMessagesResponse = ResponseSuccess<Bool>

    /**
     * https://core.telegram.org/bots/api#unpinallchatmessages
     * Use this method to clear the list of pinned messages in a chat. If the chat is not a private chat, the bot must be an administrator in the chat for this to work and must have the 'can_pin_messages' administrator right in a supergroup or 'can_edit_messages' administrator right in a channel. Returns True on success.
     */
    public func unpinAllChatMessages(params: UnpinAllChatMessagesParams) throws -> UnpinAllChatMessagesResponse {
        let data = try request("unpinAllChatMessages", params)
        return try JSONDecoder().decode(UnpinAllChatMessagesResponse.self, from: data)
    }
}

extension TelegramAPI {
    /** https://core.telegram.org/bots/api#leavechat */
    public struct LeaveChatParams: Codable {
        /** Integer or String | Unique identifier for the target chat or username of the target supergroup or channel (in the format @channelusername) */
        public let chat_id: Either2<Int, String>
        public init(chat_id: Either2<Int, String>) {
            self.chat_id = chat_id
        }
    }
}

extension TelegramAPI {

    public typealias LeaveChatResponse = ResponseSuccess<Bool>

    /**
     * https://core.telegram.org/bots/api#leavechat
     * Use this method for your bot to leave a group, supergroup or channel. Returns True on success.
     */
    public func leaveChat(params: LeaveChatParams) throws -> LeaveChatResponse {
        let data = try request("leaveChat", params)
        return try JSONDecoder().decode(LeaveChatResponse.self, from: data)
    }
}

extension TelegramAPI {
    /** https://core.telegram.org/bots/api#getchat */
    public struct GetChatParams: Codable {
        /** Integer or String | Unique identifier for the target chat or username of the target supergroup or channel (in the format @channelusername) */
        public let chat_id: Either2<Int, String>
        public init(chat_id: Either2<Int, String>) {
            self.chat_id = chat_id
        }
    }
}

extension TelegramAPI {

    public typealias GetChatResponse = ResponseSuccess<ChatFullInfo>

    /**
     * https://core.telegram.org/bots/api#getchat
     * Use this method to get up-to-date information about the chat. Returns a ChatFullInfo object on success.
     */
    public func getChat(params: GetChatParams) throws -> GetChatResponse {
        let data = try request("getChat", params)
        return try JSONDecoder().decode(GetChatResponse.self, from: data)
    }
}

extension TelegramAPI {
    /** https://core.telegram.org/bots/api#getchatadministrators */
    public struct GetChatAdministratorsParams: Codable {
        /** Integer or String | Unique identifier for the target chat or username of the target supergroup or channel (in the format @channelusername) */
        public let chat_id: Either2<Int, String>
        public init(chat_id: Either2<Int, String>) {
            self.chat_id = chat_id
        }
    }
}

extension TelegramAPI {

    public typealias GetChatAdministratorsResponse = ResponseSuccess<Array<ChatMember>>

    /**
     * https://core.telegram.org/bots/api#getchatadministrators
     * Use this method to get a list of administrators in a chat, which aren't bots. Returns an Array of ChatMember objects.
     */
    public func getChatAdministrators(params: GetChatAdministratorsParams) throws -> GetChatAdministratorsResponse {
        let data = try request("getChatAdministrators", params)
        return try JSONDecoder().decode(GetChatAdministratorsResponse.self, from: data)
    }
}

extension TelegramAPI {
    /** https://core.telegram.org/bots/api#getchatmembercount */
    public struct GetChatMemberCountParams: Codable {
        /** Integer or String | Unique identifier for the target chat or username of the target supergroup or channel (in the format @channelusername) */
        public let chat_id: Either2<Int, String>
        public init(chat_id: Either2<Int, String>) {
            self.chat_id = chat_id
        }
    }
}

extension TelegramAPI {

    public typealias GetChatMemberCountResponse = ResponseSuccess<Int>

    /**
     * https://core.telegram.org/bots/api#getchatmembercount
     * Use this method to get the number of members in a chat. Returns Int on success.
     */
    public func getChatMemberCount(params: GetChatMemberCountParams) throws -> GetChatMemberCountResponse {
        let data = try request("getChatMemberCount", params)
        return try JSONDecoder().decode(GetChatMemberCountResponse.self, from: data)
    }
}

extension TelegramAPI {
    /** https://core.telegram.org/bots/api#getchatmember */
    public struct GetChatMemberParams: Codable {
        /** Integer or String | Unique identifier for the target chat or username of the target supergroup or channel (in the format @channelusername) */
        public let chat_id: Either2<Int, String>
        /** Integer | Unique identifier of the target user */
        public let user_id: Int
        public init(chat_id: Either2<Int, String> ,user_id: Int) {
            self.chat_id = chat_id
            self.user_id = user_id
        }
    }
}

extension TelegramAPI {

    public typealias GetChatMemberResponse = ResponseSuccess<ChatMember>

    /**
     * https://core.telegram.org/bots/api#getchatmember
     * Use this method to get information about a member of a chat. The method is only guaranteed to work for other users if the bot is an administrator in the chat. Returns a ChatMember object on success.
     */
    public func getChatMember(params: GetChatMemberParams) throws -> GetChatMemberResponse {
        let data = try request("getChatMember", params)
        return try JSONDecoder().decode(GetChatMemberResponse.self, from: data)
    }
}

extension TelegramAPI {
    /** https://core.telegram.org/bots/api#setchatstickerset */
    public struct SetChatStickerSetParams: Codable {
        /** Integer or String | Unique identifier for the target chat or username of the target supergroup (in the format @supergroupusername) */
        public let chat_id: Either2<Int, String>
        /** String | Name of the sticker set to be set as the group sticker set */
        public let sticker_set_name: String
        public init(chat_id: Either2<Int, String> ,sticker_set_name: String) {
            self.chat_id = chat_id
            self.sticker_set_name = sticker_set_name
        }
    }
}

extension TelegramAPI {

    public typealias SetChatStickerSetResponse = ResponseSuccess<Bool>

    /**
     * https://core.telegram.org/bots/api#setchatstickerset
     * Use this method to set a new group sticker set for a supergroup. The bot must be an administrator in the chat for this to work and must have the appropriate administrator rights. Use the field can_set_sticker_set optionally returned in getChat requests to check if the bot can use this method. Returns True on success.
     */
    public func setChatStickerSet(params: SetChatStickerSetParams) throws -> SetChatStickerSetResponse {
        let data = try request("setChatStickerSet", params)
        return try JSONDecoder().decode(SetChatStickerSetResponse.self, from: data)
    }
}

extension TelegramAPI {
    /** https://core.telegram.org/bots/api#deletechatstickerset */
    public struct DeleteChatStickerSetParams: Codable {
        /** Integer or String | Unique identifier for the target chat or username of the target supergroup (in the format @supergroupusername) */
        public let chat_id: Either2<Int, String>
        public init(chat_id: Either2<Int, String>) {
            self.chat_id = chat_id
        }
    }
}

extension TelegramAPI {

    public typealias DeleteChatStickerSetResponse = ResponseSuccess<Bool>

    /**
     * https://core.telegram.org/bots/api#deletechatstickerset
     * Use this method to delete a group sticker set from a supergroup. The bot must be an administrator in the chat for this to work and must have the appropriate administrator rights. Use the field can_set_sticker_set optionally returned in getChat requests to check if the bot can use this method. Returns True on success.
     */
    public func deleteChatStickerSet(params: DeleteChatStickerSetParams) throws -> DeleteChatStickerSetResponse {
        let data = try request("deleteChatStickerSet", params)
        return try JSONDecoder().decode(DeleteChatStickerSetResponse.self, from: data)
    }
}

extension TelegramAPI {

    public typealias GetForumTopicIconStickersResponse = ResponseSuccess<Array<Sticker>>

    /**
     * https://core.telegram.org/bots/api#getforumtopiciconstickers
     * Use this method to get custom emoji stickers, which can be used as a forum topic icon by any user. Requires no parameters. Returns an Array of Sticker objects.
     */
    public func getForumTopicIconStickers() throws -> GetForumTopicIconStickersResponse {
        let data = try request("getForumTopicIconStickers", [String: String]())
        return try JSONDecoder().decode(GetForumTopicIconStickersResponse.self, from: data)
    }
}

extension TelegramAPI {
    /** https://core.telegram.org/bots/api#createforumtopic */
    public struct CreateForumTopicParams: Codable {
        /** Integer or String | Unique identifier for the target chat or username of the target supergroup (in the format @supergroupusername) */
        public let chat_id: Either2<Int, String>
        /** String | Topic name, 1-128 characters */
        public let name: String
        /** Integer | Color of the topic icon in RGB format. Currently, must be one of 7322096 (0x6FB9F0), 16766590 (0xFFD67E), 13338331 (0xCB86DB), 9367192 (0x8EEE98), 16749490 (0xFF93B2), or 16478047 (0xFB6F5F) */
        public let icon_color: Int?
        /** String | Unique identifier of the custom emoji shown as the topic icon. Use getForumTopicIconStickers to get all allowed custom emoji identifiers. */
        public let icon_custom_emoji_id: String?
        public init(chat_id: Either2<Int, String> ,name: String ,icon_color: Int? = nil ,icon_custom_emoji_id: String? = nil) {
            self.chat_id = chat_id
            self.name = name
            self.icon_color = icon_color
            self.icon_custom_emoji_id = icon_custom_emoji_id
        }
    }
}

extension TelegramAPI {

    public typealias CreateForumTopicResponse = ResponseSuccess<ForumTopic>

    /**
     * https://core.telegram.org/bots/api#createforumtopic
     * Use this method to create a topic in a forum supergroup chat. The bot must be an administrator in the chat for this to work and must have the can_manage_topics administrator rights. Returns information about the created topic as a ForumTopic object.
     */
    public func createForumTopic(params: CreateForumTopicParams) throws -> CreateForumTopicResponse {
        let data = try request("createForumTopic", params)
        return try JSONDecoder().decode(CreateForumTopicResponse.self, from: data)
    }
}

extension TelegramAPI {
    /** https://core.telegram.org/bots/api#editforumtopic */
    public struct EditForumTopicParams: Codable {
        /** Integer or String | Unique identifier for the target chat or username of the target supergroup (in the format @supergroupusername) */
        public let chat_id: Either2<Int, String>
        /** Integer | Unique identifier for the target message thread of the forum topic */
        public let message_thread_id: Int
        /** String | New topic name, 0-128 characters. If not specified or empty, the current name of the topic will be kept */
        public let name: String?
        /** String | New unique identifier of the custom emoji shown as the topic icon. Use getForumTopicIconStickers to get all allowed custom emoji identifiers. Pass an empty string to remove the icon. If not specified, the current icon will be kept */
        public let icon_custom_emoji_id: String?
        public init(chat_id: Either2<Int, String> ,message_thread_id: Int ,name: String? = nil ,icon_custom_emoji_id: String? = nil) {
            self.chat_id = chat_id
            self.message_thread_id = message_thread_id
            self.name = name
            self.icon_custom_emoji_id = icon_custom_emoji_id
        }
    }
}

extension TelegramAPI {

    public typealias EditForumTopicResponse = ResponseSuccess<Bool>

    /**
     * https://core.telegram.org/bots/api#editforumtopic
     * Use this method to edit name and icon of a topic in a forum supergroup chat. The bot must be an administrator in the chat for this to work and must have the can_manage_topics administrator rights, unless it is the creator of the topic. Returns True on success.
     */
    public func editForumTopic(params: EditForumTopicParams) throws -> EditForumTopicResponse {
        let data = try request("editForumTopic", params)
        return try JSONDecoder().decode(EditForumTopicResponse.self, from: data)
    }
}

extension TelegramAPI {
    /** https://core.telegram.org/bots/api#closeforumtopic */
    public struct CloseForumTopicParams: Codable {
        /** Integer or String | Unique identifier for the target chat or username of the target supergroup (in the format @supergroupusername) */
        public let chat_id: Either2<Int, String>
        /** Integer | Unique identifier for the target message thread of the forum topic */
        public let message_thread_id: Int
        public init(chat_id: Either2<Int, String> ,message_thread_id: Int) {
            self.chat_id = chat_id
            self.message_thread_id = message_thread_id
        }
    }
}

extension TelegramAPI {

    public typealias CloseForumTopicResponse = ResponseSuccess<Bool>

    /**
     * https://core.telegram.org/bots/api#closeforumtopic
     * Use this method to close an open topic in a forum supergroup chat. The bot must be an administrator in the chat for this to work and must have the can_manage_topics administrator rights, unless it is the creator of the topic. Returns True on success.
     */
    public func closeForumTopic(params: CloseForumTopicParams) throws -> CloseForumTopicResponse {
        let data = try request("closeForumTopic", params)
        return try JSONDecoder().decode(CloseForumTopicResponse.self, from: data)
    }
}

extension TelegramAPI {
    /** https://core.telegram.org/bots/api#reopenforumtopic */
    public struct ReopenForumTopicParams: Codable {
        /** Integer or String | Unique identifier for the target chat or username of the target supergroup (in the format @supergroupusername) */
        public let chat_id: Either2<Int, String>
        /** Integer | Unique identifier for the target message thread of the forum topic */
        public let message_thread_id: Int
        public init(chat_id: Either2<Int, String> ,message_thread_id: Int) {
            self.chat_id = chat_id
            self.message_thread_id = message_thread_id
        }
    }
}

extension TelegramAPI {

    public typealias ReopenForumTopicResponse = ResponseSuccess<Bool>

    /**
     * https://core.telegram.org/bots/api#reopenforumtopic
     * Use this method to reopen a closed topic in a forum supergroup chat. The bot must be an administrator in the chat for this to work and must have the can_manage_topics administrator rights, unless it is the creator of the topic. Returns True on success.
     */
    public func reopenForumTopic(params: ReopenForumTopicParams) throws -> ReopenForumTopicResponse {
        let data = try request("reopenForumTopic", params)
        return try JSONDecoder().decode(ReopenForumTopicResponse.self, from: data)
    }
}

extension TelegramAPI {
    /** https://core.telegram.org/bots/api#deleteforumtopic */
    public struct DeleteForumTopicParams: Codable {
        /** Integer or String | Unique identifier for the target chat or username of the target supergroup (in the format @supergroupusername) */
        public let chat_id: Either2<Int, String>
        /** Integer | Unique identifier for the target message thread of the forum topic */
        public let message_thread_id: Int
        public init(chat_id: Either2<Int, String> ,message_thread_id: Int) {
            self.chat_id = chat_id
            self.message_thread_id = message_thread_id
        }
    }
}

extension TelegramAPI {

    public typealias DeleteForumTopicResponse = ResponseSuccess<Bool>

    /**
     * https://core.telegram.org/bots/api#deleteforumtopic
     * Use this method to delete a forum topic along with all its messages in a forum supergroup chat. The bot must be an administrator in the chat for this to work and must have the can_delete_messages administrator rights. Returns True on success.
     */
    public func deleteForumTopic(params: DeleteForumTopicParams) throws -> DeleteForumTopicResponse {
        let data = try request("deleteForumTopic", params)
        return try JSONDecoder().decode(DeleteForumTopicResponse.self, from: data)
    }
}

extension TelegramAPI {
    /** https://core.telegram.org/bots/api#unpinallforumtopicmessages */
    public struct UnpinAllForumTopicMessagesParams: Codable {
        /** Integer or String | Unique identifier for the target chat or username of the target supergroup (in the format @supergroupusername) */
        public let chat_id: Either2<Int, String>
        /** Integer | Unique identifier for the target message thread of the forum topic */
        public let message_thread_id: Int
        public init(chat_id: Either2<Int, String> ,message_thread_id: Int) {
            self.chat_id = chat_id
            self.message_thread_id = message_thread_id
        }
    }
}

extension TelegramAPI {

    public typealias UnpinAllForumTopicMessagesResponse = ResponseSuccess<Bool>

    /**
     * https://core.telegram.org/bots/api#unpinallforumtopicmessages
     * Use this method to clear the list of pinned messages in a forum topic. The bot must be an administrator in the chat for this to work and must have the can_pin_messages administrator right in the supergroup. Returns True on success.
     */
    public func unpinAllForumTopicMessages(params: UnpinAllForumTopicMessagesParams) throws -> UnpinAllForumTopicMessagesResponse {
        let data = try request("unpinAllForumTopicMessages", params)
        return try JSONDecoder().decode(UnpinAllForumTopicMessagesResponse.self, from: data)
    }
}

extension TelegramAPI {
    /** https://core.telegram.org/bots/api#editgeneralforumtopic */
    public struct EditGeneralForumTopicParams: Codable {
        /** Integer or String | Unique identifier for the target chat or username of the target supergroup (in the format @supergroupusername) */
        public let chat_id: Either2<Int, String>
        /** String | New topic name, 1-128 characters */
        public let name: String
        public init(chat_id: Either2<Int, String> ,name: String) {
            self.chat_id = chat_id
            self.name = name
        }
    }
}

extension TelegramAPI {

    public typealias EditGeneralForumTopicResponse = ResponseSuccess<Bool>

    /**
     * https://core.telegram.org/bots/api#editgeneralforumtopic
     * Use this method to edit the name of the 'General' topic in a forum supergroup chat. The bot must be an administrator in the chat for this to work and must have the can_manage_topics administrator rights. Returns True on success.
     */
    public func editGeneralForumTopic(params: EditGeneralForumTopicParams) throws -> EditGeneralForumTopicResponse {
        let data = try request("editGeneralForumTopic", params)
        return try JSONDecoder().decode(EditGeneralForumTopicResponse.self, from: data)
    }
}

extension TelegramAPI {
    /** https://core.telegram.org/bots/api#closegeneralforumtopic */
    public struct CloseGeneralForumTopicParams: Codable {
        /** Integer or String | Unique identifier for the target chat or username of the target supergroup (in the format @supergroupusername) */
        public let chat_id: Either2<Int, String>
        public init(chat_id: Either2<Int, String>) {
            self.chat_id = chat_id
        }
    }
}

extension TelegramAPI {

    public typealias CloseGeneralForumTopicResponse = ResponseSuccess<Bool>

    /**
     * https://core.telegram.org/bots/api#closegeneralforumtopic
     * Use this method to close an open 'General' topic in a forum supergroup chat. The bot must be an administrator in the chat for this to work and must have the can_manage_topics administrator rights. Returns True on success.
     */
    public func closeGeneralForumTopic(params: CloseGeneralForumTopicParams) throws -> CloseGeneralForumTopicResponse {
        let data = try request("closeGeneralForumTopic", params)
        return try JSONDecoder().decode(CloseGeneralForumTopicResponse.self, from: data)
    }
}

extension TelegramAPI {
    /** https://core.telegram.org/bots/api#reopengeneralforumtopic */
    public struct ReopenGeneralForumTopicParams: Codable {
        /** Integer or String | Unique identifier for the target chat or username of the target supergroup (in the format @supergroupusername) */
        public let chat_id: Either2<Int, String>
        public init(chat_id: Either2<Int, String>) {
            self.chat_id = chat_id
        }
    }
}

extension TelegramAPI {

    public typealias ReopenGeneralForumTopicResponse = ResponseSuccess<Bool>

    /**
     * https://core.telegram.org/bots/api#reopengeneralforumtopic
     * Use this method to reopen a closed 'General' topic in a forum supergroup chat. The bot must be an administrator in the chat for this to work and must have the can_manage_topics administrator rights. The topic will be automatically unhidden if it was hidden. Returns True on success.
     */
    public func reopenGeneralForumTopic(params: ReopenGeneralForumTopicParams) throws -> ReopenGeneralForumTopicResponse {
        let data = try request("reopenGeneralForumTopic", params)
        return try JSONDecoder().decode(ReopenGeneralForumTopicResponse.self, from: data)
    }
}

extension TelegramAPI {
    /** https://core.telegram.org/bots/api#hidegeneralforumtopic */
    public struct HideGeneralForumTopicParams: Codable {
        /** Integer or String | Unique identifier for the target chat or username of the target supergroup (in the format @supergroupusername) */
        public let chat_id: Either2<Int, String>
        public init(chat_id: Either2<Int, String>) {
            self.chat_id = chat_id
        }
    }
}

extension TelegramAPI {

    public typealias HideGeneralForumTopicResponse = ResponseSuccess<Bool>

    /**
     * https://core.telegram.org/bots/api#hidegeneralforumtopic
     * Use this method to hide the 'General' topic in a forum supergroup chat. The bot must be an administrator in the chat for this to work and must have the can_manage_topics administrator rights. The topic will be automatically closed if it was open. Returns True on success.
     */
    public func hideGeneralForumTopic(params: HideGeneralForumTopicParams) throws -> HideGeneralForumTopicResponse {
        let data = try request("hideGeneralForumTopic", params)
        return try JSONDecoder().decode(HideGeneralForumTopicResponse.self, from: data)
    }
}

extension TelegramAPI {
    /** https://core.telegram.org/bots/api#unhidegeneralforumtopic */
    public struct UnhideGeneralForumTopicParams: Codable {
        /** Integer or String | Unique identifier for the target chat or username of the target supergroup (in the format @supergroupusername) */
        public let chat_id: Either2<Int, String>
        public init(chat_id: Either2<Int, String>) {
            self.chat_id = chat_id
        }
    }
}

extension TelegramAPI {

    public typealias UnhideGeneralForumTopicResponse = ResponseSuccess<Bool>

    /**
     * https://core.telegram.org/bots/api#unhidegeneralforumtopic
     * Use this method to unhide the 'General' topic in a forum supergroup chat. The bot must be an administrator in the chat for this to work and must have the can_manage_topics administrator rights. Returns True on success.
     */
    public func unhideGeneralForumTopic(params: UnhideGeneralForumTopicParams) throws -> UnhideGeneralForumTopicResponse {
        let data = try request("unhideGeneralForumTopic", params)
        return try JSONDecoder().decode(UnhideGeneralForumTopicResponse.self, from: data)
    }
}

extension TelegramAPI {
    /** https://core.telegram.org/bots/api#unpinallgeneralforumtopicmessages */
    public struct UnpinAllGeneralForumTopicMessagesParams: Codable {
        /** Integer or String | Unique identifier for the target chat or username of the target supergroup (in the format @supergroupusername) */
        public let chat_id: Either2<Int, String>
        public init(chat_id: Either2<Int, String>) {
            self.chat_id = chat_id
        }
    }
}

extension TelegramAPI {

    public typealias UnpinAllGeneralForumTopicMessagesResponse = ResponseSuccess<Bool>

    /**
     * https://core.telegram.org/bots/api#unpinallgeneralforumtopicmessages
     * Use this method to clear the list of pinned messages in a General forum topic. The bot must be an administrator in the chat for this to work and must have the can_pin_messages administrator right in the supergroup. Returns True on success.
     */
    public func unpinAllGeneralForumTopicMessages(params: UnpinAllGeneralForumTopicMessagesParams) throws -> UnpinAllGeneralForumTopicMessagesResponse {
        let data = try request("unpinAllGeneralForumTopicMessages", params)
        return try JSONDecoder().decode(UnpinAllGeneralForumTopicMessagesResponse.self, from: data)
    }
}

extension TelegramAPI {
    /** https://core.telegram.org/bots/api#answercallbackquery */
    public struct AnswerCallbackQueryParams: Codable {
        /** String | Unique identifier for the query to be answered */
        public let callback_query_id: String
        /** String | Text of the notification. If not specified, nothing will be shown to the user, 0-200 characters */
        public let text: String?
        /** Boolean | If True, an alert will be shown by the client instead of a notification at the top of the chat screen. Defaults to false. */
        public let show_alert: Bool?
        /** String | URL that will be opened by the user's client. If you have created a Game and accepted the conditions via @BotFather, specify the URL that opens your game - note that this will only work if the query comes from a callback_game button. Otherwise, you may use links like t.me/your_bot?start=XXXX that open your bot with a parameter. */
        public let url: String?
        /** Integer | The maximum amount of time in seconds that the result of the callback query may be cached client-side. Telegram apps will support caching starting in version 3.14. Defaults to 0. */
        public let cache_time: Int?
        public init(callback_query_id: String ,text: String? = nil ,show_alert: Bool? = nil ,url: String? = nil ,cache_time: Int? = nil) {
            self.callback_query_id = callback_query_id
            self.text = text
            self.show_alert = show_alert
            self.url = url
            self.cache_time = cache_time
        }
    }
}

extension TelegramAPI {

    public typealias AnswerCallbackQueryResponse = ResponseSuccess<Bool>

    /**
     * https://core.telegram.org/bots/api#answercallbackquery
     * Use this method to send answers to callback queries sent from inline keyboards. The answer will be displayed to the user as a notification at the top of the chat screen or as an alert. On success, True is returned.
     */
    public func answerCallbackQuery(params: AnswerCallbackQueryParams) throws -> AnswerCallbackQueryResponse {
        let data = try request("answerCallbackQuery", params)
        return try JSONDecoder().decode(AnswerCallbackQueryResponse.self, from: data)
    }
}

extension TelegramAPI {
    /** https://core.telegram.org/bots/api#getuserchatboosts */
    public struct GetUserChatBoostsParams: Codable {
        /** Integer or String | Unique identifier for the chat or username of the channel (in the format @channelusername) */
        public let chat_id: Either2<Int, String>
        /** Integer | Unique identifier of the target user */
        public let user_id: Int
        public init(chat_id: Either2<Int, String> ,user_id: Int) {
            self.chat_id = chat_id
            self.user_id = user_id
        }
    }
}

extension TelegramAPI {

    public typealias GetUserChatBoostsResponse = ResponseSuccess<UserChatBoosts>

    /**
     * https://core.telegram.org/bots/api#getuserchatboosts
     * Use this method to get the list of boosts added to a chat by a user. Requires administrator rights in the chat. Returns a UserChatBoosts object.
     */
    public func getUserChatBoosts(params: GetUserChatBoostsParams) throws -> GetUserChatBoostsResponse {
        let data = try request("getUserChatBoosts", params)
        return try JSONDecoder().decode(GetUserChatBoostsResponse.self, from: data)
    }
}

extension TelegramAPI {
    /** https://core.telegram.org/bots/api#getbusinessconnection */
    public struct GetBusinessConnectionParams: Codable {
        /** String | Unique identifier of the business connection */
        public let business_connection_id: String
        public init(business_connection_id: String) {
            self.business_connection_id = business_connection_id
        }
    }
}

extension TelegramAPI {

    public typealias GetBusinessConnectionResponse = ResponseSuccess<BusinessConnection>

    /**
     * https://core.telegram.org/bots/api#getbusinessconnection
     * Use this method to get information about the connection of the bot with a business account. Returns a BusinessConnection object on success.
     */
    public func getBusinessConnection(params: GetBusinessConnectionParams) throws -> GetBusinessConnectionResponse {
        let data = try request("getBusinessConnection", params)
        return try JSONDecoder().decode(GetBusinessConnectionResponse.self, from: data)
    }
}

extension TelegramAPI {
    /** https://core.telegram.org/bots/api#setmycommands */
    public struct SetMyCommandsParams: Codable {
        /** Array of BotCommand | A JSON-serialized list of bot commands to be set as the list of the bot's commands. At most 100 commands can be specified. */
        public let commands: Array<BotCommand>
        /** BotCommandScope | A JSON-serialized object, describing scope of users for which the commands are relevant. Defaults to BotCommandScopeDefault. */
        public let scope: BotCommandScope?
        /** String | A two-letter ISO 639-1 language code. If empty, commands will be applied to all users from the given scope, for whose language there are no dedicated commands */
        public let language_code: String?
        public init(commands: Array<BotCommand> ,scope: BotCommandScope? = nil ,language_code: String? = nil) {
            self.commands = commands
            self.scope = scope
            self.language_code = language_code
        }
    }
}

extension TelegramAPI {

    public typealias SetMyCommandsResponse = ResponseSuccess<Bool>

    /**
     * https://core.telegram.org/bots/api#setmycommands
     * Use this method to change the list of the bot's commands. See this manual for more details about bot commands. Returns True on success.
     */
    public func setMyCommands(params: SetMyCommandsParams) throws -> SetMyCommandsResponse {
        let data = try request("setMyCommands", params)
        return try JSONDecoder().decode(SetMyCommandsResponse.self, from: data)
    }
}

extension TelegramAPI {
    /** https://core.telegram.org/bots/api#deletemycommands */
    public struct DeleteMyCommandsParams: Codable {
        /** BotCommandScope | A JSON-serialized object, describing scope of users for which the commands are relevant. Defaults to BotCommandScopeDefault. */
        public let scope: BotCommandScope?
        /** String | A two-letter ISO 639-1 language code. If empty, commands will be applied to all users from the given scope, for whose language there are no dedicated commands */
        public let language_code: String?
        public init(scope: BotCommandScope? = nil ,language_code: String? = nil) {
            self.scope = scope
            self.language_code = language_code
        }
    }
}

extension TelegramAPI {

    public typealias DeleteMyCommandsResponse = ResponseSuccess<Bool>

    /**
     * https://core.telegram.org/bots/api#deletemycommands
     * Use this method to delete the list of the bot's commands for the given scope and user language. After deletion, higher level commands will be shown to affected users. Returns True on success.
     */
    public func deleteMyCommands(params: DeleteMyCommandsParams) throws -> DeleteMyCommandsResponse {
        let data = try request("deleteMyCommands", params)
        return try JSONDecoder().decode(DeleteMyCommandsResponse.self, from: data)
    }
}

extension TelegramAPI {
    /** https://core.telegram.org/bots/api#getmycommands */
    public struct GetMyCommandsParams: Codable {
        /** BotCommandScope | A JSON-serialized object, describing scope of users. Defaults to BotCommandScopeDefault. */
        public let scope: BotCommandScope?
        /** String | A two-letter ISO 639-1 language code or an empty string */
        public let language_code: String?
        public init(scope: BotCommandScope? = nil ,language_code: String? = nil) {
            self.scope = scope
            self.language_code = language_code
        }
    }
}

extension TelegramAPI {

    public typealias GetMyCommandsResponse = ResponseSuccess<Array<BotCommand>>

    /**
     * https://core.telegram.org/bots/api#getmycommands
     * Use this method to get the current list of the bot's commands for the given scope and user language. Returns an Array of BotCommand objects. If commands aren't set, an empty list is returned.
     */
    public func getMyCommands(params: GetMyCommandsParams) throws -> GetMyCommandsResponse {
        let data = try request("getMyCommands", params)
        return try JSONDecoder().decode(GetMyCommandsResponse.self, from: data)
    }
}

extension TelegramAPI {
    /** https://core.telegram.org/bots/api#setmyname */
    public struct SetMyNameParams: Codable {
        /** String | New bot name; 0-64 characters. Pass an empty string to remove the dedicated name for the given language. */
        public let name: String?
        /** String | A two-letter ISO 639-1 language code. If empty, the name will be shown to all users for whose language there is no dedicated name. */
        public let language_code: String?
        public init(name: String? = nil ,language_code: String? = nil) {
            self.name = name
            self.language_code = language_code
        }
    }
}

extension TelegramAPI {

    public typealias SetMyNameResponse = ResponseSuccess<Bool>

    /**
     * https://core.telegram.org/bots/api#setmyname
     * Use this method to change the bot's name. Returns True on success.
     */
    public func setMyName(params: SetMyNameParams) throws -> SetMyNameResponse {
        let data = try request("setMyName", params)
        return try JSONDecoder().decode(SetMyNameResponse.self, from: data)
    }
}

extension TelegramAPI {
    /** https://core.telegram.org/bots/api#getmyname */
    public struct GetMyNameParams: Codable {
        /** String | A two-letter ISO 639-1 language code or an empty string */
        public let language_code: String?
        public init(language_code: String? = nil) {
            self.language_code = language_code
        }
    }
}

extension TelegramAPI {

    public typealias GetMyNameResponse = ResponseSuccess<BotName>

    /**
     * https://core.telegram.org/bots/api#getmyname
     * Use this method to get the current bot name for the given user language. Returns BotName on success.
     */
    public func getMyName(params: GetMyNameParams) throws -> GetMyNameResponse {
        let data = try request("getMyName", params)
        return try JSONDecoder().decode(GetMyNameResponse.self, from: data)
    }
}

extension TelegramAPI {
    /** https://core.telegram.org/bots/api#setmydescription */
    public struct SetMyDescriptionParams: Codable {
        /** String | New bot description; 0-512 characters. Pass an empty string to remove the dedicated description for the given language. */
        public let description: String?
        /** String | A two-letter ISO 639-1 language code. If empty, the description will be applied to all users for whose language there is no dedicated description. */
        public let language_code: String?
        public init(description: String? = nil ,language_code: String? = nil) {
            self.description = description
            self.language_code = language_code
        }
    }
}

extension TelegramAPI {

    public typealias SetMyDescriptionResponse = ResponseSuccess<Bool>

    /**
     * https://core.telegram.org/bots/api#setmydescription
     * Use this method to change the bot's description, which is shown in the chat with the bot if the chat is empty. Returns True on success.
     */
    public func setMyDescription(params: SetMyDescriptionParams) throws -> SetMyDescriptionResponse {
        let data = try request("setMyDescription", params)
        return try JSONDecoder().decode(SetMyDescriptionResponse.self, from: data)
    }
}

extension TelegramAPI {
    /** https://core.telegram.org/bots/api#getmydescription */
    public struct GetMyDescriptionParams: Codable {
        /** String | A two-letter ISO 639-1 language code or an empty string */
        public let language_code: String?
        public init(language_code: String? = nil) {
            self.language_code = language_code
        }
    }
}

extension TelegramAPI {

    public typealias GetMyDescriptionResponse = ResponseSuccess<BotDescription>

    /**
     * https://core.telegram.org/bots/api#getmydescription
     * Use this method to get the current bot description for the given user language. Returns BotDescription on success.
     */
    public func getMyDescription(params: GetMyDescriptionParams) throws -> GetMyDescriptionResponse {
        let data = try request("getMyDescription", params)
        return try JSONDecoder().decode(GetMyDescriptionResponse.self, from: data)
    }
}

extension TelegramAPI {
    /** https://core.telegram.org/bots/api#setmyshortdescription */
    public struct SetMyShortDescriptionParams: Codable {
        /** String | New short description for the bot; 0-120 characters. Pass an empty string to remove the dedicated short description for the given language. */
        public let short_description: String?
        /** String | A two-letter ISO 639-1 language code. If empty, the short description will be applied to all users for whose language there is no dedicated short description. */
        public let language_code: String?
        public init(short_description: String? = nil ,language_code: String? = nil) {
            self.short_description = short_description
            self.language_code = language_code
        }
    }
}

extension TelegramAPI {

    public typealias SetMyShortDescriptionResponse = ResponseSuccess<Bool>

    /**
     * https://core.telegram.org/bots/api#setmyshortdescription
     * Use this method to change the bot's short description, which is shown on the bot's profile page and is sent together with the link when users share the bot. Returns True on success.
     */
    public func setMyShortDescription(params: SetMyShortDescriptionParams) throws -> SetMyShortDescriptionResponse {
        let data = try request("setMyShortDescription", params)
        return try JSONDecoder().decode(SetMyShortDescriptionResponse.self, from: data)
    }
}

extension TelegramAPI {
    /** https://core.telegram.org/bots/api#getmyshortdescription */
    public struct GetMyShortDescriptionParams: Codable {
        /** String | A two-letter ISO 639-1 language code or an empty string */
        public let language_code: String?
        public init(language_code: String? = nil) {
            self.language_code = language_code
        }
    }
}

extension TelegramAPI {

    public typealias GetMyShortDescriptionResponse = ResponseSuccess<BotShortDescription>

    /**
     * https://core.telegram.org/bots/api#getmyshortdescription
     * Use this method to get the current bot short description for the given user language. Returns BotShortDescription on success.
     */
    public func getMyShortDescription(params: GetMyShortDescriptionParams) throws -> GetMyShortDescriptionResponse {
        let data = try request("getMyShortDescription", params)
        return try JSONDecoder().decode(GetMyShortDescriptionResponse.self, from: data)
    }
}

extension TelegramAPI {
    /** https://core.telegram.org/bots/api#setchatmenubutton */
    public struct SetChatMenuButtonParams: Codable {
        /** Integer | Unique identifier for the target private chat. If not specified, default bot's menu button will be changed */
        public let chat_id: Int?
        /** MenuButton | A JSON-serialized object for the bot's new menu button. Defaults to MenuButtonDefault */
        public let menu_button: MenuButton?
        public init(chat_id: Int? = nil ,menu_button: MenuButton? = nil) {
            self.chat_id = chat_id
            self.menu_button = menu_button
        }
    }
}

extension TelegramAPI {

    public typealias SetChatMenuButtonResponse = ResponseSuccess<Bool>

    /**
     * https://core.telegram.org/bots/api#setchatmenubutton
     * Use this method to change the bot's menu button in a private chat, or the default menu button. Returns True on success.
     */
    public func setChatMenuButton(params: SetChatMenuButtonParams) throws -> SetChatMenuButtonResponse {
        let data = try request("setChatMenuButton", params)
        return try JSONDecoder().decode(SetChatMenuButtonResponse.self, from: data)
    }
}

extension TelegramAPI {
    /** https://core.telegram.org/bots/api#getchatmenubutton */
    public struct GetChatMenuButtonParams: Codable {
        /** Integer | Unique identifier for the target private chat. If not specified, default bot's menu button will be returned */
        public let chat_id: Int?
        public init(chat_id: Int? = nil) {
            self.chat_id = chat_id
        }
    }
}

extension TelegramAPI {

    public typealias GetChatMenuButtonResponse = ResponseSuccess<MenuButton>

    /**
     * https://core.telegram.org/bots/api#getchatmenubutton
     * Use this method to get the current value of the bot's menu button in a private chat, or the default menu button. Returns MenuButton on success.
     */
    public func getChatMenuButton(params: GetChatMenuButtonParams) throws -> GetChatMenuButtonResponse {
        let data = try request("getChatMenuButton", params)
        return try JSONDecoder().decode(GetChatMenuButtonResponse.self, from: data)
    }
}

extension TelegramAPI {
    /** https://core.telegram.org/bots/api#setmydefaultadministratorrights */
    public struct SetMyDefaultAdministratorRightsParams: Codable {
        /** ChatAdministratorRights | A JSON-serialized object describing new default administrator rights. If not specified, the default administrator rights will be cleared. */
        public let rights: ChatAdministratorRights?
        /** Boolean | Pass True to change the default administrator rights of the bot in channels. Otherwise, the default administrator rights of the bot for groups and supergroups will be changed. */
        public let for_channels: Bool?
        public init(rights: ChatAdministratorRights? = nil ,for_channels: Bool? = nil) {
            self.rights = rights
            self.for_channels = for_channels
        }
    }
}

extension TelegramAPI {

    public typealias SetMyDefaultAdministratorRightsResponse = ResponseSuccess<Bool>

    /**
     * https://core.telegram.org/bots/api#setmydefaultadministratorrights
     * Use this method to change the default administrator rights requested by the bot when it's added as an administrator to groups or channels. These rights will be suggested to users, but they are free to modify the list before adding the bot. Returns True on success.
     */
    public func setMyDefaultAdministratorRights(params: SetMyDefaultAdministratorRightsParams) throws -> SetMyDefaultAdministratorRightsResponse {
        let data = try request("setMyDefaultAdministratorRights", params)
        return try JSONDecoder().decode(SetMyDefaultAdministratorRightsResponse.self, from: data)
    }
}

extension TelegramAPI {
    /** https://core.telegram.org/bots/api#getmydefaultadministratorrights */
    public struct GetMyDefaultAdministratorRightsParams: Codable {
        /** Boolean | Pass True to get default administrator rights of the bot in channels. Otherwise, default administrator rights of the bot for groups and supergroups will be returned. */
        public let for_channels: Bool?
        public init(for_channels: Bool? = nil) {
            self.for_channels = for_channels
        }
    }
}

extension TelegramAPI {

    public typealias GetMyDefaultAdministratorRightsResponse = ResponseSuccess<ChatAdministratorRights>

    /**
     * https://core.telegram.org/bots/api#getmydefaultadministratorrights
     * Use this method to get the current default administrator rights of the bot. Returns ChatAdministratorRights on success.
     */
    public func getMyDefaultAdministratorRights(params: GetMyDefaultAdministratorRightsParams) throws -> GetMyDefaultAdministratorRightsResponse {
        let data = try request("getMyDefaultAdministratorRights", params)
        return try JSONDecoder().decode(GetMyDefaultAdministratorRightsResponse.self, from: data)
    }
}

extension TelegramAPI {
    /** https://core.telegram.org/bots/api#editmessagetext */
    public struct EditMessageTextParams: Codable {
        /** String | Unique identifier of the business connection on behalf of which the message to be edited was sent */
        public let business_connection_id: String?
        /** Integer or String | Required if inline_message_id is not specified. Unique identifier for the target chat or username of the target channel (in the format @channelusername) */
        public let chat_id: Either2<Int, String>?
        /** Integer | Required if inline_message_id is not specified. Identifier of the message to edit */
        public let message_id: Int?
        /** String | Required if chat_id and message_id are not specified. Identifier of the inline message */
        public let inline_message_id: String?
        /** String | New text of the message, 1-4096 characters after entities parsing */
        public let text: String
        /** String | Mode for parsing entities in the message text. See formatting options for more details. */
        public let parse_mode: String?
        /** Array of MessageEntity | A JSON-serialized list of special entities that appear in message text, which can be specified instead of parse_mode */
        public let entities: Array<MessageEntity>?
        /** LinkPreviewOptions | Link preview generation options for the message */
        public let link_preview_options: LinkPreviewOptions?
        /** InlineKeyboardMarkup | A JSON-serialized object for an inline keyboard. */
        public let reply_markup: InlineKeyboardMarkup?
        public init(business_connection_id: String? = nil ,chat_id: Either2<Int, String>? = nil ,message_id: Int? = nil ,inline_message_id: String? = nil ,text: String ,parse_mode: String? = nil ,entities: Array<MessageEntity>? = nil ,link_preview_options: LinkPreviewOptions? = nil ,reply_markup: InlineKeyboardMarkup? = nil) {
            self.business_connection_id = business_connection_id
            self.chat_id = chat_id
            self.message_id = message_id
            self.inline_message_id = inline_message_id
            self.text = text
            self.parse_mode = parse_mode
            self.entities = entities
            self.link_preview_options = link_preview_options
            self.reply_markup = reply_markup
        }
    }
}

extension TelegramAPI {

    public typealias EditMessageTextResponse = ResponseSuccess<Either2<Message, Bool>>

    /**
     * https://core.telegram.org/bots/api#editmessagetext
     * Use this method to edit text and game messages. On success, if the edited message is not an inline message, the edited Message is returned, otherwise True is returned. Note that business messages that were not sent by the bot and do not contain an inline keyboard can only be edited within 48 hours from the time they were sent.
     */
    public func editMessageText(params: EditMessageTextParams) throws -> EditMessageTextResponse {
        let data = try request("editMessageText", params)
        return try JSONDecoder().decode(EditMessageTextResponse.self, from: data)
    }
}

extension TelegramAPI {
    /** https://core.telegram.org/bots/api#editmessagecaption */
    public struct EditMessageCaptionParams: Codable {
        /** String | Unique identifier of the business connection on behalf of which the message to be edited was sent */
        public let business_connection_id: String?
        /** Integer or String | Required if inline_message_id is not specified. Unique identifier for the target chat or username of the target channel (in the format @channelusername) */
        public let chat_id: Either2<Int, String>?
        /** Integer | Required if inline_message_id is not specified. Identifier of the message to edit */
        public let message_id: Int?
        /** String | Required if chat_id and message_id are not specified. Identifier of the inline message */
        public let inline_message_id: String?
        /** String | New caption of the message, 0-1024 characters after entities parsing */
        public let caption: String?
        /** String | Mode for parsing entities in the message caption. See formatting options for more details. */
        public let parse_mode: String?
        /** Array of MessageEntity | A JSON-serialized list of special entities that appear in the caption, which can be specified instead of parse_mode */
        public let caption_entities: Array<MessageEntity>?
        /** Boolean | Pass True, if the caption must be shown above the message media. Supported only for animation, photo and video messages. */
        public let show_caption_above_media: Bool?
        /** InlineKeyboardMarkup | A JSON-serialized object for an inline keyboard. */
        public let reply_markup: InlineKeyboardMarkup?
        public init(business_connection_id: String? = nil ,chat_id: Either2<Int, String>? = nil ,message_id: Int? = nil ,inline_message_id: String? = nil ,caption: String? = nil ,parse_mode: String? = nil ,caption_entities: Array<MessageEntity>? = nil ,show_caption_above_media: Bool? = nil ,reply_markup: InlineKeyboardMarkup? = nil) {
            self.business_connection_id = business_connection_id
            self.chat_id = chat_id
            self.message_id = message_id
            self.inline_message_id = inline_message_id
            self.caption = caption
            self.parse_mode = parse_mode
            self.caption_entities = caption_entities
            self.show_caption_above_media = show_caption_above_media
            self.reply_markup = reply_markup
        }
    }
}

extension TelegramAPI {

    public typealias EditMessageCaptionResponse = ResponseSuccess<Either2<Message, Bool>>

    /**
     * https://core.telegram.org/bots/api#editmessagecaption
     * Use this method to edit captions of messages. On success, if the edited message is not an inline message, the edited Message is returned, otherwise True is returned. Note that business messages that were not sent by the bot and do not contain an inline keyboard can only be edited within 48 hours from the time they were sent.
     */
    public func editMessageCaption(params: EditMessageCaptionParams) throws -> EditMessageCaptionResponse {
        let data = try request("editMessageCaption", params)
        return try JSONDecoder().decode(EditMessageCaptionResponse.self, from: data)
    }
}

extension TelegramAPI {
    /** https://core.telegram.org/bots/api#editmessagemedia */
    public struct EditMessageMediaParams: Codable {
        /** String | Unique identifier of the business connection on behalf of which the message to be edited was sent */
        public let business_connection_id: String?
        /** Integer or String | Required if inline_message_id is not specified. Unique identifier for the target chat or username of the target channel (in the format @channelusername) */
        public let chat_id: Either2<Int, String>?
        /** Integer | Required if inline_message_id is not specified. Identifier of the message to edit */
        public let message_id: Int?
        /** String | Required if chat_id and message_id are not specified. Identifier of the inline message */
        public let inline_message_id: String?
        /** InputMedia | A JSON-serialized object for a new media content of the message */
        public let media: InputMedia
        /** InlineKeyboardMarkup | A JSON-serialized object for a new inline keyboard. */
        public let reply_markup: InlineKeyboardMarkup?
        public init(business_connection_id: String? = nil ,chat_id: Either2<Int, String>? = nil ,message_id: Int? = nil ,inline_message_id: String? = nil ,media: InputMedia ,reply_markup: InlineKeyboardMarkup? = nil) {
            self.business_connection_id = business_connection_id
            self.chat_id = chat_id
            self.message_id = message_id
            self.inline_message_id = inline_message_id
            self.media = media
            self.reply_markup = reply_markup
        }
    }
}

extension TelegramAPI {

    public typealias EditMessageMediaResponse = ResponseSuccess<Either2<Message, Bool>>

    /**
     * https://core.telegram.org/bots/api#editmessagemedia
     * Use this method to edit animation, audio, document, photo, or video messages, or to add media to text messages. If a message is part of a message album, then it can be edited only to an audio for audio albums, only to a document for document albums and to a photo or a video otherwise. When an inline message is edited, a new file can't be uploaded; use a previously uploaded file via its file_id or specify a URL. On success, if the edited message is not an inline message, the edited Message is returned, otherwise True is returned. Note that business messages that were not sent by the bot and do not contain an inline keyboard can only be edited within 48 hours from the time they were sent.
     */
    public func editMessageMedia(params: EditMessageMediaParams) throws -> EditMessageMediaResponse {
        let data = try request("editMessageMedia", params)
        return try JSONDecoder().decode(EditMessageMediaResponse.self, from: data)
    }
}

extension TelegramAPI {
    /** https://core.telegram.org/bots/api#editmessagelivelocation */
    public struct EditMessageLiveLocationParams: Codable {
        /** String | Unique identifier of the business connection on behalf of which the message to be edited was sent */
        public let business_connection_id: String?
        /** Integer or String | Required if inline_message_id is not specified. Unique identifier for the target chat or username of the target channel (in the format @channelusername) */
        public let chat_id: Either2<Int, String>?
        /** Integer | Required if inline_message_id is not specified. Identifier of the message to edit */
        public let message_id: Int?
        /** String | Required if chat_id and message_id are not specified. Identifier of the inline message */
        public let inline_message_id: String?
        /** Float | Latitude of new location */
        public let latitude: Float
        /** Float | Longitude of new location */
        public let longitude: Float
        /** Integer | New period in seconds during which the location can be updated, starting from the message send date. If 0x7FFFFFFF is specified, then the location can be updated forever. Otherwise, the new value must not exceed the current live_period by more than a day, and the live location expiration date must remain within the next 90 days. If not specified, then live_period remains unchanged */
        public let live_period: Int?
        /** Float | The radius of uncertainty for the location, measured in meters; 0-1500 */
        public let horizontal_accuracy: Float?
        /** Integer | Direction in which the user is moving, in degrees. Must be between 1 and 360 if specified. */
        public let heading: Int?
        /** Integer | The maximum distance for proximity alerts about approaching another chat member, in meters. Must be between 1 and 100000 if specified. */
        public let proximity_alert_radius: Int?
        /** InlineKeyboardMarkup | A JSON-serialized object for a new inline keyboard. */
        public let reply_markup: InlineKeyboardMarkup?
        public init(business_connection_id: String? = nil ,chat_id: Either2<Int, String>? = nil ,message_id: Int? = nil ,inline_message_id: String? = nil ,latitude: Float ,longitude: Float ,live_period: Int? = nil ,horizontal_accuracy: Float? = nil ,heading: Int? = nil ,proximity_alert_radius: Int? = nil ,reply_markup: InlineKeyboardMarkup? = nil) {
            self.business_connection_id = business_connection_id
            self.chat_id = chat_id
            self.message_id = message_id
            self.inline_message_id = inline_message_id
            self.latitude = latitude
            self.longitude = longitude
            self.live_period = live_period
            self.horizontal_accuracy = horizontal_accuracy
            self.heading = heading
            self.proximity_alert_radius = proximity_alert_radius
            self.reply_markup = reply_markup
        }
    }
}

extension TelegramAPI {

    public typealias EditMessageLiveLocationResponse = ResponseSuccess<Either2<Message, Bool>>

    /**
     * https://core.telegram.org/bots/api#editmessagelivelocation
     * Use this method to edit live location messages. A location can be edited until its live_period expires or editing is explicitly disabled by a call to stopMessageLiveLocation. On success, if the edited message is not an inline message, the edited Message is returned, otherwise True is returned.
     */
    public func editMessageLiveLocation(params: EditMessageLiveLocationParams) throws -> EditMessageLiveLocationResponse {
        let data = try request("editMessageLiveLocation", params)
        return try JSONDecoder().decode(EditMessageLiveLocationResponse.self, from: data)
    }
}

extension TelegramAPI {
    /** https://core.telegram.org/bots/api#stopmessagelivelocation */
    public struct StopMessageLiveLocationParams: Codable {
        /** String | Unique identifier of the business connection on behalf of which the message to be edited was sent */
        public let business_connection_id: String?
        /** Integer or String | Required if inline_message_id is not specified. Unique identifier for the target chat or username of the target channel (in the format @channelusername) */
        public let chat_id: Either2<Int, String>?
        /** Integer | Required if inline_message_id is not specified. Identifier of the message with live location to stop */
        public let message_id: Int?
        /** String | Required if chat_id and message_id are not specified. Identifier of the inline message */
        public let inline_message_id: String?
        /** InlineKeyboardMarkup | A JSON-serialized object for a new inline keyboard. */
        public let reply_markup: InlineKeyboardMarkup?
        public init(business_connection_id: String? = nil ,chat_id: Either2<Int, String>? = nil ,message_id: Int? = nil ,inline_message_id: String? = nil ,reply_markup: InlineKeyboardMarkup? = nil) {
            self.business_connection_id = business_connection_id
            self.chat_id = chat_id
            self.message_id = message_id
            self.inline_message_id = inline_message_id
            self.reply_markup = reply_markup
        }
    }
}

extension TelegramAPI {

    public typealias StopMessageLiveLocationResponse = ResponseSuccess<Either2<Message, Bool>>

    /**
     * https://core.telegram.org/bots/api#stopmessagelivelocation
     * Use this method to stop updating a live location message before live_period expires. On success, if the message is not an inline message, the edited Message is returned, otherwise True is returned.
     */
    public func stopMessageLiveLocation(params: StopMessageLiveLocationParams) throws -> StopMessageLiveLocationResponse {
        let data = try request("stopMessageLiveLocation", params)
        return try JSONDecoder().decode(StopMessageLiveLocationResponse.self, from: data)
    }
}

extension TelegramAPI {
    /** https://core.telegram.org/bots/api#editmessagereplymarkup */
    public struct EditMessageReplyMarkupParams: Codable {
        /** String | Unique identifier of the business connection on behalf of which the message to be edited was sent */
        public let business_connection_id: String?
        /** Integer or String | Required if inline_message_id is not specified. Unique identifier for the target chat or username of the target channel (in the format @channelusername) */
        public let chat_id: Either2<Int, String>?
        /** Integer | Required if inline_message_id is not specified. Identifier of the message to edit */
        public let message_id: Int?
        /** String | Required if chat_id and message_id are not specified. Identifier of the inline message */
        public let inline_message_id: String?
        /** InlineKeyboardMarkup | A JSON-serialized object for an inline keyboard. */
        public let reply_markup: InlineKeyboardMarkup?
        public init(business_connection_id: String? = nil ,chat_id: Either2<Int, String>? = nil ,message_id: Int? = nil ,inline_message_id: String? = nil ,reply_markup: InlineKeyboardMarkup? = nil) {
            self.business_connection_id = business_connection_id
            self.chat_id = chat_id
            self.message_id = message_id
            self.inline_message_id = inline_message_id
            self.reply_markup = reply_markup
        }
    }
}

extension TelegramAPI {

    public typealias EditMessageReplyMarkupResponse = ResponseSuccess<Either2<Message, Bool>>

    /**
     * https://core.telegram.org/bots/api#editmessagereplymarkup
     * Use this method to edit only the reply markup of messages. On success, if the edited message is not an inline message, the edited Message is returned, otherwise True is returned. Note that business messages that were not sent by the bot and do not contain an inline keyboard can only be edited within 48 hours from the time they were sent.
     */
    public func editMessageReplyMarkup(params: EditMessageReplyMarkupParams) throws -> EditMessageReplyMarkupResponse {
        let data = try request("editMessageReplyMarkup", params)
        return try JSONDecoder().decode(EditMessageReplyMarkupResponse.self, from: data)
    }
}

extension TelegramAPI {
    /** https://core.telegram.org/bots/api#stoppoll */
    public struct StopPollParams: Codable {
        /** String | Unique identifier of the business connection on behalf of which the message to be edited was sent */
        public let business_connection_id: String?
        /** Integer or String | Unique identifier for the target chat or username of the target channel (in the format @channelusername) */
        public let chat_id: Either2<Int, String>
        /** Integer | Identifier of the original message with the poll */
        public let message_id: Int
        /** InlineKeyboardMarkup | A JSON-serialized object for a new message inline keyboard. */
        public let reply_markup: InlineKeyboardMarkup?
        public init(business_connection_id: String? = nil ,chat_id: Either2<Int, String> ,message_id: Int ,reply_markup: InlineKeyboardMarkup? = nil) {
            self.business_connection_id = business_connection_id
            self.chat_id = chat_id
            self.message_id = message_id
            self.reply_markup = reply_markup
        }
    }
}

extension TelegramAPI {

    public typealias StopPollResponse = ResponseSuccess<Poll>

    /**
     * https://core.telegram.org/bots/api#stoppoll
     * Use this method to stop a poll which was sent by the bot. On success, the stopped Poll is returned.
     */
    public func stopPoll(params: StopPollParams) throws -> StopPollResponse {
        let data = try request("stopPoll", params)
        return try JSONDecoder().decode(StopPollResponse.self, from: data)
    }
}

extension TelegramAPI {
    /** https://core.telegram.org/bots/api#deletemessage */
    public struct DeleteMessageParams: Codable {
        /** Integer or String | Unique identifier for the target chat or username of the target channel (in the format @channelusername) */
        public let chat_id: Either2<Int, String>
        /** Integer | Identifier of the message to delete */
        public let message_id: Int
        public init(chat_id: Either2<Int, String> ,message_id: Int) {
            self.chat_id = chat_id
            self.message_id = message_id
        }
    }
}

extension TelegramAPI {

    public typealias DeleteMessageResponse = ResponseSuccess<Bool>

    /**
     * https://core.telegram.org/bots/api#deletemessage
     * Use this method to delete a message, including service messages, with the following limitations:
     * - A message can only be deleted if it was sent less than 48 hours ago.
     * - Service messages about a supergroup, channel, or forum topic creation can't be deleted.
     * - A dice message in a private chat can only be deleted if it was sent more than 24 hours ago.
     * - Bots can delete outgoing messages in private chats, groups, and supergroups.
     * - Bots can delete incoming messages in private chats.
     * - Bots granted can_post_messages permissions can delete outgoing messages in channels.
     * - If the bot is an administrator of a group, it can delete any message there.
     * - If the bot has can_delete_messages permission in a supergroup or a channel, it can delete any message there.
     * Returns True on success.
     */
    public func deleteMessage(params: DeleteMessageParams) throws -> DeleteMessageResponse {
        let data = try request("deleteMessage", params)
        return try JSONDecoder().decode(DeleteMessageResponse.self, from: data)
    }
}

extension TelegramAPI {
    /** https://core.telegram.org/bots/api#deletemessages */
    public struct DeleteMessagesParams: Codable {
        /** Integer or String | Unique identifier for the target chat or username of the target channel (in the format @channelusername) */
        public let chat_id: Either2<Int, String>
        /** Array of Integer | A JSON-serialized list of 1-100 identifiers of messages to delete. See deleteMessage for limitations on which messages can be deleted */
        public let message_ids: Array<Int>
        public init(chat_id: Either2<Int, String> ,message_ids: Array<Int>) {
            self.chat_id = chat_id
            self.message_ids = message_ids
        }
    }
}

extension TelegramAPI {

    public typealias DeleteMessagesResponse = ResponseSuccess<Bool>

    /**
     * https://core.telegram.org/bots/api#deletemessages
     * Use this method to delete multiple messages simultaneously. If some of the specified messages can't be found, they are skipped. Returns True on success.
     */
    public func deleteMessages(params: DeleteMessagesParams) throws -> DeleteMessagesResponse {
        let data = try request("deleteMessages", params)
        return try JSONDecoder().decode(DeleteMessagesResponse.self, from: data)
    }
}

extension TelegramAPI {
    /** https://core.telegram.org/bots/api#sendsticker */
    public struct SendStickerParams: Codable {
        /** String | Unique identifier of the business connection on behalf of which the message will be sent */
        public let business_connection_id: String?
        /** Integer or String | Unique identifier for the target chat or username of the target channel (in the format @channelusername) */
        public let chat_id: Either2<Int, String>
        /** Integer | Unique identifier for the target message thread (topic) of the forum; for forum supergroups only */
        public let message_thread_id: Int?
        /** InputFile or String | Sticker to send. Pass a file_id as String to send a file that exists on the Telegram servers (recommended), pass an HTTP URL as a String for Telegram to get a .WEBP sticker from the Internet, or upload a new .WEBP, .TGS, or .WEBM sticker using multipart/form-data. More information on Sending Files: https://core.telegram.org/bots/api#sending-files. Video and animated stickers can't be sent via an HTTP URL. */
        public let sticker: Either2<InputFile, String>
        /** String | Emoji associated with the sticker; only for just uploaded stickers */
        public let emoji: String?
        /** Boolean | Sends the message silently. Users will receive a notification with no sound. */
        public let disable_notification: Bool?
        /** Boolean | Protects the contents of the sent message from forwarding and saving */
        public let protect_content: Bool?
        /** Boolean | Pass True to allow up to 1000 messages per second, ignoring broadcasting limits for a fee of 0.1 Telegram Stars per message. The relevant Stars will be withdrawn from the bot's balance */
        public let allow_paid_broadcast: Bool?
        /** String | Unique identifier of the message effect to be added to the message; for private chats only */
        public let message_effect_id: String?
        /** ReplyParameters | Description of the message to reply to */
        public let reply_parameters: ReplyParameters?
        /** InlineKeyboardMarkup or ReplyKeyboardMarkup or ReplyKeyboardRemove or ForceReply | Additional interface options. A JSON-serialized object for an inline keyboard, custom reply keyboard, instructions to remove a reply keyboard or to force a reply from the user */
        public let reply_markup: Either4<InlineKeyboardMarkup, ReplyKeyboardMarkup, ReplyKeyboardRemove, ForceReply>?
        public init(business_connection_id: String? = nil ,chat_id: Either2<Int, String> ,message_thread_id: Int? = nil ,sticker: Either2<InputFile, String> ,emoji: String? = nil ,disable_notification: Bool? = nil ,protect_content: Bool? = nil ,allow_paid_broadcast: Bool? = nil ,message_effect_id: String? = nil ,reply_parameters: ReplyParameters? = nil ,reply_markup: Either4<InlineKeyboardMarkup, ReplyKeyboardMarkup, ReplyKeyboardRemove, ForceReply>? = nil) {
            self.business_connection_id = business_connection_id
            self.chat_id = chat_id
            self.message_thread_id = message_thread_id
            self.sticker = sticker
            self.emoji = emoji
            self.disable_notification = disable_notification
            self.protect_content = protect_content
            self.allow_paid_broadcast = allow_paid_broadcast
            self.message_effect_id = message_effect_id
            self.reply_parameters = reply_parameters
            self.reply_markup = reply_markup
        }
    }
}

extension TelegramAPI {

    public typealias SendStickerResponse = ResponseSuccess<Message>

    /**
     * https://core.telegram.org/bots/api#sendsticker
     * Use this method to send static .WEBP, animated .TGS, or video .WEBM stickers. On success, the sent Message is returned.
     */
    public func sendSticker(params: SendStickerParams) throws -> SendStickerResponse {
        let data = try request("sendSticker", params)
        return try JSONDecoder().decode(SendStickerResponse.self, from: data)
    }
}

extension TelegramAPI {
    /** https://core.telegram.org/bots/api#getstickerset */
    public struct GetStickerSetParams: Codable {
        /** String | Name of the sticker set */
        public let name: String
        public init(name: String) {
            self.name = name
        }
    }
}

extension TelegramAPI {

    public typealias GetStickerSetResponse = ResponseSuccess<StickerSet>

    /**
     * https://core.telegram.org/bots/api#getstickerset
     * Use this method to get a sticker set. On success, a StickerSet object is returned.
     */
    public func getStickerSet(params: GetStickerSetParams) throws -> GetStickerSetResponse {
        let data = try request("getStickerSet", params)
        return try JSONDecoder().decode(GetStickerSetResponse.self, from: data)
    }
}

extension TelegramAPI {
    /** https://core.telegram.org/bots/api#getcustomemojistickers */
    public struct GetCustomEmojiStickersParams: Codable {
        /** Array of String | A JSON-serialized list of custom emoji identifiers. At most 200 custom emoji identifiers can be specified. */
        public let custom_emoji_ids: Array<String>
        public init(custom_emoji_ids: Array<String>) {
            self.custom_emoji_ids = custom_emoji_ids
        }
    }
}

extension TelegramAPI {

    public typealias GetCustomEmojiStickersResponse = ResponseSuccess<Array<Sticker>>

    /**
     * https://core.telegram.org/bots/api#getcustomemojistickers
     * Use this method to get information about custom emoji stickers by their identifiers. Returns an Array of Sticker objects.
     */
    public func getCustomEmojiStickers(params: GetCustomEmojiStickersParams) throws -> GetCustomEmojiStickersResponse {
        let data = try request("getCustomEmojiStickers", params)
        return try JSONDecoder().decode(GetCustomEmojiStickersResponse.self, from: data)
    }
}

extension TelegramAPI {
    /** https://core.telegram.org/bots/api#uploadstickerfile */
    public struct UploadStickerFileParams: Codable {
        /** Integer | User identifier of sticker file owner */
        public let user_id: Int
        /** InputFile | A file with the sticker in .WEBP, .PNG, .TGS, or .WEBM format. See https://core.telegram.org/stickers for technical requirements. More information on Sending Files: https://core.telegram.org/bots/api#sending-files */
        public let sticker: InputFile
        /** String | Format of the sticker, must be one of "static", "animated", "video" */
        public let sticker_format: String
        public init(user_id: Int ,sticker: InputFile ,sticker_format: String) {
            self.user_id = user_id
            self.sticker = sticker
            self.sticker_format = sticker_format
        }
    }
}

extension TelegramAPI {

    public typealias UploadStickerFileResponse = ResponseSuccess<File>

    /**
     * https://core.telegram.org/bots/api#uploadstickerfile
     * Use this method to upload a file with a sticker for later use in the createNewStickerSet, addStickerToSet, or replaceStickerInSet methods (the file can be used multiple times). Returns the uploaded File on success.
     */
    public func uploadStickerFile(params: UploadStickerFileParams) throws -> UploadStickerFileResponse {
        let data = try request("uploadStickerFile", params)
        return try JSONDecoder().decode(UploadStickerFileResponse.self, from: data)
    }
}

extension TelegramAPI {
    /** https://core.telegram.org/bots/api#createnewstickerset */
    public struct CreateNewStickerSetParams: Codable {
        /** Integer | User identifier of created sticker set owner */
        public let user_id: Int
        /** String | Short name of sticker set, to be used in t.me/addstickers/ URLs (e.g., animals). Can contain only English letters, digits and underscores. Must begin with a letter, can't contain consecutive underscores and must end in "_by_<bot_username>". <bot_username> is case insensitive. 1-64 characters. */
        public let name: String
        /** String | Sticker set title, 1-64 characters */
        public let title: String
        /** Array of InputSticker | A JSON-serialized list of 1-50 initial stickers to be added to the sticker set */
        public let stickers: Array<InputSticker>
        /** String | Type of stickers in the set, pass "regular", "mask", or "custom_emoji". By default, a regular sticker set is created. */
        public let sticker_type: String?
        /** Boolean | Pass True if stickers in the sticker set must be repainted to the color of text when used in messages, the accent color if used as emoji status, white on chat photos, or another appropriate color based on context; for custom emoji sticker sets only */
        public let needs_repainting: Bool?
        public init(user_id: Int ,name: String ,title: String ,stickers: Array<InputSticker> ,sticker_type: String? = nil ,needs_repainting: Bool? = nil) {
            self.user_id = user_id
            self.name = name
            self.title = title
            self.stickers = stickers
            self.sticker_type = sticker_type
            self.needs_repainting = needs_repainting
        }
    }
}

extension TelegramAPI {

    public typealias CreateNewStickerSetResponse = ResponseSuccess<Bool>

    /**
     * https://core.telegram.org/bots/api#createnewstickerset
     * Use this method to create a new sticker set owned by a user. The bot will be able to edit the sticker set thus created. Returns True on success.
     */
    public func createNewStickerSet(params: CreateNewStickerSetParams) throws -> CreateNewStickerSetResponse {
        let data = try request("createNewStickerSet", params)
        return try JSONDecoder().decode(CreateNewStickerSetResponse.self, from: data)
    }
}

extension TelegramAPI {
    /** https://core.telegram.org/bots/api#addstickertoset */
    public struct AddStickerToSetParams: Codable {
        /** Integer | User identifier of sticker set owner */
        public let user_id: Int
        /** String | Sticker set name */
        public let name: String
        /** InputSticker | A JSON-serialized object with information about the added sticker. If exactly the same sticker had already been added to the set, then the set isn't changed. */
        public let sticker: InputSticker
        public init(user_id: Int ,name: String ,sticker: InputSticker) {
            self.user_id = user_id
            self.name = name
            self.sticker = sticker
        }
    }
}

extension TelegramAPI {

    public typealias AddStickerToSetResponse = ResponseSuccess<Bool>

    /**
     * https://core.telegram.org/bots/api#addstickertoset
     * Use this method to add a new sticker to a set created by the bot. Emoji sticker sets can have up to 200 stickers. Other sticker sets can have up to 120 stickers. Returns True on success.
     */
    public func addStickerToSet(params: AddStickerToSetParams) throws -> AddStickerToSetResponse {
        let data = try request("addStickerToSet", params)
        return try JSONDecoder().decode(AddStickerToSetResponse.self, from: data)
    }
}

extension TelegramAPI {
    /** https://core.telegram.org/bots/api#setstickerpositioninset */
    public struct SetStickerPositionInSetParams: Codable {
        /** String | File identifier of the sticker */
        public let sticker: String
        /** Integer | New sticker position in the set, zero-based */
        public let position: Int
        public init(sticker: String ,position: Int) {
            self.sticker = sticker
            self.position = position
        }
    }
}

extension TelegramAPI {

    public typealias SetStickerPositionInSetResponse = ResponseSuccess<Bool>

    /**
     * https://core.telegram.org/bots/api#setstickerpositioninset
     * Use this method to move a sticker in a set created by the bot to a specific position. Returns True on success.
     */
    public func setStickerPositionInSet(params: SetStickerPositionInSetParams) throws -> SetStickerPositionInSetResponse {
        let data = try request("setStickerPositionInSet", params)
        return try JSONDecoder().decode(SetStickerPositionInSetResponse.self, from: data)
    }
}

extension TelegramAPI {
    /** https://core.telegram.org/bots/api#deletestickerfromset */
    public struct DeleteStickerFromSetParams: Codable {
        /** String | File identifier of the sticker */
        public let sticker: String
        public init(sticker: String) {
            self.sticker = sticker
        }
    }
}

extension TelegramAPI {

    public typealias DeleteStickerFromSetResponse = ResponseSuccess<Bool>

    /**
     * https://core.telegram.org/bots/api#deletestickerfromset
     * Use this method to delete a sticker from a set created by the bot. Returns True on success.
     */
    public func deleteStickerFromSet(params: DeleteStickerFromSetParams) throws -> DeleteStickerFromSetResponse {
        let data = try request("deleteStickerFromSet", params)
        return try JSONDecoder().decode(DeleteStickerFromSetResponse.self, from: data)
    }
}

extension TelegramAPI {
    /** https://core.telegram.org/bots/api#replacestickerinset */
    public struct ReplaceStickerInSetParams: Codable {
        /** Integer | User identifier of the sticker set owner */
        public let user_id: Int
        /** String | Sticker set name */
        public let name: String
        /** String | File identifier of the replaced sticker */
        public let old_sticker: String
        /** InputSticker | A JSON-serialized object with information about the added sticker. If exactly the same sticker had already been added to the set, then the set remains unchanged. */
        public let sticker: InputSticker
        public init(user_id: Int ,name: String ,old_sticker: String ,sticker: InputSticker) {
            self.user_id = user_id
            self.name = name
            self.old_sticker = old_sticker
            self.sticker = sticker
        }
    }
}

extension TelegramAPI {

    public typealias ReplaceStickerInSetResponse = ResponseSuccess<Bool>

    /**
     * https://core.telegram.org/bots/api#replacestickerinset
     * Use this method to replace an existing sticker in a sticker set with a new one. The method is equivalent to calling deleteStickerFromSet, then addStickerToSet, then setStickerPositionInSet. Returns True on success.
     */
    public func replaceStickerInSet(params: ReplaceStickerInSetParams) throws -> ReplaceStickerInSetResponse {
        let data = try request("replaceStickerInSet", params)
        return try JSONDecoder().decode(ReplaceStickerInSetResponse.self, from: data)
    }
}

extension TelegramAPI {
    /** https://core.telegram.org/bots/api#setstickeremojilist */
    public struct SetStickerEmojiListParams: Codable {
        /** String | File identifier of the sticker */
        public let sticker: String
        /** Array of String | A JSON-serialized list of 1-20 emoji associated with the sticker */
        public let emoji_list: Array<String>
        public init(sticker: String ,emoji_list: Array<String>) {
            self.sticker = sticker
            self.emoji_list = emoji_list
        }
    }
}

extension TelegramAPI {

    public typealias SetStickerEmojiListResponse = ResponseSuccess<Bool>

    /**
     * https://core.telegram.org/bots/api#setstickeremojilist
     * Use this method to change the list of emoji assigned to a regular or custom emoji sticker. The sticker must belong to a sticker set created by the bot. Returns True on success.
     */
    public func setStickerEmojiList(params: SetStickerEmojiListParams) throws -> SetStickerEmojiListResponse {
        let data = try request("setStickerEmojiList", params)
        return try JSONDecoder().decode(SetStickerEmojiListResponse.self, from: data)
    }
}

extension TelegramAPI {
    /** https://core.telegram.org/bots/api#setstickerkeywords */
    public struct SetStickerKeywordsParams: Codable {
        /** String | File identifier of the sticker */
        public let sticker: String
        /** Array of String | A JSON-serialized list of 0-20 search keywords for the sticker with total length of up to 64 characters */
        public let keywords: Array<String>?
        public init(sticker: String ,keywords: Array<String>? = nil) {
            self.sticker = sticker
            self.keywords = keywords
        }
    }
}

extension TelegramAPI {

    public typealias SetStickerKeywordsResponse = ResponseSuccess<Bool>

    /**
     * https://core.telegram.org/bots/api#setstickerkeywords
     * Use this method to change search keywords assigned to a regular or custom emoji sticker. The sticker must belong to a sticker set created by the bot. Returns True on success.
     */
    public func setStickerKeywords(params: SetStickerKeywordsParams) throws -> SetStickerKeywordsResponse {
        let data = try request("setStickerKeywords", params)
        return try JSONDecoder().decode(SetStickerKeywordsResponse.self, from: data)
    }
}

extension TelegramAPI {
    /** https://core.telegram.org/bots/api#setstickermaskposition */
    public struct SetStickerMaskPositionParams: Codable {
        /** String | File identifier of the sticker */
        public let sticker: String
        /** MaskPosition | A JSON-serialized object with the position where the mask should be placed on faces. Omit the parameter to remove the mask position. */
        public let mask_position: MaskPosition?
        public init(sticker: String ,mask_position: MaskPosition? = nil) {
            self.sticker = sticker
            self.mask_position = mask_position
        }
    }
}

extension TelegramAPI {

    public typealias SetStickerMaskPositionResponse = ResponseSuccess<Bool>

    /**
     * https://core.telegram.org/bots/api#setstickermaskposition
     * Use this method to change the mask position of a mask sticker. The sticker must belong to a sticker set that was created by the bot. Returns True on success.
     */
    public func setStickerMaskPosition(params: SetStickerMaskPositionParams) throws -> SetStickerMaskPositionResponse {
        let data = try request("setStickerMaskPosition", params)
        return try JSONDecoder().decode(SetStickerMaskPositionResponse.self, from: data)
    }
}

extension TelegramAPI {
    /** https://core.telegram.org/bots/api#setstickersettitle */
    public struct SetStickerSetTitleParams: Codable {
        /** String | Sticker set name */
        public let name: String
        /** String | Sticker set title, 1-64 characters */
        public let title: String
        public init(name: String ,title: String) {
            self.name = name
            self.title = title
        }
    }
}

extension TelegramAPI {

    public typealias SetStickerSetTitleResponse = ResponseSuccess<Bool>

    /**
     * https://core.telegram.org/bots/api#setstickersettitle
     * Use this method to set the title of a created sticker set. Returns True on success.
     */
    public func setStickerSetTitle(params: SetStickerSetTitleParams) throws -> SetStickerSetTitleResponse {
        let data = try request("setStickerSetTitle", params)
        return try JSONDecoder().decode(SetStickerSetTitleResponse.self, from: data)
    }
}

extension TelegramAPI {
    /** https://core.telegram.org/bots/api#setstickersetthumbnail */
    public struct SetStickerSetThumbnailParams: Codable {
        /** String | Sticker set name */
        public let name: String
        /** Integer | User identifier of the sticker set owner */
        public let user_id: Int
        /** InputFile or String | A .WEBP or .PNG image with the thumbnail, must be up to 128 kilobytes in size and have a width and height of exactly 100px, or a .TGS animation with a thumbnail up to 32 kilobytes in size (see https://core.telegram.org/stickers#animation-requirements for animated sticker technical requirements), or a .WEBM video with the thumbnail up to 32 kilobytes in size; see https://core.telegram.org/stickers#video-requirements for video sticker technical requirements. Pass a file_id as a String to send a file that already exists on the Telegram servers, pass an HTTP URL as a String for Telegram to get a file from the Internet, or upload a new one using multipart/form-data. More information on Sending Files: https://core.telegram.org/bots/api#sending-files. Animated and video sticker set thumbnails can't be uploaded via HTTP URL. If omitted, then the thumbnail is dropped and the first sticker is used as the thumbnail. */
        public let thumbnail: Either2<InputFile, String>?
        /** String | Format of the thumbnail, must be one of "static" for a .WEBP or .PNG image, "animated" for a .TGS animation, or "video" for a .WEBM video */
        public let format: String
        public init(name: String ,user_id: Int ,thumbnail: Either2<InputFile, String>? = nil ,format: String) {
            self.name = name
            self.user_id = user_id
            self.thumbnail = thumbnail
            self.format = format
        }
    }
}

extension TelegramAPI {

    public typealias SetStickerSetThumbnailResponse = ResponseSuccess<Bool>

    /**
     * https://core.telegram.org/bots/api#setstickersetthumbnail
     * Use this method to set the thumbnail of a regular or mask sticker set. The format of the thumbnail file must match the format of the stickers in the set. Returns True on success.
     */
    public func setStickerSetThumbnail(params: SetStickerSetThumbnailParams) throws -> SetStickerSetThumbnailResponse {
        let data = try request("setStickerSetThumbnail", params)
        return try JSONDecoder().decode(SetStickerSetThumbnailResponse.self, from: data)
    }
}

extension TelegramAPI {
    /** https://core.telegram.org/bots/api#setcustomemojistickersetthumbnail */
    public struct SetCustomEmojiStickerSetThumbnailParams: Codable {
        /** String | Sticker set name */
        public let name: String
        /** String | Custom emoji identifier of a sticker from the sticker set; pass an empty string to drop the thumbnail and use the first sticker as the thumbnail. */
        public let custom_emoji_id: String?
        public init(name: String ,custom_emoji_id: String? = nil) {
            self.name = name
            self.custom_emoji_id = custom_emoji_id
        }
    }
}

extension TelegramAPI {

    public typealias SetCustomEmojiStickerSetThumbnailResponse = ResponseSuccess<Bool>

    /**
     * https://core.telegram.org/bots/api#setcustomemojistickersetthumbnail
     * Use this method to set the thumbnail of a custom emoji sticker set. Returns True on success.
     */
    public func setCustomEmojiStickerSetThumbnail(params: SetCustomEmojiStickerSetThumbnailParams) throws -> SetCustomEmojiStickerSetThumbnailResponse {
        let data = try request("setCustomEmojiStickerSetThumbnail", params)
        return try JSONDecoder().decode(SetCustomEmojiStickerSetThumbnailResponse.self, from: data)
    }
}

extension TelegramAPI {
    /** https://core.telegram.org/bots/api#deletestickerset */
    public struct DeleteStickerSetParams: Codable {
        /** String | Sticker set name */
        public let name: String
        public init(name: String) {
            self.name = name
        }
    }
}

extension TelegramAPI {

    public typealias DeleteStickerSetResponse = ResponseSuccess<Bool>

    /**
     * https://core.telegram.org/bots/api#deletestickerset
     * Use this method to delete a sticker set that was created by the bot. Returns True on success.
     */
    public func deleteStickerSet(params: DeleteStickerSetParams) throws -> DeleteStickerSetResponse {
        let data = try request("deleteStickerSet", params)
        return try JSONDecoder().decode(DeleteStickerSetResponse.self, from: data)
    }
}

extension TelegramAPI {

    public typealias GetAvailableGiftsResponse = ResponseSuccess<Gifts>

    /**
     * https://core.telegram.org/bots/api#getavailablegifts
     * Returns the list of gifts that can be sent by the bot to users. Requires no parameters. Returns a Gifts object.
     */
    public func getAvailableGifts() throws -> GetAvailableGiftsResponse {
        let data = try request("getAvailableGifts", [String: String]())
        return try JSONDecoder().decode(GetAvailableGiftsResponse.self, from: data)
    }
}

extension TelegramAPI {
    /** https://core.telegram.org/bots/api#sendgift */
    public struct SendGiftParams: Codable {
        /** Integer | Unique identifier of the target user that will receive the gift */
        public let user_id: Int
        /** String | Identifier of the gift */
        public let gift_id: String
        /** Boolean | Pass True to pay for the gift upgrade from the bot's balance, thereby making the upgrade free for the receiver */
        public let pay_for_upgrade: Bool?
        /** String | Text that will be shown along with the gift; 0-255 characters */
        public let text: String?
        /** String | Mode for parsing entities in the text. See formatting options for more details. Entities other than "bold", "italic", "underline", "strikethrough", "spoiler", and "custom_emoji" are ignored. */
        public let text_parse_mode: String?
        /** Array of MessageEntity | A JSON-serialized list of special entities that appear in the gift text. It can be specified instead of text_parse_mode. Entities other than "bold", "italic", "underline", "strikethrough", "spoiler", and "custom_emoji" are ignored. */
        public let text_entities: Array<MessageEntity>?
        public init(user_id: Int ,gift_id: String ,pay_for_upgrade: Bool? = nil ,text: String? = nil ,text_parse_mode: String? = nil ,text_entities: Array<MessageEntity>? = nil) {
            self.user_id = user_id
            self.gift_id = gift_id
            self.pay_for_upgrade = pay_for_upgrade
            self.text = text
            self.text_parse_mode = text_parse_mode
            self.text_entities = text_entities
        }
    }
}

extension TelegramAPI {

    public typealias SendGiftResponse = ResponseSuccess<Bool>

    /**
     * https://core.telegram.org/bots/api#sendgift
     * Sends a gift to the given user. The gift can't be converted to Telegram Stars by the user. Returns True on success.
     */
    public func sendGift(params: SendGiftParams) throws -> SendGiftResponse {
        let data = try request("sendGift", params)
        return try JSONDecoder().decode(SendGiftResponse.self, from: data)
    }
}

extension TelegramAPI {
    /** https://core.telegram.org/bots/api#verifyuser */
    public struct VerifyUserParams: Codable {
        /** Integer | Unique identifier of the target user */
        public let user_id: Int
        /** String | Custom description for the verification; 0-70 characters. Must be empty if the organization isn't allowed to provide a custom verification description. */
        public let custom_description: String?
        public init(user_id: Int ,custom_description: String? = nil) {
            self.user_id = user_id
            self.custom_description = custom_description
        }
    }
}

extension TelegramAPI {

    public typealias VerifyUserResponse = ResponseSuccess<Bool>

    /**
     * https://core.telegram.org/bots/api#verifyuser
     * Verifies a user on behalf of the organization which is represented by the bot. Returns True on success.
     */
    public func verifyUser(params: VerifyUserParams) throws -> VerifyUserResponse {
        let data = try request("verifyUser", params)
        return try JSONDecoder().decode(VerifyUserResponse.self, from: data)
    }
}

extension TelegramAPI {
    /** https://core.telegram.org/bots/api#verifychat */
    public struct VerifyChatParams: Codable {
        /** Integer or String | Unique identifier for the target chat or username of the target channel (in the format @channelusername) */
        public let chat_id: Either2<Int, String>
        /** String | Custom description for the verification; 0-70 characters. Must be empty if the organization isn't allowed to provide a custom verification description. */
        public let custom_description: String?
        public init(chat_id: Either2<Int, String> ,custom_description: String? = nil) {
            self.chat_id = chat_id
            self.custom_description = custom_description
        }
    }
}

extension TelegramAPI {

    public typealias VerifyChatResponse = ResponseSuccess<Bool>

    /**
     * https://core.telegram.org/bots/api#verifychat
     * Verifies a chat on behalf of the organization which is represented by the bot. Returns True on success.
     */
    public func verifyChat(params: VerifyChatParams) throws -> VerifyChatResponse {
        let data = try request("verifyChat", params)
        return try JSONDecoder().decode(VerifyChatResponse.self, from: data)
    }
}

extension TelegramAPI {
    /** https://core.telegram.org/bots/api#removeuserverification */
    public struct RemoveUserVerificationParams: Codable {
        /** Integer | Unique identifier of the target user */
        public let user_id: Int
        public init(user_id: Int) {
            self.user_id = user_id
        }
    }
}

extension TelegramAPI {

    public typealias RemoveUserVerificationResponse = ResponseSuccess<Bool>

    /**
     * https://core.telegram.org/bots/api#removeuserverification
     * Removes verification from a user who is currently verified on behalf of the organization represented by the bot. Returns True on success.
     */
    public func removeUserVerification(params: RemoveUserVerificationParams) throws -> RemoveUserVerificationResponse {
        let data = try request("removeUserVerification", params)
        return try JSONDecoder().decode(RemoveUserVerificationResponse.self, from: data)
    }
}

extension TelegramAPI {
    /** https://core.telegram.org/bots/api#removechatverification */
    public struct RemoveChatVerificationParams: Codable {
        /** Integer or String | Unique identifier for the target chat or username of the target channel (in the format @channelusername) */
        public let chat_id: Either2<Int, String>
        public init(chat_id: Either2<Int, String>) {
            self.chat_id = chat_id
        }
    }
}

extension TelegramAPI {

    public typealias RemoveChatVerificationResponse = ResponseSuccess<Bool>

    /**
     * https://core.telegram.org/bots/api#removechatverification
     * Removes verification from a chat that is currently verified on behalf of the organization represented by the bot. Returns True on success.
     */
    public func removeChatVerification(params: RemoveChatVerificationParams) throws -> RemoveChatVerificationResponse {
        let data = try request("removeChatVerification", params)
        return try JSONDecoder().decode(RemoveChatVerificationResponse.self, from: data)
    }
}

extension TelegramAPI {
    /** https://core.telegram.org/bots/api#answerinlinequery */
    public struct AnswerInlineQueryParams: Codable {
        /** String | Unique identifier for the answered query */
        public let inline_query_id: String
        /** Array of InlineQueryResult | A JSON-serialized array of results for the inline query */
        public let results: Array<InlineQueryResult>
        /** Integer | The maximum amount of time in seconds that the result of the inline query may be cached on the server. Defaults to 300. */
        public let cache_time: Int?
        /** Boolean | Pass True if results may be cached on the server side only for the user that sent the query. By default, results may be returned to any user who sends the same query. */
        public let is_personal: Bool?
        /** String | Pass the offset that a client should send in the next query with the same text to receive more results. Pass an empty string if there are no more results or if you don't support pagination. Offset length can't exceed 64 bytes. */
        public let next_offset: String?
        /** InlineQueryResultsButton | A JSON-serialized object describing a button to be shown above inline query results */
        public let button: InlineQueryResultsButton?
        public init(inline_query_id: String ,results: Array<InlineQueryResult> ,cache_time: Int? = nil ,is_personal: Bool? = nil ,next_offset: String? = nil ,button: InlineQueryResultsButton? = nil) {
            self.inline_query_id = inline_query_id
            self.results = results
            self.cache_time = cache_time
            self.is_personal = is_personal
            self.next_offset = next_offset
            self.button = button
        }
    }
}

extension TelegramAPI {

    public typealias AnswerInlineQueryResponse = ResponseSuccess<Bool>

    /**
     * https://core.telegram.org/bots/api#answerinlinequery
     * Use this method to send answers to an inline query. On success, True is returned.
     * No more than 50 results per query are allowed.
     */
    public func answerInlineQuery(params: AnswerInlineQueryParams) throws -> AnswerInlineQueryResponse {
        let data = try request("answerInlineQuery", params)
        return try JSONDecoder().decode(AnswerInlineQueryResponse.self, from: data)
    }
}

extension TelegramAPI {
    /** https://core.telegram.org/bots/api#answerwebappquery */
    public struct AnswerWebAppQueryParams: Codable {
        /** String | Unique identifier for the query to be answered */
        public let web_app_query_id: String
        /** InlineQueryResult | A JSON-serialized object describing the message to be sent */
        public let result: InlineQueryResult
        public init(web_app_query_id: String ,result: InlineQueryResult) {
            self.web_app_query_id = web_app_query_id
            self.result = result
        }
    }
}

extension TelegramAPI {

    public typealias AnswerWebAppQueryResponse = ResponseSuccess<SentWebAppMessage>

    /**
     * https://core.telegram.org/bots/api#answerwebappquery
     * Use this method to set the result of an interaction with a Web App and send a corresponding message on behalf of the user to the chat from which the query originated. On success, a SentWebAppMessage object is returned.
     */
    public func answerWebAppQuery(params: AnswerWebAppQueryParams) throws -> AnswerWebAppQueryResponse {
        let data = try request("answerWebAppQuery", params)
        return try JSONDecoder().decode(AnswerWebAppQueryResponse.self, from: data)
    }
}

extension TelegramAPI {
    /** https://core.telegram.org/bots/api#savepreparedinlinemessage */
    public struct SavePreparedInlineMessageParams: Codable {
        /** Integer | Unique identifier of the target user that can use the prepared message */
        public let user_id: Int
        /** InlineQueryResult | A JSON-serialized object describing the message to be sent */
        public let result: InlineQueryResult
        /** Boolean | Pass True if the message can be sent to private chats with users */
        public let allow_user_chats: Bool?
        /** Boolean | Pass True if the message can be sent to private chats with bots */
        public let allow_bot_chats: Bool?
        /** Boolean | Pass True if the message can be sent to group and supergroup chats */
        public let allow_group_chats: Bool?
        /** Boolean | Pass True if the message can be sent to channel chats */
        public let allow_channel_chats: Bool?
        public init(user_id: Int ,result: InlineQueryResult ,allow_user_chats: Bool? = nil ,allow_bot_chats: Bool? = nil ,allow_group_chats: Bool? = nil ,allow_channel_chats: Bool? = nil) {
            self.user_id = user_id
            self.result = result
            self.allow_user_chats = allow_user_chats
            self.allow_bot_chats = allow_bot_chats
            self.allow_group_chats = allow_group_chats
            self.allow_channel_chats = allow_channel_chats
        }
    }
}

extension TelegramAPI {

    public typealias SavePreparedInlineMessageResponse = ResponseSuccess<PreparedInlineMessage>

    /**
     * https://core.telegram.org/bots/api#savepreparedinlinemessage
     * Stores a message that can be sent by a user of a Mini App. Returns a PreparedInlineMessage object.
     */
    public func savePreparedInlineMessage(params: SavePreparedInlineMessageParams) throws -> SavePreparedInlineMessageResponse {
        let data = try request("savePreparedInlineMessage", params)
        return try JSONDecoder().decode(SavePreparedInlineMessageResponse.self, from: data)
    }
}

extension TelegramAPI {
    /** https://core.telegram.org/bots/api#sendinvoice */
    public struct SendInvoiceParams: Codable {
        /** Integer or String | Unique identifier for the target chat or username of the target channel (in the format @channelusername) */
        public let chat_id: Either2<Int, String>
        /** Integer | Unique identifier for the target message thread (topic) of the forum; for forum supergroups only */
        public let message_thread_id: Int?
        /** String | Product name, 1-32 characters */
        public let title: String
        /** String | Product description, 1-255 characters */
        public let description: String
        /** String | Bot-defined invoice payload, 1-128 bytes. This will not be displayed to the user, use it for your internal processes. */
        public let payload: String
        /** String | Payment provider token, obtained via @BotFather. Pass an empty string for payments in Telegram Stars. */
        public let provider_token: String?
        /** String | Three-letter ISO 4217 currency code, see more on currencies. Pass "XTR" for payments in Telegram Stars. */
        public let currency: String
        /** Array of LabeledPrice | Price breakdown, a JSON-serialized list of components (e.g. product price, tax, discount, delivery cost, delivery tax, bonus, etc.). Must contain exactly one item for payments in Telegram Stars. */
        public let prices: Array<LabeledPrice>
        /** Integer | The maximum accepted amount for tips in the smallest units of the currency (integer, not float/double). For example, for a maximum tip of US$ 1.45 pass max_tip_amount = 145. See the exp parameter in currencies.json, it shows the number of digits past the decimal point for each currency (2 for the majority of currencies). Defaults to 0. Not supported for payments in Telegram Stars. */
        public let max_tip_amount: Int?
        /** Array of Integer | A JSON-serialized array of suggested amounts of tips in the smallest units of the currency (integer, not float/double). At most 4 suggested tip amounts can be specified. The suggested tip amounts must be positive, passed in a strictly increased order and must not exceed max_tip_amount. */
        public let suggested_tip_amounts: Array<Int>?
        /** String | Unique deep-linking parameter. If left empty, forwarded copies of the sent message will have a Pay button, allowing multiple users to pay directly from the forwarded message, using the same invoice. If non-empty, forwarded copies of the sent message will have a URL button with a deep link to the bot (instead of a Pay button), with the value used as the start parameter */
        public let start_parameter: String?
        /** String | JSON-serialized data about the invoice, which will be shared with the payment provider. A detailed description of required fields should be provided by the payment provider. */
        public let provider_data: String?
        /** String | URL of the product photo for the invoice. Can be a photo of the goods or a marketing image for a service. People like it better when they see what they are paying for. */
        public let photo_url: String?
        /** Integer | Photo size in bytes */
        public let photo_size: Int?
        /** Integer | Photo width */
        public let photo_width: Int?
        /** Integer | Photo height */
        public let photo_height: Int?
        /** Boolean | Pass True if you require the user's full name to complete the order. Ignored for payments in Telegram Stars. */
        public let need_name: Bool?
        /** Boolean | Pass True if you require the user's phone number to complete the order. Ignored for payments in Telegram Stars. */
        public let need_phone_number: Bool?
        /** Boolean | Pass True if you require the user's email address to complete the order. Ignored for payments in Telegram Stars. */
        public let need_email: Bool?
        /** Boolean | Pass True if you require the user's shipping address to complete the order. Ignored for payments in Telegram Stars. */
        public let need_shipping_address: Bool?
        /** Boolean | Pass True if the user's phone number should be sent to the provider. Ignored for payments in Telegram Stars. */
        public let send_phone_number_to_provider: Bool?
        /** Boolean | Pass True if the user's email address should be sent to the provider. Ignored for payments in Telegram Stars. */
        public let send_email_to_provider: Bool?
        /** Boolean | Pass True if the final price depends on the shipping method. Ignored for payments in Telegram Stars. */
        public let is_flexible: Bool?
        /** Boolean | Sends the message silently. Users will receive a notification with no sound. */
        public let disable_notification: Bool?
        /** Boolean | Protects the contents of the sent message from forwarding and saving */
        public let protect_content: Bool?
        /** Boolean | Pass True to allow up to 1000 messages per second, ignoring broadcasting limits for a fee of 0.1 Telegram Stars per message. The relevant Stars will be withdrawn from the bot's balance */
        public let allow_paid_broadcast: Bool?
        /** String | Unique identifier of the message effect to be added to the message; for private chats only */
        public let message_effect_id: String?
        /** ReplyParameters | Description of the message to reply to */
        public let reply_parameters: ReplyParameters?
        /** InlineKeyboardMarkup | A JSON-serialized object for an inline keyboard. If empty, one 'Pay total price' button will be shown. If not empty, the first button must be a Pay button. */
        public let reply_markup: InlineKeyboardMarkup?
        public init(chat_id: Either2<Int, String> ,message_thread_id: Int? = nil ,title: String ,description: String ,payload: String ,provider_token: String? = nil ,currency: String ,prices: Array<LabeledPrice> ,max_tip_amount: Int? = nil ,suggested_tip_amounts: Array<Int>? = nil ,start_parameter: String? = nil ,provider_data: String? = nil ,photo_url: String? = nil ,photo_size: Int? = nil ,photo_width: Int? = nil ,photo_height: Int? = nil ,need_name: Bool? = nil ,need_phone_number: Bool? = nil ,need_email: Bool? = nil ,need_shipping_address: Bool? = nil ,send_phone_number_to_provider: Bool? = nil ,send_email_to_provider: Bool? = nil ,is_flexible: Bool? = nil ,disable_notification: Bool? = nil ,protect_content: Bool? = nil ,allow_paid_broadcast: Bool? = nil ,message_effect_id: String? = nil ,reply_parameters: ReplyParameters? = nil ,reply_markup: InlineKeyboardMarkup? = nil) {
            self.chat_id = chat_id
            self.message_thread_id = message_thread_id
            self.title = title
            self.description = description
            self.payload = payload
            self.provider_token = provider_token
            self.currency = currency
            self.prices = prices
            self.max_tip_amount = max_tip_amount
            self.suggested_tip_amounts = suggested_tip_amounts
            self.start_parameter = start_parameter
            self.provider_data = provider_data
            self.photo_url = photo_url
            self.photo_size = photo_size
            self.photo_width = photo_width
            self.photo_height = photo_height
            self.need_name = need_name
            self.need_phone_number = need_phone_number
            self.need_email = need_email
            self.need_shipping_address = need_shipping_address
            self.send_phone_number_to_provider = send_phone_number_to_provider
            self.send_email_to_provider = send_email_to_provider
            self.is_flexible = is_flexible
            self.disable_notification = disable_notification
            self.protect_content = protect_content
            self.allow_paid_broadcast = allow_paid_broadcast
            self.message_effect_id = message_effect_id
            self.reply_parameters = reply_parameters
            self.reply_markup = reply_markup
        }
    }
}

extension TelegramAPI {

    public typealias SendInvoiceResponse = ResponseSuccess<Message>

    /**
     * https://core.telegram.org/bots/api#sendinvoice
     * Use this method to send invoices. On success, the sent Message is returned.
     */
    public func sendInvoice(params: SendInvoiceParams) throws -> SendInvoiceResponse {
        let data = try request("sendInvoice", params)
        return try JSONDecoder().decode(SendInvoiceResponse.self, from: data)
    }
}

extension TelegramAPI {
    /** https://core.telegram.org/bots/api#createinvoicelink */
    public struct CreateInvoiceLinkParams: Codable {
        /** String | Unique identifier of the business connection on behalf of which the link will be created. For payments in Telegram Stars only. */
        public let business_connection_id: String?
        /** String | Product name, 1-32 characters */
        public let title: String
        /** String | Product description, 1-255 characters */
        public let description: String
        /** String | Bot-defined invoice payload, 1-128 bytes. This will not be displayed to the user, use it for your internal processes. */
        public let payload: String
        /** String | Payment provider token, obtained via @BotFather. Pass an empty string for payments in Telegram Stars. */
        public let provider_token: String?
        /** String | Three-letter ISO 4217 currency code, see more on currencies. Pass "XTR" for payments in Telegram Stars. */
        public let currency: String
        /** Array of LabeledPrice | Price breakdown, a JSON-serialized list of components (e.g. product price, tax, discount, delivery cost, delivery tax, bonus, etc.). Must contain exactly one item for payments in Telegram Stars. */
        public let prices: Array<LabeledPrice>
        /** Integer | The number of seconds the subscription will be active for before the next payment. The currency must be set to "XTR" (Telegram Stars) if the parameter is used. Currently, it must always be 2592000 (30 days) if specified. Any number of subscriptions can be active for a given bot at the same time, including multiple concurrent subscriptions from the same user. Subscription price must no exceed 2500 Telegram Stars. */
        public let subscription_period: Int?
        /** Integer | The maximum accepted amount for tips in the smallest units of the currency (integer, not float/double). For example, for a maximum tip of US$ 1.45 pass max_tip_amount = 145. See the exp parameter in currencies.json, it shows the number of digits past the decimal point for each currency (2 for the majority of currencies). Defaults to 0. Not supported for payments in Telegram Stars. */
        public let max_tip_amount: Int?
        /** Array of Integer | A JSON-serialized array of suggested amounts of tips in the smallest units of the currency (integer, not float/double). At most 4 suggested tip amounts can be specified. The suggested tip amounts must be positive, passed in a strictly increased order and must not exceed max_tip_amount. */
        public let suggested_tip_amounts: Array<Int>?
        /** String | JSON-serialized data about the invoice, which will be shared with the payment provider. A detailed description of required fields should be provided by the payment provider. */
        public let provider_data: String?
        /** String | URL of the product photo for the invoice. Can be a photo of the goods or a marketing image for a service. */
        public let photo_url: String?
        /** Integer | Photo size in bytes */
        public let photo_size: Int?
        /** Integer | Photo width */
        public let photo_width: Int?
        /** Integer | Photo height */
        public let photo_height: Int?
        /** Boolean | Pass True if you require the user's full name to complete the order. Ignored for payments in Telegram Stars. */
        public let need_name: Bool?
        /** Boolean | Pass True if you require the user's phone number to complete the order. Ignored for payments in Telegram Stars. */
        public let need_phone_number: Bool?
        /** Boolean | Pass True if you require the user's email address to complete the order. Ignored for payments in Telegram Stars. */
        public let need_email: Bool?
        /** Boolean | Pass True if you require the user's shipping address to complete the order. Ignored for payments in Telegram Stars. */
        public let need_shipping_address: Bool?
        /** Boolean | Pass True if the user's phone number should be sent to the provider. Ignored for payments in Telegram Stars. */
        public let send_phone_number_to_provider: Bool?
        /** Boolean | Pass True if the user's email address should be sent to the provider. Ignored for payments in Telegram Stars. */
        public let send_email_to_provider: Bool?
        /** Boolean | Pass True if the final price depends on the shipping method. Ignored for payments in Telegram Stars. */
        public let is_flexible: Bool?
        public init(business_connection_id: String? = nil ,title: String ,description: String ,payload: String ,provider_token: String? = nil ,currency: String ,prices: Array<LabeledPrice> ,subscription_period: Int? = nil ,max_tip_amount: Int? = nil ,suggested_tip_amounts: Array<Int>? = nil ,provider_data: String? = nil ,photo_url: String? = nil ,photo_size: Int? = nil ,photo_width: Int? = nil ,photo_height: Int? = nil ,need_name: Bool? = nil ,need_phone_number: Bool? = nil ,need_email: Bool? = nil ,need_shipping_address: Bool? = nil ,send_phone_number_to_provider: Bool? = nil ,send_email_to_provider: Bool? = nil ,is_flexible: Bool? = nil) {
            self.business_connection_id = business_connection_id
            self.title = title
            self.description = description
            self.payload = payload
            self.provider_token = provider_token
            self.currency = currency
            self.prices = prices
            self.subscription_period = subscription_period
            self.max_tip_amount = max_tip_amount
            self.suggested_tip_amounts = suggested_tip_amounts
            self.provider_data = provider_data
            self.photo_url = photo_url
            self.photo_size = photo_size
            self.photo_width = photo_width
            self.photo_height = photo_height
            self.need_name = need_name
            self.need_phone_number = need_phone_number
            self.need_email = need_email
            self.need_shipping_address = need_shipping_address
            self.send_phone_number_to_provider = send_phone_number_to_provider
            self.send_email_to_provider = send_email_to_provider
            self.is_flexible = is_flexible
        }
    }
}

extension TelegramAPI {

    public typealias CreateInvoiceLinkResponse = ResponseSuccess<String>

    /**
     * https://core.telegram.org/bots/api#createinvoicelink
     * Use this method to create a link for an invoice. Returns the created invoice link as String on success.
     */
    public func createInvoiceLink(params: CreateInvoiceLinkParams) throws -> CreateInvoiceLinkResponse {
        let data = try request("createInvoiceLink", params)
        return try JSONDecoder().decode(CreateInvoiceLinkResponse.self, from: data)
    }
}

extension TelegramAPI {
    /** https://core.telegram.org/bots/api#answershippingquery */
    public struct AnswerShippingQueryParams: Codable {
        /** String | Unique identifier for the query to be answered */
        public let shipping_query_id: String
        /** Boolean | Pass True if delivery to the specified address is possible and False if there are any problems (for example, if delivery to the specified address is not possible) */
        public let ok: Bool
        /** Array of ShippingOption | Required if ok is True. A JSON-serialized array of available shipping options. */
        public let shipping_options: Array<ShippingOption>?
        /** String | Required if ok is False. Error message in human readable form that explains why it is impossible to complete the order (e.g. "Sorry, delivery to your desired address is unavailable"). Telegram will display this message to the user. */
        public let error_message: String?
        public init(shipping_query_id: String ,ok: Bool ,shipping_options: Array<ShippingOption>? = nil ,error_message: String? = nil) {
            self.shipping_query_id = shipping_query_id
            self.ok = ok
            self.shipping_options = shipping_options
            self.error_message = error_message
        }
    }
}

extension TelegramAPI {

    public typealias AnswerShippingQueryResponse = ResponseSuccess<Bool>

    /**
     * https://core.telegram.org/bots/api#answershippingquery
     * If you sent an invoice requesting a shipping address and the parameter is_flexible was specified, the Bot API will send an Update with a shipping_query field to the bot. Use this method to reply to shipping queries. On success, True is returned.
     */
    public func answerShippingQuery(params: AnswerShippingQueryParams) throws -> AnswerShippingQueryResponse {
        let data = try request("answerShippingQuery", params)
        return try JSONDecoder().decode(AnswerShippingQueryResponse.self, from: data)
    }
}

extension TelegramAPI {
    /** https://core.telegram.org/bots/api#answerprecheckoutquery */
    public struct AnswerPreCheckoutQueryParams: Codable {
        /** String | Unique identifier for the query to be answered */
        public let pre_checkout_query_id: String
        /** Boolean | Specify True if everything is alright (goods are available, etc.) and the bot is ready to proceed with the order. Use False if there are any problems. */
        public let ok: Bool
        /** String | Required if ok is False. Error message in human readable form that explains the reason for failure to proceed with the checkout (e.g. "Sorry, somebody just bought the last of our amazing black T-shirts while you were busy filling out your payment details. Please choose a different color or garment!"). Telegram will display this message to the user. */
        public let error_message: String?
        public init(pre_checkout_query_id: String ,ok: Bool ,error_message: String? = nil) {
            self.pre_checkout_query_id = pre_checkout_query_id
            self.ok = ok
            self.error_message = error_message
        }
    }
}

extension TelegramAPI {

    public typealias AnswerPreCheckoutQueryResponse = ResponseSuccess<Bool>

    /**
     * https://core.telegram.org/bots/api#answerprecheckoutquery
     * Once the user has confirmed their payment and shipping details, the Bot API sends the final confirmation in the form of an Update with the field pre_checkout_query. Use this method to respond to such pre-checkout queries. On success, True is returned. Note: The Bot API must receive an answer within 10 seconds after the pre-checkout query was sent.
     */
    public func answerPreCheckoutQuery(params: AnswerPreCheckoutQueryParams) throws -> AnswerPreCheckoutQueryResponse {
        let data = try request("answerPreCheckoutQuery", params)
        return try JSONDecoder().decode(AnswerPreCheckoutQueryResponse.self, from: data)
    }
}

extension TelegramAPI {
    /** https://core.telegram.org/bots/api#getstartransactions */
    public struct GetStarTransactionsParams: Codable {
        /** Integer | Number of transactions to skip in the response */
        public let offset: Int?
        /** Integer | The maximum number of transactions to be retrieved. Values between 1-100 are accepted. Defaults to 100. */
        public let limit: Int?
        public init(offset: Int? = nil ,limit: Int? = nil) {
            self.offset = offset
            self.limit = limit
        }
    }
}

extension TelegramAPI {

    public typealias GetStarTransactionsResponse = ResponseSuccess<StarTransactions>

    /**
     * https://core.telegram.org/bots/api#getstartransactions
     * Returns the bot's Telegram Star transactions in chronological order. On success, returns a StarTransactions object.
     */
    public func getStarTransactions(params: GetStarTransactionsParams) throws -> GetStarTransactionsResponse {
        let data = try request("getStarTransactions", params)
        return try JSONDecoder().decode(GetStarTransactionsResponse.self, from: data)
    }
}

extension TelegramAPI {
    /** https://core.telegram.org/bots/api#refundstarpayment */
    public struct RefundStarPaymentParams: Codable {
        /** Integer | Identifier of the user whose payment will be refunded */
        public let user_id: Int
        /** String | Telegram payment identifier */
        public let telegram_payment_charge_id: String
        public init(user_id: Int ,telegram_payment_charge_id: String) {
            self.user_id = user_id
            self.telegram_payment_charge_id = telegram_payment_charge_id
        }
    }
}

extension TelegramAPI {

    public typealias RefundStarPaymentResponse = ResponseSuccess<Bool>

    /**
     * https://core.telegram.org/bots/api#refundstarpayment
     * Refunds a successful payment in Telegram Stars. Returns True on success.
     */
    public func refundStarPayment(params: RefundStarPaymentParams) throws -> RefundStarPaymentResponse {
        let data = try request("refundStarPayment", params)
        return try JSONDecoder().decode(RefundStarPaymentResponse.self, from: data)
    }
}

extension TelegramAPI {
    /** https://core.telegram.org/bots/api#edituserstarsubscription */
    public struct EditUserStarSubscriptionParams: Codable {
        /** Integer | Identifier of the user whose subscription will be edited */
        public let user_id: Int
        /** String | Telegram payment identifier for the subscription */
        public let telegram_payment_charge_id: String
        /** Boolean | Pass True to cancel extension of the user subscription; the subscription must be active up to the end of the current subscription period. Pass False to allow the user to re-enable a subscription that was previously canceled by the bot. */
        public let is_canceled: Bool
        public init(user_id: Int ,telegram_payment_charge_id: String ,is_canceled: Bool) {
            self.user_id = user_id
            self.telegram_payment_charge_id = telegram_payment_charge_id
            self.is_canceled = is_canceled
        }
    }
}

extension TelegramAPI {

    public typealias EditUserStarSubscriptionResponse = ResponseSuccess<Bool>

    /**
     * https://core.telegram.org/bots/api#edituserstarsubscription
     * Allows the bot to cancel or re-enable extension of a subscription paid in Telegram Stars. Returns True on success.
     */
    public func editUserStarSubscription(params: EditUserStarSubscriptionParams) throws -> EditUserStarSubscriptionResponse {
        let data = try request("editUserStarSubscription", params)
        return try JSONDecoder().decode(EditUserStarSubscriptionResponse.self, from: data)
    }
}

extension TelegramAPI {
    /** https://core.telegram.org/bots/api#setpassportdataerrors */
    public struct SetPassportDataErrorsParams: Codable {
        /** Integer | User identifier */
        public let user_id: Int
        /** Array of PassportElementError | A JSON-serialized array describing the errors */
        public let errors: Array<PassportElementError>
        public init(user_id: Int ,errors: Array<PassportElementError>) {
            self.user_id = user_id
            self.errors = errors
        }
    }
}

extension TelegramAPI {

    public typealias SetPassportDataErrorsResponse = ResponseSuccess<Bool>

    /**
     * https://core.telegram.org/bots/api#setpassportdataerrors
     * Informs a user that some of the Telegram Passport elements they provided contains errors. The user will not be able to re-submit their Passport to you until the errors are fixed (the contents of the field for which you returned the error must change). Returns True on success.
     * Use this if the data submitted by the user doesn't satisfy the standards your service requires for any reason. For example, if a birthday date seems invalid, a submitted document is blurry, a scan shows evidence of tampering, etc. Supply some details in the error message to make sure the user knows how to correct the issues.
     */
    public func setPassportDataErrors(params: SetPassportDataErrorsParams) throws -> SetPassportDataErrorsResponse {
        let data = try request("setPassportDataErrors", params)
        return try JSONDecoder().decode(SetPassportDataErrorsResponse.self, from: data)
    }
}

extension TelegramAPI {
    /** https://core.telegram.org/bots/api#sendgame */
    public struct SendGameParams: Codable {
        /** String | Unique identifier of the business connection on behalf of which the message will be sent */
        public let business_connection_id: String?
        /** Integer | Unique identifier for the target chat */
        public let chat_id: Int
        /** Integer | Unique identifier for the target message thread (topic) of the forum; for forum supergroups only */
        public let message_thread_id: Int?
        /** String | Short name of the game, serves as the unique identifier for the game. Set up your games via @BotFather. */
        public let game_short_name: String
        /** Boolean | Sends the message silently. Users will receive a notification with no sound. */
        public let disable_notification: Bool?
        /** Boolean | Protects the contents of the sent message from forwarding and saving */
        public let protect_content: Bool?
        /** Boolean | Pass True to allow up to 1000 messages per second, ignoring broadcasting limits for a fee of 0.1 Telegram Stars per message. The relevant Stars will be withdrawn from the bot's balance */
        public let allow_paid_broadcast: Bool?
        /** String | Unique identifier of the message effect to be added to the message; for private chats only */
        public let message_effect_id: String?
        /** ReplyParameters | Description of the message to reply to */
        public let reply_parameters: ReplyParameters?
        /** InlineKeyboardMarkup | A JSON-serialized object for an inline keyboard. If empty, one 'Play game_title' button will be shown. If not empty, the first button must launch the game. */
        public let reply_markup: InlineKeyboardMarkup?
        public init(business_connection_id: String? = nil ,chat_id: Int ,message_thread_id: Int? = nil ,game_short_name: String ,disable_notification: Bool? = nil ,protect_content: Bool? = nil ,allow_paid_broadcast: Bool? = nil ,message_effect_id: String? = nil ,reply_parameters: ReplyParameters? = nil ,reply_markup: InlineKeyboardMarkup? = nil) {
            self.business_connection_id = business_connection_id
            self.chat_id = chat_id
            self.message_thread_id = message_thread_id
            self.game_short_name = game_short_name
            self.disable_notification = disable_notification
            self.protect_content = protect_content
            self.allow_paid_broadcast = allow_paid_broadcast
            self.message_effect_id = message_effect_id
            self.reply_parameters = reply_parameters
            self.reply_markup = reply_markup
        }
    }
}

extension TelegramAPI {

    public typealias SendGameResponse = ResponseSuccess<Message>

    /**
     * https://core.telegram.org/bots/api#sendgame
     * Use this method to send a game. On success, the sent Message is returned.
     */
    public func sendGame(params: SendGameParams) throws -> SendGameResponse {
        let data = try request("sendGame", params)
        return try JSONDecoder().decode(SendGameResponse.self, from: data)
    }
}

extension TelegramAPI {
    /** https://core.telegram.org/bots/api#setgamescore */
    public struct SetGameScoreParams: Codable {
        /** Integer | User identifier */
        public let user_id: Int
        /** Integer | New score, must be non-negative */
        public let score: Int
        /** Boolean | Pass True if the high score is allowed to decrease. This can be useful when fixing mistakes or banning cheaters */
        public let force: Bool?
        /** Boolean | Pass True if the game message should not be automatically edited to include the current scoreboard */
        public let disable_edit_message: Bool?
        /** Integer | Required if inline_message_id is not specified. Unique identifier for the target chat */
        public let chat_id: Int?
        /** Integer | Required if inline_message_id is not specified. Identifier of the sent message */
        public let message_id: Int?
        /** String | Required if chat_id and message_id are not specified. Identifier of the inline message */
        public let inline_message_id: String?
        public init(user_id: Int ,score: Int ,force: Bool? = nil ,disable_edit_message: Bool? = nil ,chat_id: Int? = nil ,message_id: Int? = nil ,inline_message_id: String? = nil) {
            self.user_id = user_id
            self.score = score
            self.force = force
            self.disable_edit_message = disable_edit_message
            self.chat_id = chat_id
            self.message_id = message_id
            self.inline_message_id = inline_message_id
        }
    }
}

extension TelegramAPI {

    public typealias SetGameScoreResponse = ResponseSuccess<Either2<Message, Bool>>

    /**
     * https://core.telegram.org/bots/api#setgamescore
     * Use this method to set the score of the specified user in a game message. On success, if the message is not an inline message, the Message is returned, otherwise True is returned. Returns an error, if the new score is not greater than the user's current score in the chat and force is False.
     */
    public func setGameScore(params: SetGameScoreParams) throws -> SetGameScoreResponse {
        let data = try request("setGameScore", params)
        return try JSONDecoder().decode(SetGameScoreResponse.self, from: data)
    }
}

extension TelegramAPI {
    /** https://core.telegram.org/bots/api#getgamehighscores */
    public struct GetGameHighScoresParams: Codable {
        /** Integer | Target user id */
        public let user_id: Int
        /** Integer | Required if inline_message_id is not specified. Unique identifier for the target chat */
        public let chat_id: Int?
        /** Integer | Required if inline_message_id is not specified. Identifier of the sent message */
        public let message_id: Int?
        /** String | Required if chat_id and message_id are not specified. Identifier of the inline message */
        public let inline_message_id: String?
        public init(user_id: Int ,chat_id: Int? = nil ,message_id: Int? = nil ,inline_message_id: String? = nil) {
            self.user_id = user_id
            self.chat_id = chat_id
            self.message_id = message_id
            self.inline_message_id = inline_message_id
        }
    }
}

extension TelegramAPI {

    public typealias GetGameHighScoresResponse = ResponseSuccess<Array<GameHighScore>>

    /**
     * https://core.telegram.org/bots/api#getgamehighscores
     * Use this method to get data for high score tables. Will return the score of the specified user and several of their neighbors in a game. Returns an Array of GameHighScore objects.
     */
    public func getGameHighScores(params: GetGameHighScoresParams) throws -> GetGameHighScoresResponse {
        let data = try request("getGameHighScores", params)
        return try JSONDecoder().decode(GetGameHighScoresResponse.self, from: data)
    }
}
extension TelegramAPI {

    public enum Either2<A: Codable, B: Codable>: Codable {
        case a(A)
        case b(B)

        public init(from decoder: Decoder) throws {
            let container = try decoder.singleValueContainer()
            if let value = try? container.decode(A.self) {
                self = .a(value)
            }
            else if let value = try? container.decode(B.self) {
                self = .b(value)
            }else {
                throw DecodingError.typeMismatch(Either2.self, DecodingError.Context(codingPath: decoder.codingPath, debugDescription: "Wrong type for Either2"))
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.singleValueContainer()
            switch self {
                case .a(let value):
                    try container.encode(value)
                case .b(let value):
                    try container.encode(value)
            }
        }
    }

    public enum Either3<A: Codable, B: Codable, C: Codable>: Codable {
        case a(A)
        case b(B)
        case c(C)

        public init(from decoder: Decoder) throws {
            let container = try decoder.singleValueContainer()
            if let value = try? container.decode(A.self) {
                self = .a(value)
            }
            else if let value = try? container.decode(B.self) {
                self = .b(value)
            }
            else if let value = try? container.decode(C.self) {
                self = .c(value)
            }else {
                throw DecodingError.typeMismatch(Either3.self, DecodingError.Context(codingPath: decoder.codingPath, debugDescription: "Wrong type for Either3"))
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.singleValueContainer()
            switch self {
                case .a(let value):
                    try container.encode(value)
                case .b(let value):
                    try container.encode(value)
                case .c(let value):
                    try container.encode(value)
            }
        }
    }

    public enum Either4<A: Codable, B: Codable, C: Codable, D: Codable>: Codable {
        case a(A)
        case b(B)
        case c(C)
        case d(D)

        public init(from decoder: Decoder) throws {
            let container = try decoder.singleValueContainer()
            if let value = try? container.decode(A.self) {
                self = .a(value)
            }
            else if let value = try? container.decode(B.self) {
                self = .b(value)
            }
            else if let value = try? container.decode(C.self) {
                self = .c(value)
            }
            else if let value = try? container.decode(D.self) {
                self = .d(value)
            }else {
                throw DecodingError.typeMismatch(Either4.self, DecodingError.Context(codingPath: decoder.codingPath, debugDescription: "Wrong type for Either4"))
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.singleValueContainer()
            switch self {
                case .a(let value):
                    try container.encode(value)
                case .b(let value):
                    try container.encode(value)
                case .c(let value):
                    try container.encode(value)
                case .d(let value):
                    try container.encode(value)
            }
        }
    }

}